// This C++ source file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version 11.0.0
// for hyconsoft_rnd (hyconsoft_rnd@hyconsoft) on Wed Dec 11 13:55:00 2024

// Copyright (c) 2000-2024 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

/* Including header files */

#include "PIPEasp_Types.hh"

namespace PIPEasp__Types {

/* Prototypes of static functions */

static void pre_init_module();

/* Literal string constants */

static const unsigned char module_checksum[] = { 0x1d, 0x47, 0xb9, 0x59, 0x71, 0xb0, 0xe9, 0x66, 0xe0, 0x19, 0x8d, 0x7d, 0x19, 0x94, 0x2b, 0xda };

/* Global variable definitions */

const XERdescriptor_t       ASP__PExecute_command_xer_ = { {"command>\n", "command>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ASP__PExecute_command_descr_ = { "@PIPEasp_Types.ASP_PExecute.command", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &ASP__PExecute_command_xer_, &CHARSTRING_json_, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__PExecute_stdin__xer_ = { {"stdin>\n", "stdin>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ASP__PExecute_stdin__descr_ = { "@PIPEasp_Types.ASP_PExecute.stdin", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &ASP__PExecute_stdin__xer_, &CHARSTRING_json_, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ASP__PExecute
const TTCN_Typedescriptor_t ASP__PExecute_descr_ = { "@PIPEasp_Types.ASP_PExecute", NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__PExecutePty_command_xer_ = { {"command>\n", "command>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ASP__PExecutePty_command_descr_ = { "@PIPEasp_Types.ASP_PExecutePty.command", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &ASP__PExecutePty_command_xer_, &CHARSTRING_json_, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__PExecutePty_stdin__xer_ = { {"stdin>\n", "stdin>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ASP__PExecutePty_stdin__descr_ = { "@PIPEasp_Types.ASP_PExecutePty.stdin", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &ASP__PExecutePty_stdin__xer_, &CHARSTRING_json_, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ASP__PExecutePty
const TTCN_Typedescriptor_t ASP__PExecutePty_descr_ = { "@PIPEasp_Types.ASP_PExecutePty", NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__PResult_stdout__xer_ = { {"stdout>\n", "stdout>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ASP__PResult_stdout__descr_ = { "@PIPEasp_Types.ASP_PResult.stdout", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &ASP__PResult_stdout__xer_, &CHARSTRING_json_, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__PResult_stderr__xer_ = { {"stderr>\n", "stderr>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ASP__PResult_stderr__descr_ = { "@PIPEasp_Types.ASP_PResult.stderr", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &ASP__PResult_stderr__xer_, &CHARSTRING_json_, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__PResult_code_xer_ = { {"code>\n", "code>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ASP__PResult_code_descr_ = { "@PIPEasp_Types.ASP_PResult.code", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &ASP__PResult_code_xer_, &INTEGER_json_, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ASP__PResult
const TTCN_Typedescriptor_t ASP__PResult_descr_ = { "@PIPEasp_Types.ASP_PResult", NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__PExecuteBinary_command_xer_ = { {"command>\n", "command>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ASP__PExecuteBinary_command_descr_ = { "@PIPEasp_Types.ASP_PExecuteBinary.command", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &ASP__PExecuteBinary_command_xer_, &CHARSTRING_json_, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__PExecuteBinary_stdin__xer_ = { {"stdin>\n", "stdin>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const int ASP__PExecuteBinary_stdin__oer_ext_arr_[0] = {};
const int ASP__PExecuteBinary_stdin__oer_p_[0] = {};
const TTCN_OERdescriptor_t ASP__PExecuteBinary_stdin__oer_ = { -1, TRUE, -1, FALSE, 0, 0, ASP__PExecuteBinary_stdin__oer_ext_arr_, 0, ASP__PExecuteBinary_stdin__oer_p_};
const TTCN_Typedescriptor_t ASP__PExecuteBinary_stdin__descr_ = { "@PIPEasp_Types.ASP_PExecuteBinary.stdin", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &ASP__PExecuteBinary_stdin__xer_, &OCTETSTRING_json_, &ASP__PExecuteBinary_stdin__oer_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ASP__PExecuteBinary
const TTCN_Typedescriptor_t ASP__PExecuteBinary_descr_ = { "@PIPEasp_Types.ASP_PExecuteBinary", NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__PExecuteBinaryPty_command_xer_ = { {"command>\n", "command>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ASP__PExecuteBinaryPty_command_descr_ = { "@PIPEasp_Types.ASP_PExecuteBinaryPty.command", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &ASP__PExecuteBinaryPty_command_xer_, &CHARSTRING_json_, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__PExecuteBinaryPty_stdin__xer_ = { {"stdin>\n", "stdin>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const int ASP__PExecuteBinaryPty_stdin__oer_ext_arr_[0] = {};
const int ASP__PExecuteBinaryPty_stdin__oer_p_[0] = {};
const TTCN_OERdescriptor_t ASP__PExecuteBinaryPty_stdin__oer_ = { -1, TRUE, -1, FALSE, 0, 0, ASP__PExecuteBinaryPty_stdin__oer_ext_arr_, 0, ASP__PExecuteBinaryPty_stdin__oer_p_};
const TTCN_Typedescriptor_t ASP__PExecuteBinaryPty_stdin__descr_ = { "@PIPEasp_Types.ASP_PExecuteBinaryPty.stdin", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &ASP__PExecuteBinaryPty_stdin__xer_, &OCTETSTRING_json_, &ASP__PExecuteBinaryPty_stdin__oer_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ASP__PExecuteBinaryPty
const TTCN_Typedescriptor_t ASP__PExecuteBinaryPty_descr_ = { "@PIPEasp_Types.ASP_PExecuteBinaryPty", NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__PResultBinary_stdout__xer_ = { {"stdout>\n", "stdout>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const int ASP__PResultBinary_stdout__oer_ext_arr_[0] = {};
const int ASP__PResultBinary_stdout__oer_p_[0] = {};
const TTCN_OERdescriptor_t ASP__PResultBinary_stdout__oer_ = { -1, TRUE, -1, FALSE, 0, 0, ASP__PResultBinary_stdout__oer_ext_arr_, 0, ASP__PResultBinary_stdout__oer_p_};
const TTCN_Typedescriptor_t ASP__PResultBinary_stdout__descr_ = { "@PIPEasp_Types.ASP_PResultBinary.stdout", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &ASP__PResultBinary_stdout__xer_, &OCTETSTRING_json_, &ASP__PResultBinary_stdout__oer_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__PResultBinary_stderr__xer_ = { {"stderr>\n", "stderr>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const int ASP__PResultBinary_stderr__oer_ext_arr_[0] = {};
const int ASP__PResultBinary_stderr__oer_p_[0] = {};
const TTCN_OERdescriptor_t ASP__PResultBinary_stderr__oer_ = { -1, TRUE, -1, FALSE, 0, 0, ASP__PResultBinary_stderr__oer_ext_arr_, 0, ASP__PResultBinary_stderr__oer_p_};
const TTCN_Typedescriptor_t ASP__PResultBinary_stderr__descr_ = { "@PIPEasp_Types.ASP_PResultBinary.stderr", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &ASP__PResultBinary_stderr__xer_, &OCTETSTRING_json_, &ASP__PResultBinary_stderr__oer_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__PResultBinary_code_xer_ = { {"code>\n", "code>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ASP__PResultBinary_code_descr_ = { "@PIPEasp_Types.ASP_PResultBinary.code", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &ASP__PResultBinary_code_xer_, &INTEGER_json_, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ASP__PResultBinary
const TTCN_Typedescriptor_t ASP__PResultBinary_descr_ = { "@PIPEasp_Types.ASP_PResultBinary", NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__PExecuteBackground_command_xer_ = { {"command>\n", "command>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ASP__PExecuteBackground_command_descr_ = { "@PIPEasp_Types.ASP_PExecuteBackground.command", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &ASP__PExecuteBackground_command_xer_, &CHARSTRING_json_, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ASP__PExecuteBackground
const TTCN_Typedescriptor_t ASP__PExecuteBackground_descr_ = { "@PIPEasp_Types.ASP_PExecuteBackground", NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__PExecuteBackgroundPty_command_xer_ = { {"command>\n", "command>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ASP__PExecuteBackgroundPty_command_descr_ = { "@PIPEasp_Types.ASP_PExecuteBackgroundPty.command", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &ASP__PExecuteBackgroundPty_command_xer_, &CHARSTRING_json_, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ASP__PExecuteBackgroundPty
const TTCN_Typedescriptor_t ASP__PExecuteBackgroundPty_descr_ = { "@PIPEasp_Types.ASP_PExecuteBackgroundPty", NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__PStdin_stdin__xer_ = { {"stdin>\n", "stdin>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ASP__PStdin_stdin__descr_ = { "@PIPEasp_Types.ASP_PStdin.stdin", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &ASP__PStdin_stdin__xer_, &CHARSTRING_json_, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ASP__PStdin
const TTCN_Typedescriptor_t ASP__PStdin_descr_ = { "@PIPEasp_Types.ASP_PStdin", NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__PStdout_stdout__xer_ = { {"stdout>\n", "stdout>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ASP__PStdout_stdout__descr_ = { "@PIPEasp_Types.ASP_PStdout.stdout", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &ASP__PStdout_stdout__xer_, &CHARSTRING_json_, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ASP__PStdout
const TTCN_Typedescriptor_t ASP__PStdout_descr_ = { "@PIPEasp_Types.ASP_PStdout", NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__PStderr_stderr__xer_ = { {"stderr>\n", "stderr>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ASP__PStderr_stderr__descr_ = { "@PIPEasp_Types.ASP_PStderr.stderr", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &ASP__PStderr_stderr__xer_, &CHARSTRING_json_, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ASP__PStderr
const TTCN_Typedescriptor_t ASP__PStderr_descr_ = { "@PIPEasp_Types.ASP_PStderr", NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__PStdinBinary_stdin__xer_ = { {"stdin>\n", "stdin>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const int ASP__PStdinBinary_stdin__oer_ext_arr_[0] = {};
const int ASP__PStdinBinary_stdin__oer_p_[0] = {};
const TTCN_OERdescriptor_t ASP__PStdinBinary_stdin__oer_ = { -1, TRUE, -1, FALSE, 0, 0, ASP__PStdinBinary_stdin__oer_ext_arr_, 0, ASP__PStdinBinary_stdin__oer_p_};
const TTCN_Typedescriptor_t ASP__PStdinBinary_stdin__descr_ = { "@PIPEasp_Types.ASP_PStdinBinary.stdin", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &ASP__PStdinBinary_stdin__xer_, &OCTETSTRING_json_, &ASP__PStdinBinary_stdin__oer_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ASP__PStdinBinary
const TTCN_Typedescriptor_t ASP__PStdinBinary_descr_ = { "@PIPEasp_Types.ASP_PStdinBinary", NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__PStdoutBinary_stdout__xer_ = { {"stdout>\n", "stdout>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const int ASP__PStdoutBinary_stdout__oer_ext_arr_[0] = {};
const int ASP__PStdoutBinary_stdout__oer_p_[0] = {};
const TTCN_OERdescriptor_t ASP__PStdoutBinary_stdout__oer_ = { -1, TRUE, -1, FALSE, 0, 0, ASP__PStdoutBinary_stdout__oer_ext_arr_, 0, ASP__PStdoutBinary_stdout__oer_p_};
const TTCN_Typedescriptor_t ASP__PStdoutBinary_stdout__descr_ = { "@PIPEasp_Types.ASP_PStdoutBinary.stdout", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &ASP__PStdoutBinary_stdout__xer_, &OCTETSTRING_json_, &ASP__PStdoutBinary_stdout__oer_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ASP__PStdoutBinary
const TTCN_Typedescriptor_t ASP__PStdoutBinary_descr_ = { "@PIPEasp_Types.ASP_PStdoutBinary", NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__PStderrBinary_stderr__xer_ = { {"stderr>\n", "stderr>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const int ASP__PStderrBinary_stderr__oer_ext_arr_[0] = {};
const int ASP__PStderrBinary_stderr__oer_p_[0] = {};
const TTCN_OERdescriptor_t ASP__PStderrBinary_stderr__oer_ = { -1, TRUE, -1, FALSE, 0, 0, ASP__PStderrBinary_stderr__oer_ext_arr_, 0, ASP__PStderrBinary_stderr__oer_p_};
const TTCN_Typedescriptor_t ASP__PStderrBinary_stderr__descr_ = { "@PIPEasp_Types.ASP_PStderrBinary.stderr", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &ASP__PStderrBinary_stderr__xer_, &OCTETSTRING_json_, &ASP__PStderrBinary_stderr__oer_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ASP__PStderrBinary
const TTCN_Typedescriptor_t ASP__PStderrBinary_descr_ = { "@PIPEasp_Types.ASP_PStderrBinary", NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__PKill_signal_xer_ = { {"signal>\n", "signal>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ASP__PKill_signal_descr_ = { "@PIPEasp_Types.ASP_PKill.signal", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &ASP__PKill_signal_xer_, &INTEGER_json_, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ASP__PKill
const TTCN_Typedescriptor_t ASP__PKill_descr_ = { "@PIPEasp_Types.ASP_PKill", NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__PExit_code_xer_ = { {"code>\n", "code>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ASP__PExit_code_descr_ = { "@PIPEasp_Types.ASP_PExit.code", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &ASP__PExit_code_xer_, &INTEGER_json_, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ASP__PExit
const TTCN_Typedescriptor_t ASP__PExit_descr_ = { "@PIPEasp_Types.ASP_PExit", NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__PLineMode_lineMode_xer_ = { {"lineMode>\n", "lineMode>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const int ASP__PLineMode_lineMode_oer_ext_arr_[0] = {};
const int ASP__PLineMode_lineMode_oer_p_[0] = {};
const TTCN_OERdescriptor_t ASP__PLineMode_lineMode_oer_ = { -1, TRUE, -1, FALSE, 0, 0, ASP__PLineMode_lineMode_oer_ext_arr_, 0, ASP__PLineMode_lineMode_oer_p_};
const TTCN_Typedescriptor_t ASP__PLineMode_lineMode_descr_ = { "@PIPEasp_Types.ASP_PLineMode.lineMode", &BOOLEAN_ber_, &BOOLEAN_raw_, &BOOLEAN_text_, &ASP__PLineMode_lineMode_xer_, &BOOLEAN_json_, &ASP__PLineMode_lineMode_oer_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ASP__PLineMode
const TTCN_Typedescriptor_t ASP__PLineMode_descr_ = { "@PIPEasp_Types.ASP_PLineMode", NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__PError_errorMessage_xer_ = { {"errorMessage>\n", "errorMessage>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ASP__PError_errorMessage_descr_ = { "@PIPEasp_Types.ASP_PError.errorMessage", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &ASP__PError_errorMessage_xer_, &CHARSTRING_json_, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ASP__PError
const TTCN_Typedescriptor_t ASP__PError_descr_ = { "@PIPEasp_Types.ASP_PError", NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ASP__PEndOfInput
const TTCN_Typedescriptor_t ASP__PEndOfInput_descr_ = { "@PIPEasp_Types.ASP_PEndOfInput", NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__Parallel__Command_p__id_xer_ = { {"p_id>\n", "p_id>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ASP__Parallel__Command_p__id_descr_ = { "@PIPEasp_Types.ASP_Parallel_Command.p_id", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &ASP__Parallel__Command_p__id_xer_, &INTEGER_json_, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ASP__Commands
const TTCN_Typedescriptor_t ASP__Commands_descr_ = { "@PIPEasp_Types.ASP_Commands", NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ASP__Parallel__Command
const TTCN_Typedescriptor_t ASP__Parallel__Command_descr_ = { "@PIPEasp_Types.ASP_Parallel_Command", NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__Parrallel__Result_p__id_xer_ = { {"p_id>\n", "p_id>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ASP__Parrallel__Result_p__id_descr_ = { "@PIPEasp_Types.ASP_Parrallel_Result.p_id", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &ASP__Parrallel__Result_p__id_xer_, &INTEGER_json_, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ASP__Results
const TTCN_Typedescriptor_t ASP__Results_descr_ = { "@PIPEasp_Types.ASP_Results", NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ASP__Parrallel__Result
const TTCN_Typedescriptor_t ASP__Parrallel__Result_descr_ = { "@PIPEasp_Types.ASP_Parrallel_Result", NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
TTCN_Module module_object("PIPEasp_Types", __DATE__, __TIME__, module_checksum, pre_init_module, NULL, 0U, 4294967295U, 4294967295U, 4294967295U, NULL, 0LU, 0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

static const RuntimeVersionChecker ver_checker(  current_runtime_version.requires_major_version_11,
  current_runtime_version.requires_minor_version_0,
  current_runtime_version.requires_patch_level_0,  current_runtime_version.requires_runtime_1);

/* Member functions of C++ classes */

ASP__PExecute::ASP__PExecute()
{
}

ASP__PExecute::ASP__PExecute(const CHARSTRING& par_command,
    const CHARSTRING& par_stdin_)
  :   field_command(par_command),
  field_stdin_(par_stdin_)
{
}

ASP__PExecute::ASP__PExecute(const ASP__PExecute& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @PIPEasp_Types.ASP_PExecute.");
if (other_value.command().is_bound()) field_command = other_value.command();
else field_command.clean_up();
if (other_value.stdin_().is_bound()) field_stdin_ = other_value.stdin_();
else field_stdin_.clean_up();
}

void ASP__PExecute::clean_up()
{
field_command.clean_up();
field_stdin_.clean_up();
}

const TTCN_Typedescriptor_t* ASP__PExecute::get_descriptor() const { return &ASP__PExecute_descr_; }
ASP__PExecute& ASP__PExecute::operator=(const ASP__PExecute& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @PIPEasp_Types.ASP_PExecute.");
  if (other_value.command().is_bound()) field_command = other_value.command();
  else field_command.clean_up();
  if (other_value.stdin_().is_bound()) field_stdin_ = other_value.stdin_();
  else field_stdin_.clean_up();
}
return *this;
}

boolean ASP__PExecute::operator==(const ASP__PExecute& other_value) const
{
return field_command==other_value.field_command
  && field_stdin_==other_value.field_stdin_;
}

boolean ASP__PExecute::is_bound() const
{
return (field_command.is_bound())
  || (field_stdin_.is_bound());
}
boolean ASP__PExecute::is_value() const
{
return field_command.is_value()
  && field_stdin_.is_value();
}
void ASP__PExecute::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ command := ");
field_command.log();
TTCN_Logger::log_event_str(", stdin := ");
field_stdin_.log();
TTCN_Logger::log_event_str(" }");
}

void ASP__PExecute::set_implicit_omit()
{
if (command().is_bound()) command().set_implicit_omit();
if (stdin_().is_bound()) stdin_().set_implicit_omit();
}

void ASP__PExecute::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record value of type @PIPEasp_Types.ASP_PExecute has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) command().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) stdin_().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "command")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          command().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stdin")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stdin_().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PIPEasp_Types.ASP_PExecute: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@PIPEasp_Types.ASP_PExecute");
  }
}

void ASP__PExecute::encode_text(Text_Buf& text_buf) const
{
field_command.encode_text(text_buf);
field_stdin_.encode_text(text_buf);
}

void ASP__PExecute::decode_text(Text_Buf& text_buf)
{
field_command.decode_text(text_buf);
field_stdin_.decode_text(text_buf);
}

struct ASP__PExecute_template::single_value_struct {
CHARSTRING_template field_command;
CHARSTRING_template field_stdin_;
};

void ASP__PExecute_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_command = ANY_VALUE;
single_value->field_stdin_ = ANY_VALUE;
}
}
}

void ASP__PExecute_template::copy_value(const ASP__PExecute& other_value)
{
single_value = new single_value_struct;
if (other_value.command().is_bound()) {
  single_value->field_command = other_value.command();
} else {
  single_value->field_command.clean_up();
}
if (other_value.stdin_().is_bound()) {
  single_value->field_stdin_ = other_value.stdin_();
} else {
  single_value->field_stdin_.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ASP__PExecute_template::copy_template(const ASP__PExecute_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.command().get_selection()) {
single_value->field_command = other_value.command();
} else {
single_value->field_command.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.stdin_().get_selection()) {
single_value->field_stdin_ = other_value.stdin_();
} else {
single_value->field_stdin_.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ASP__PExecute_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
case IMPLICATION_MATCH:
implication_.precondition = new ASP__PExecute_template(*other_value.implication_.precondition);
implication_.implied_template = new ASP__PExecute_template(*other_value.implication_.implied_template);
break;
case DYNAMIC_MATCH:
dyn_match = other_value.dyn_match;
dyn_match->ref_count++;
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PExecute.");
break;
}
set_selection(other_value);
}

ASP__PExecute_template::ASP__PExecute_template()
{
}

ASP__PExecute_template::ASP__PExecute_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ASP__PExecute_template::ASP__PExecute_template(const ASP__PExecute& other_value)
{
copy_value(other_value);
}

ASP__PExecute_template::ASP__PExecute_template(const OPTIONAL<ASP__PExecute>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__PExecute&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @PIPEasp_Types.ASP_PExecute from an unbound optional field.");
}
}

ASP__PExecute_template::ASP__PExecute_template(ASP__PExecute_template* p_precondition, ASP__PExecute_template* p_implied_template)
 : Base_Template(IMPLICATION_MATCH)
{
implication_.precondition = p_precondition;
implication_.implied_template = p_implied_template;
}

ASP__PExecute_template::ASP__PExecute_template(Dynamic_Match_Interface<ASP__PExecute>* p_dyn_match)
 : Base_Template(DYNAMIC_MATCH)
{
dyn_match = new dynmatch_struct<ASP__PExecute>;
dyn_match->ptr = p_dyn_match;
dyn_match->ref_count = 1;
}

ASP__PExecute_template::ASP__PExecute_template(const ASP__PExecute_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ASP__PExecute_template::~ASP__PExecute_template()
{
clean_up();
}

ASP__PExecute_template& ASP__PExecute_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ASP__PExecute_template& ASP__PExecute_template::operator=(const ASP__PExecute& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ASP__PExecute_template& ASP__PExecute_template::operator=(const OPTIONAL<ASP__PExecute>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__PExecute&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @PIPEasp_Types.ASP_PExecute.");
}
return *this;
}

ASP__PExecute_template& ASP__PExecute_template::operator=(const ASP__PExecute_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ASP__PExecute_template::match(const ASP__PExecute& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.command().is_bound()) return FALSE;
if(!single_value->field_command.match(other_value.command(), legacy))return FALSE;
if(!other_value.stdin_().is_bound()) return FALSE;
if(!single_value->field_stdin_.match(other_value.stdin_(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
case CONJUNCTION_MATCH:
for (unsigned int i = 0; i < value_list.n_values; i++) {
if (!value_list.list_value[i].match(other_value)) {
return FALSE;
}
}
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match(other_value) || implication_.implied_template->match(other_value);
case DYNAMIC_MATCH:
return dyn_match->ptr->match(other_value);
default:
TTCN_error("Matching an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PExecute.");
}
return FALSE;
}

boolean ASP__PExecute_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
return single_value->field_command.is_bound()
 || single_value->field_stdin_.is_bound();
}

boolean ASP__PExecute_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value->field_command.is_value()
 && single_value->field_stdin_.is_value();
}

void ASP__PExecute_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
delete [] value_list.list_value;
break;
case IMPLICATION_MATCH:
delete implication_.precondition;
delete implication_.implied_template;
break;
case DYNAMIC_MATCH:
dyn_match->ref_count--;
if (dyn_match->ref_count == 0) {
delete dyn_match->ptr;
delete dyn_match;
}
break;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ASP__PExecute ASP__PExecute_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @PIPEasp_Types.ASP_PExecute.");
ASP__PExecute ret_val;
if (single_value->field_command.is_bound()) {
ret_val.command() = single_value->field_command.valueof();
}
if (single_value->field_stdin_.is_bound()) {
ret_val.stdin_() = single_value->field_stdin_.valueof();
}
return ret_val;
}

void ASP__PExecute_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST&& template_type != CONJUNCTION_MATCH)
TTCN_error("Setting an invalid list for a template of type @PIPEasp_Types.ASP_PExecute.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ASP__PExecute_template[list_length];
}

ASP__PExecute_template& ASP__PExecute_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST&& template_selection != CONJUNCTION_MATCH)
TTCN_error("Accessing a list element of a non-list template of type @PIPEasp_Types.ASP_PExecute.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @PIPEasp_Types.ASP_PExecute.");
return value_list.list_value[list_index];
}

CHARSTRING_template& ASP__PExecute_template::command()
{
set_specific();
return single_value->field_command;
}

const CHARSTRING_template& ASP__PExecute_template::command() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field command of a non-specific template of type @PIPEasp_Types.ASP_PExecute.");
return single_value->field_command;
}

CHARSTRING_template& ASP__PExecute_template::stdin_()
{
set_specific();
return single_value->field_stdin_;
}

const CHARSTRING_template& ASP__PExecute_template::stdin_() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field stdin of a non-specific template of type @PIPEasp_Types.ASP_PExecute.");
return single_value->field_stdin_;
}

int ASP__PExecute_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecute which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecute containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecute containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecute containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecute containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecute containing complemented list.");
  case CONJUNCTION_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecute containing a conjunction list match.");
  case IMPLICATION_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecute containing an implication match.");
  case DYNAMIC_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecute containing a dynamic match.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PExecute.");
  }
  return 0;
}

void ASP__PExecute_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ command := ");
single_value->field_command.log();
TTCN_Logger::log_event_str(", stdin := ");
single_value->field_stdin_.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case CONJUNCTION_MATCH:
if (template_selection == CONJUNCTION_MATCH) {
TTCN_Logger::log_event_str("conjunct");
}
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
case IMPLICATION_MATCH:
implication_.precondition->log();
TTCN_Logger::log_event_str(" implies ");
implication_.implied_template->log();
break;
case DYNAMIC_MATCH:
TTCN_Logger::log_event_str("@dynamic template");
break;
default:
log_generic();
}
log_ifpresent();
}

void ASP__PExecute_template::log_match(const ASP__PExecute& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_command.match(match_value.command(), legacy)){
TTCN_Logger::log_logmatch_info(".command");
single_value->field_command.log_match(match_value.command(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_stdin_.match(match_value.stdin_(), legacy)){
TTCN_Logger::log_logmatch_info(".stdin");
single_value->field_stdin_.log_match(match_value.stdin_(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ command := ");
single_value->field_command.log_match(match_value.command(), legacy);
TTCN_Logger::log_event_str(", stdin := ");
single_value->field_stdin_.log_match(match_value.stdin_(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ASP__PExecute_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_command.encode_text(text_buf);
single_value->field_stdin_.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PExecute.");
}
}

void ASP__PExecute_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_command.decode_text(text_buf);
single_value->field_stdin_.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ASP__PExecute_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @PIPEasp_Types.ASP_PExecute.");
}
}

void ASP__PExecute_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
  case Module_Param::MP_ConjunctList_Template: {
    ASP__PExecute_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : (param.get_type() == Module_Param::MP_ConjunctList_Template ? CONJUNCTION_MATCH : COMPLEMENTED_LIST), param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record template of type @PIPEasp_Types.ASP_PExecute has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) command().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) stdin_().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "command")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          command().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stdin")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stdin_().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PIPEasp_Types.ASP_PExecute: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  case Module_Param::MP_Implication_Template: {
    ASP__PExecute_template* precondition = new ASP__PExecute_template;
    precondition->set_param(*param.get_elem(0));
    ASP__PExecute_template* implied_template = new ASP__PExecute_template;
    implied_template->set_param(*param.get_elem(1));
    *this = ASP__PExecute_template(precondition, implied_template);
  } break;
  default:
    param.type_error("record template", "@PIPEasp_Types.ASP_PExecute");
  }
  is_ifpresent = param.get_ifpresent();
}

void ASP__PExecute_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_command.check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_PExecute");
single_value->field_stdin_.check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_PExecute");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@PIPEasp_Types.ASP_PExecute");
}

boolean ASP__PExecute_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ASP__PExecute_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match_omit() || implication_.implied_template->match_omit();
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ASP__PExecutePty::ASP__PExecutePty()
{
}

ASP__PExecutePty::ASP__PExecutePty(const CHARSTRING& par_command,
    const CHARSTRING& par_stdin_)
  :   field_command(par_command),
  field_stdin_(par_stdin_)
{
}

ASP__PExecutePty::ASP__PExecutePty(const ASP__PExecutePty& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @PIPEasp_Types.ASP_PExecutePty.");
if (other_value.command().is_bound()) field_command = other_value.command();
else field_command.clean_up();
if (other_value.stdin_().is_bound()) field_stdin_ = other_value.stdin_();
else field_stdin_.clean_up();
}

void ASP__PExecutePty::clean_up()
{
field_command.clean_up();
field_stdin_.clean_up();
}

const TTCN_Typedescriptor_t* ASP__PExecutePty::get_descriptor() const { return &ASP__PExecutePty_descr_; }
ASP__PExecutePty& ASP__PExecutePty::operator=(const ASP__PExecutePty& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @PIPEasp_Types.ASP_PExecutePty.");
  if (other_value.command().is_bound()) field_command = other_value.command();
  else field_command.clean_up();
  if (other_value.stdin_().is_bound()) field_stdin_ = other_value.stdin_();
  else field_stdin_.clean_up();
}
return *this;
}

boolean ASP__PExecutePty::operator==(const ASP__PExecutePty& other_value) const
{
return field_command==other_value.field_command
  && field_stdin_==other_value.field_stdin_;
}

boolean ASP__PExecutePty::is_bound() const
{
return (field_command.is_bound())
  || (field_stdin_.is_bound());
}
boolean ASP__PExecutePty::is_value() const
{
return field_command.is_value()
  && field_stdin_.is_value();
}
void ASP__PExecutePty::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ command := ");
field_command.log();
TTCN_Logger::log_event_str(", stdin := ");
field_stdin_.log();
TTCN_Logger::log_event_str(" }");
}

void ASP__PExecutePty::set_implicit_omit()
{
if (command().is_bound()) command().set_implicit_omit();
if (stdin_().is_bound()) stdin_().set_implicit_omit();
}

void ASP__PExecutePty::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record value of type @PIPEasp_Types.ASP_PExecutePty has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) command().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) stdin_().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "command")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          command().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stdin")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stdin_().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PIPEasp_Types.ASP_PExecutePty: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@PIPEasp_Types.ASP_PExecutePty");
  }
}

void ASP__PExecutePty::encode_text(Text_Buf& text_buf) const
{
field_command.encode_text(text_buf);
field_stdin_.encode_text(text_buf);
}

void ASP__PExecutePty::decode_text(Text_Buf& text_buf)
{
field_command.decode_text(text_buf);
field_stdin_.decode_text(text_buf);
}

struct ASP__PExecutePty_template::single_value_struct {
CHARSTRING_template field_command;
CHARSTRING_template field_stdin_;
};

void ASP__PExecutePty_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_command = ANY_VALUE;
single_value->field_stdin_ = ANY_VALUE;
}
}
}

void ASP__PExecutePty_template::copy_value(const ASP__PExecutePty& other_value)
{
single_value = new single_value_struct;
if (other_value.command().is_bound()) {
  single_value->field_command = other_value.command();
} else {
  single_value->field_command.clean_up();
}
if (other_value.stdin_().is_bound()) {
  single_value->field_stdin_ = other_value.stdin_();
} else {
  single_value->field_stdin_.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ASP__PExecutePty_template::copy_template(const ASP__PExecutePty_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.command().get_selection()) {
single_value->field_command = other_value.command();
} else {
single_value->field_command.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.stdin_().get_selection()) {
single_value->field_stdin_ = other_value.stdin_();
} else {
single_value->field_stdin_.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ASP__PExecutePty_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
case IMPLICATION_MATCH:
implication_.precondition = new ASP__PExecutePty_template(*other_value.implication_.precondition);
implication_.implied_template = new ASP__PExecutePty_template(*other_value.implication_.implied_template);
break;
case DYNAMIC_MATCH:
dyn_match = other_value.dyn_match;
dyn_match->ref_count++;
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PExecutePty.");
break;
}
set_selection(other_value);
}

ASP__PExecutePty_template::ASP__PExecutePty_template()
{
}

ASP__PExecutePty_template::ASP__PExecutePty_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ASP__PExecutePty_template::ASP__PExecutePty_template(const ASP__PExecutePty& other_value)
{
copy_value(other_value);
}

ASP__PExecutePty_template::ASP__PExecutePty_template(const OPTIONAL<ASP__PExecutePty>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__PExecutePty&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @PIPEasp_Types.ASP_PExecutePty from an unbound optional field.");
}
}

ASP__PExecutePty_template::ASP__PExecutePty_template(ASP__PExecutePty_template* p_precondition, ASP__PExecutePty_template* p_implied_template)
 : Base_Template(IMPLICATION_MATCH)
{
implication_.precondition = p_precondition;
implication_.implied_template = p_implied_template;
}

ASP__PExecutePty_template::ASP__PExecutePty_template(Dynamic_Match_Interface<ASP__PExecutePty>* p_dyn_match)
 : Base_Template(DYNAMIC_MATCH)
{
dyn_match = new dynmatch_struct<ASP__PExecutePty>;
dyn_match->ptr = p_dyn_match;
dyn_match->ref_count = 1;
}

ASP__PExecutePty_template::ASP__PExecutePty_template(const ASP__PExecutePty_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ASP__PExecutePty_template::~ASP__PExecutePty_template()
{
clean_up();
}

ASP__PExecutePty_template& ASP__PExecutePty_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ASP__PExecutePty_template& ASP__PExecutePty_template::operator=(const ASP__PExecutePty& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ASP__PExecutePty_template& ASP__PExecutePty_template::operator=(const OPTIONAL<ASP__PExecutePty>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__PExecutePty&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @PIPEasp_Types.ASP_PExecutePty.");
}
return *this;
}

ASP__PExecutePty_template& ASP__PExecutePty_template::operator=(const ASP__PExecutePty_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ASP__PExecutePty_template::match(const ASP__PExecutePty& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.command().is_bound()) return FALSE;
if(!single_value->field_command.match(other_value.command(), legacy))return FALSE;
if(!other_value.stdin_().is_bound()) return FALSE;
if(!single_value->field_stdin_.match(other_value.stdin_(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
case CONJUNCTION_MATCH:
for (unsigned int i = 0; i < value_list.n_values; i++) {
if (!value_list.list_value[i].match(other_value)) {
return FALSE;
}
}
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match(other_value) || implication_.implied_template->match(other_value);
case DYNAMIC_MATCH:
return dyn_match->ptr->match(other_value);
default:
TTCN_error("Matching an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PExecutePty.");
}
return FALSE;
}

boolean ASP__PExecutePty_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
return single_value->field_command.is_bound()
 || single_value->field_stdin_.is_bound();
}

boolean ASP__PExecutePty_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value->field_command.is_value()
 && single_value->field_stdin_.is_value();
}

void ASP__PExecutePty_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
delete [] value_list.list_value;
break;
case IMPLICATION_MATCH:
delete implication_.precondition;
delete implication_.implied_template;
break;
case DYNAMIC_MATCH:
dyn_match->ref_count--;
if (dyn_match->ref_count == 0) {
delete dyn_match->ptr;
delete dyn_match;
}
break;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ASP__PExecutePty ASP__PExecutePty_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @PIPEasp_Types.ASP_PExecutePty.");
ASP__PExecutePty ret_val;
if (single_value->field_command.is_bound()) {
ret_val.command() = single_value->field_command.valueof();
}
if (single_value->field_stdin_.is_bound()) {
ret_val.stdin_() = single_value->field_stdin_.valueof();
}
return ret_val;
}

void ASP__PExecutePty_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST&& template_type != CONJUNCTION_MATCH)
TTCN_error("Setting an invalid list for a template of type @PIPEasp_Types.ASP_PExecutePty.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ASP__PExecutePty_template[list_length];
}

ASP__PExecutePty_template& ASP__PExecutePty_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST&& template_selection != CONJUNCTION_MATCH)
TTCN_error("Accessing a list element of a non-list template of type @PIPEasp_Types.ASP_PExecutePty.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @PIPEasp_Types.ASP_PExecutePty.");
return value_list.list_value[list_index];
}

CHARSTRING_template& ASP__PExecutePty_template::command()
{
set_specific();
return single_value->field_command;
}

const CHARSTRING_template& ASP__PExecutePty_template::command() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field command of a non-specific template of type @PIPEasp_Types.ASP_PExecutePty.");
return single_value->field_command;
}

CHARSTRING_template& ASP__PExecutePty_template::stdin_()
{
set_specific();
return single_value->field_stdin_;
}

const CHARSTRING_template& ASP__PExecutePty_template::stdin_() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field stdin of a non-specific template of type @PIPEasp_Types.ASP_PExecutePty.");
return single_value->field_stdin_;
}

int ASP__PExecutePty_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecutePty which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecutePty containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecutePty containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecutePty containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecutePty containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecutePty containing complemented list.");
  case CONJUNCTION_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecutePty containing a conjunction list match.");
  case IMPLICATION_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecutePty containing an implication match.");
  case DYNAMIC_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecutePty containing a dynamic match.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PExecutePty.");
  }
  return 0;
}

void ASP__PExecutePty_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ command := ");
single_value->field_command.log();
TTCN_Logger::log_event_str(", stdin := ");
single_value->field_stdin_.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case CONJUNCTION_MATCH:
if (template_selection == CONJUNCTION_MATCH) {
TTCN_Logger::log_event_str("conjunct");
}
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
case IMPLICATION_MATCH:
implication_.precondition->log();
TTCN_Logger::log_event_str(" implies ");
implication_.implied_template->log();
break;
case DYNAMIC_MATCH:
TTCN_Logger::log_event_str("@dynamic template");
break;
default:
log_generic();
}
log_ifpresent();
}

void ASP__PExecutePty_template::log_match(const ASP__PExecutePty& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_command.match(match_value.command(), legacy)){
TTCN_Logger::log_logmatch_info(".command");
single_value->field_command.log_match(match_value.command(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_stdin_.match(match_value.stdin_(), legacy)){
TTCN_Logger::log_logmatch_info(".stdin");
single_value->field_stdin_.log_match(match_value.stdin_(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ command := ");
single_value->field_command.log_match(match_value.command(), legacy);
TTCN_Logger::log_event_str(", stdin := ");
single_value->field_stdin_.log_match(match_value.stdin_(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ASP__PExecutePty_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_command.encode_text(text_buf);
single_value->field_stdin_.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PExecutePty.");
}
}

void ASP__PExecutePty_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_command.decode_text(text_buf);
single_value->field_stdin_.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ASP__PExecutePty_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @PIPEasp_Types.ASP_PExecutePty.");
}
}

void ASP__PExecutePty_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
  case Module_Param::MP_ConjunctList_Template: {
    ASP__PExecutePty_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : (param.get_type() == Module_Param::MP_ConjunctList_Template ? CONJUNCTION_MATCH : COMPLEMENTED_LIST), param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record template of type @PIPEasp_Types.ASP_PExecutePty has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) command().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) stdin_().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "command")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          command().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stdin")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stdin_().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PIPEasp_Types.ASP_PExecutePty: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  case Module_Param::MP_Implication_Template: {
    ASP__PExecutePty_template* precondition = new ASP__PExecutePty_template;
    precondition->set_param(*param.get_elem(0));
    ASP__PExecutePty_template* implied_template = new ASP__PExecutePty_template;
    implied_template->set_param(*param.get_elem(1));
    *this = ASP__PExecutePty_template(precondition, implied_template);
  } break;
  default:
    param.type_error("record template", "@PIPEasp_Types.ASP_PExecutePty");
  }
  is_ifpresent = param.get_ifpresent();
}

void ASP__PExecutePty_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_command.check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_PExecutePty");
single_value->field_stdin_.check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_PExecutePty");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@PIPEasp_Types.ASP_PExecutePty");
}

boolean ASP__PExecutePty_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ASP__PExecutePty_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match_omit() || implication_.implied_template->match_omit();
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ASP__PResult::ASP__PResult()
{
}

ASP__PResult::ASP__PResult(const CHARSTRING& par_stdout_,
    const CHARSTRING& par_stderr_,
    const INTEGER& par_code)
  :   field_stdout_(par_stdout_),
  field_stderr_(par_stderr_),
  field_code(par_code)
{
}

ASP__PResult::ASP__PResult(const ASP__PResult& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @PIPEasp_Types.ASP_PResult.");
if (other_value.stdout_().is_bound()) field_stdout_ = other_value.stdout_();
else field_stdout_.clean_up();
if (other_value.stderr_().is_bound()) field_stderr_ = other_value.stderr_();
else field_stderr_.clean_up();
if (other_value.code().is_bound()) field_code = other_value.code();
else field_code.clean_up();
}

void ASP__PResult::clean_up()
{
field_stdout_.clean_up();
field_stderr_.clean_up();
field_code.clean_up();
}

const TTCN_Typedescriptor_t* ASP__PResult::get_descriptor() const { return &ASP__PResult_descr_; }
ASP__PResult& ASP__PResult::operator=(const ASP__PResult& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @PIPEasp_Types.ASP_PResult.");
  if (other_value.stdout_().is_bound()) field_stdout_ = other_value.stdout_();
  else field_stdout_.clean_up();
  if (other_value.stderr_().is_bound()) field_stderr_ = other_value.stderr_();
  else field_stderr_.clean_up();
  if (other_value.code().is_bound()) field_code = other_value.code();
  else field_code.clean_up();
}
return *this;
}

boolean ASP__PResult::operator==(const ASP__PResult& other_value) const
{
return field_stdout_==other_value.field_stdout_
  && field_stderr_==other_value.field_stderr_
  && field_code==other_value.field_code;
}

boolean ASP__PResult::is_bound() const
{
return (field_stdout_.is_bound())
  || (field_stderr_.is_bound())
  || (field_code.is_bound());
}
boolean ASP__PResult::is_value() const
{
return field_stdout_.is_value()
  && field_stderr_.is_value()
  && field_code.is_value();
}
void ASP__PResult::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ stdout := ");
field_stdout_.log();
TTCN_Logger::log_event_str(", stderr := ");
field_stderr_.log();
TTCN_Logger::log_event_str(", code := ");
field_code.log();
TTCN_Logger::log_event_str(" }");
}

void ASP__PResult::set_implicit_omit()
{
if (stdout_().is_bound()) stdout_().set_implicit_omit();
if (stderr_().is_bound()) stderr_().set_implicit_omit();
if (code().is_bound()) code().set_implicit_omit();
}

void ASP__PResult::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (3<param.get_size()) {
      param.error("record value of type @PIPEasp_Types.ASP_PResult has 3 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) stdout_().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) stderr_().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) code().set_param(*param.get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stdout")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stdout_().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stderr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stderr_().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "code")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          code().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PIPEasp_Types.ASP_PResult: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@PIPEasp_Types.ASP_PResult");
  }
}

void ASP__PResult::encode_text(Text_Buf& text_buf) const
{
field_stdout_.encode_text(text_buf);
field_stderr_.encode_text(text_buf);
field_code.encode_text(text_buf);
}

void ASP__PResult::decode_text(Text_Buf& text_buf)
{
field_stdout_.decode_text(text_buf);
field_stderr_.decode_text(text_buf);
field_code.decode_text(text_buf);
}

struct ASP__PResult_template::single_value_struct {
CHARSTRING_template field_stdout_;
CHARSTRING_template field_stderr_;
INTEGER_template field_code;
};

void ASP__PResult_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_stdout_ = ANY_VALUE;
single_value->field_stderr_ = ANY_VALUE;
single_value->field_code = ANY_VALUE;
}
}
}

void ASP__PResult_template::copy_value(const ASP__PResult& other_value)
{
single_value = new single_value_struct;
if (other_value.stdout_().is_bound()) {
  single_value->field_stdout_ = other_value.stdout_();
} else {
  single_value->field_stdout_.clean_up();
}
if (other_value.stderr_().is_bound()) {
  single_value->field_stderr_ = other_value.stderr_();
} else {
  single_value->field_stderr_.clean_up();
}
if (other_value.code().is_bound()) {
  single_value->field_code = other_value.code();
} else {
  single_value->field_code.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ASP__PResult_template::copy_template(const ASP__PResult_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.stdout_().get_selection()) {
single_value->field_stdout_ = other_value.stdout_();
} else {
single_value->field_stdout_.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.stderr_().get_selection()) {
single_value->field_stderr_ = other_value.stderr_();
} else {
single_value->field_stderr_.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.code().get_selection()) {
single_value->field_code = other_value.code();
} else {
single_value->field_code.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ASP__PResult_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
case IMPLICATION_MATCH:
implication_.precondition = new ASP__PResult_template(*other_value.implication_.precondition);
implication_.implied_template = new ASP__PResult_template(*other_value.implication_.implied_template);
break;
case DYNAMIC_MATCH:
dyn_match = other_value.dyn_match;
dyn_match->ref_count++;
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PResult.");
break;
}
set_selection(other_value);
}

ASP__PResult_template::ASP__PResult_template()
{
}

ASP__PResult_template::ASP__PResult_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ASP__PResult_template::ASP__PResult_template(const ASP__PResult& other_value)
{
copy_value(other_value);
}

ASP__PResult_template::ASP__PResult_template(const OPTIONAL<ASP__PResult>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__PResult&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @PIPEasp_Types.ASP_PResult from an unbound optional field.");
}
}

ASP__PResult_template::ASP__PResult_template(ASP__PResult_template* p_precondition, ASP__PResult_template* p_implied_template)
 : Base_Template(IMPLICATION_MATCH)
{
implication_.precondition = p_precondition;
implication_.implied_template = p_implied_template;
}

ASP__PResult_template::ASP__PResult_template(Dynamic_Match_Interface<ASP__PResult>* p_dyn_match)
 : Base_Template(DYNAMIC_MATCH)
{
dyn_match = new dynmatch_struct<ASP__PResult>;
dyn_match->ptr = p_dyn_match;
dyn_match->ref_count = 1;
}

ASP__PResult_template::ASP__PResult_template(const ASP__PResult_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ASP__PResult_template::~ASP__PResult_template()
{
clean_up();
}

ASP__PResult_template& ASP__PResult_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ASP__PResult_template& ASP__PResult_template::operator=(const ASP__PResult& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ASP__PResult_template& ASP__PResult_template::operator=(const OPTIONAL<ASP__PResult>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__PResult&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @PIPEasp_Types.ASP_PResult.");
}
return *this;
}

ASP__PResult_template& ASP__PResult_template::operator=(const ASP__PResult_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ASP__PResult_template::match(const ASP__PResult& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.stdout_().is_bound()) return FALSE;
if(!single_value->field_stdout_.match(other_value.stdout_(), legacy))return FALSE;
if(!other_value.stderr_().is_bound()) return FALSE;
if(!single_value->field_stderr_.match(other_value.stderr_(), legacy))return FALSE;
if(!other_value.code().is_bound()) return FALSE;
if(!single_value->field_code.match(other_value.code(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
case CONJUNCTION_MATCH:
for (unsigned int i = 0; i < value_list.n_values; i++) {
if (!value_list.list_value[i].match(other_value)) {
return FALSE;
}
}
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match(other_value) || implication_.implied_template->match(other_value);
case DYNAMIC_MATCH:
return dyn_match->ptr->match(other_value);
default:
TTCN_error("Matching an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PResult.");
}
return FALSE;
}

boolean ASP__PResult_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
return single_value->field_stdout_.is_bound()
 || single_value->field_stderr_.is_bound()
 || single_value->field_code.is_bound();
}

boolean ASP__PResult_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value->field_stdout_.is_value()
 && single_value->field_stderr_.is_value()
 && single_value->field_code.is_value();
}

void ASP__PResult_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
delete [] value_list.list_value;
break;
case IMPLICATION_MATCH:
delete implication_.precondition;
delete implication_.implied_template;
break;
case DYNAMIC_MATCH:
dyn_match->ref_count--;
if (dyn_match->ref_count == 0) {
delete dyn_match->ptr;
delete dyn_match;
}
break;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ASP__PResult ASP__PResult_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @PIPEasp_Types.ASP_PResult.");
ASP__PResult ret_val;
if (single_value->field_stdout_.is_bound()) {
ret_val.stdout_() = single_value->field_stdout_.valueof();
}
if (single_value->field_stderr_.is_bound()) {
ret_val.stderr_() = single_value->field_stderr_.valueof();
}
if (single_value->field_code.is_bound()) {
ret_val.code() = single_value->field_code.valueof();
}
return ret_val;
}

void ASP__PResult_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST&& template_type != CONJUNCTION_MATCH)
TTCN_error("Setting an invalid list for a template of type @PIPEasp_Types.ASP_PResult.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ASP__PResult_template[list_length];
}

ASP__PResult_template& ASP__PResult_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST&& template_selection != CONJUNCTION_MATCH)
TTCN_error("Accessing a list element of a non-list template of type @PIPEasp_Types.ASP_PResult.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @PIPEasp_Types.ASP_PResult.");
return value_list.list_value[list_index];
}

CHARSTRING_template& ASP__PResult_template::stdout_()
{
set_specific();
return single_value->field_stdout_;
}

const CHARSTRING_template& ASP__PResult_template::stdout_() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field stdout of a non-specific template of type @PIPEasp_Types.ASP_PResult.");
return single_value->field_stdout_;
}

CHARSTRING_template& ASP__PResult_template::stderr_()
{
set_specific();
return single_value->field_stderr_;
}

const CHARSTRING_template& ASP__PResult_template::stderr_() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field stderr of a non-specific template of type @PIPEasp_Types.ASP_PResult.");
return single_value->field_stderr_;
}

INTEGER_template& ASP__PResult_template::code()
{
set_specific();
return single_value->field_code;
}

const INTEGER_template& ASP__PResult_template::code() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field code of a non-specific template of type @PIPEasp_Types.ASP_PResult.");
return single_value->field_code;
}

int ASP__PResult_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PResult which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 3;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PResult containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PResult containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PResult containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PResult containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PResult containing complemented list.");
  case CONJUNCTION_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PResult containing a conjunction list match.");
  case IMPLICATION_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PResult containing an implication match.");
  case DYNAMIC_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PResult containing a dynamic match.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PResult.");
  }
  return 0;
}

void ASP__PResult_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ stdout := ");
single_value->field_stdout_.log();
TTCN_Logger::log_event_str(", stderr := ");
single_value->field_stderr_.log();
TTCN_Logger::log_event_str(", code := ");
single_value->field_code.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case CONJUNCTION_MATCH:
if (template_selection == CONJUNCTION_MATCH) {
TTCN_Logger::log_event_str("conjunct");
}
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
case IMPLICATION_MATCH:
implication_.precondition->log();
TTCN_Logger::log_event_str(" implies ");
implication_.implied_template->log();
break;
case DYNAMIC_MATCH:
TTCN_Logger::log_event_str("@dynamic template");
break;
default:
log_generic();
}
log_ifpresent();
}

void ASP__PResult_template::log_match(const ASP__PResult& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_stdout_.match(match_value.stdout_(), legacy)){
TTCN_Logger::log_logmatch_info(".stdout");
single_value->field_stdout_.log_match(match_value.stdout_(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_stderr_.match(match_value.stderr_(), legacy)){
TTCN_Logger::log_logmatch_info(".stderr");
single_value->field_stderr_.log_match(match_value.stderr_(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_code.match(match_value.code(), legacy)){
TTCN_Logger::log_logmatch_info(".code");
single_value->field_code.log_match(match_value.code(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ stdout := ");
single_value->field_stdout_.log_match(match_value.stdout_(), legacy);
TTCN_Logger::log_event_str(", stderr := ");
single_value->field_stderr_.log_match(match_value.stderr_(), legacy);
TTCN_Logger::log_event_str(", code := ");
single_value->field_code.log_match(match_value.code(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ASP__PResult_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_stdout_.encode_text(text_buf);
single_value->field_stderr_.encode_text(text_buf);
single_value->field_code.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PResult.");
}
}

void ASP__PResult_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_stdout_.decode_text(text_buf);
single_value->field_stderr_.decode_text(text_buf);
single_value->field_code.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ASP__PResult_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @PIPEasp_Types.ASP_PResult.");
}
}

void ASP__PResult_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
  case Module_Param::MP_ConjunctList_Template: {
    ASP__PResult_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : (param.get_type() == Module_Param::MP_ConjunctList_Template ? CONJUNCTION_MATCH : COMPLEMENTED_LIST), param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (3<param.get_size()) {
      param.error("record template of type @PIPEasp_Types.ASP_PResult has 3 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) stdout_().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) stderr_().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) code().set_param(*param.get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stdout")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stdout_().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stderr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stderr_().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "code")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          code().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PIPEasp_Types.ASP_PResult: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  case Module_Param::MP_Implication_Template: {
    ASP__PResult_template* precondition = new ASP__PResult_template;
    precondition->set_param(*param.get_elem(0));
    ASP__PResult_template* implied_template = new ASP__PResult_template;
    implied_template->set_param(*param.get_elem(1));
    *this = ASP__PResult_template(precondition, implied_template);
  } break;
  default:
    param.type_error("record template", "@PIPEasp_Types.ASP_PResult");
  }
  is_ifpresent = param.get_ifpresent();
}

void ASP__PResult_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_stdout_.check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_PResult");
single_value->field_stderr_.check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_PResult");
single_value->field_code.check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_PResult");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@PIPEasp_Types.ASP_PResult");
}

boolean ASP__PResult_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ASP__PResult_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match_omit() || implication_.implied_template->match_omit();
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ASP__PExecuteBinary::ASP__PExecuteBinary()
{
}

ASP__PExecuteBinary::ASP__PExecuteBinary(const CHARSTRING& par_command,
    const OCTETSTRING& par_stdin_)
  :   field_command(par_command),
  field_stdin_(par_stdin_)
{
}

ASP__PExecuteBinary::ASP__PExecuteBinary(const ASP__PExecuteBinary& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @PIPEasp_Types.ASP_PExecuteBinary.");
if (other_value.command().is_bound()) field_command = other_value.command();
else field_command.clean_up();
if (other_value.stdin_().is_bound()) field_stdin_ = other_value.stdin_();
else field_stdin_.clean_up();
}

void ASP__PExecuteBinary::clean_up()
{
field_command.clean_up();
field_stdin_.clean_up();
}

const TTCN_Typedescriptor_t* ASP__PExecuteBinary::get_descriptor() const { return &ASP__PExecuteBinary_descr_; }
ASP__PExecuteBinary& ASP__PExecuteBinary::operator=(const ASP__PExecuteBinary& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @PIPEasp_Types.ASP_PExecuteBinary.");
  if (other_value.command().is_bound()) field_command = other_value.command();
  else field_command.clean_up();
  if (other_value.stdin_().is_bound()) field_stdin_ = other_value.stdin_();
  else field_stdin_.clean_up();
}
return *this;
}

boolean ASP__PExecuteBinary::operator==(const ASP__PExecuteBinary& other_value) const
{
return field_command==other_value.field_command
  && field_stdin_==other_value.field_stdin_;
}

boolean ASP__PExecuteBinary::is_bound() const
{
return (field_command.is_bound())
  || (field_stdin_.is_bound());
}
boolean ASP__PExecuteBinary::is_value() const
{
return field_command.is_value()
  && field_stdin_.is_value();
}
void ASP__PExecuteBinary::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ command := ");
field_command.log();
TTCN_Logger::log_event_str(", stdin := ");
field_stdin_.log();
TTCN_Logger::log_event_str(" }");
}

void ASP__PExecuteBinary::set_implicit_omit()
{
if (command().is_bound()) command().set_implicit_omit();
if (stdin_().is_bound()) stdin_().set_implicit_omit();
}

void ASP__PExecuteBinary::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record value of type @PIPEasp_Types.ASP_PExecuteBinary has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) command().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) stdin_().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "command")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          command().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stdin")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stdin_().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PIPEasp_Types.ASP_PExecuteBinary: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@PIPEasp_Types.ASP_PExecuteBinary");
  }
}

void ASP__PExecuteBinary::encode_text(Text_Buf& text_buf) const
{
field_command.encode_text(text_buf);
field_stdin_.encode_text(text_buf);
}

void ASP__PExecuteBinary::decode_text(Text_Buf& text_buf)
{
field_command.decode_text(text_buf);
field_stdin_.decode_text(text_buf);
}

struct ASP__PExecuteBinary_template::single_value_struct {
CHARSTRING_template field_command;
OCTETSTRING_template field_stdin_;
};

void ASP__PExecuteBinary_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_command = ANY_VALUE;
single_value->field_stdin_ = ANY_VALUE;
}
}
}

void ASP__PExecuteBinary_template::copy_value(const ASP__PExecuteBinary& other_value)
{
single_value = new single_value_struct;
if (other_value.command().is_bound()) {
  single_value->field_command = other_value.command();
} else {
  single_value->field_command.clean_up();
}
if (other_value.stdin_().is_bound()) {
  single_value->field_stdin_ = other_value.stdin_();
} else {
  single_value->field_stdin_.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ASP__PExecuteBinary_template::copy_template(const ASP__PExecuteBinary_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.command().get_selection()) {
single_value->field_command = other_value.command();
} else {
single_value->field_command.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.stdin_().get_selection()) {
single_value->field_stdin_ = other_value.stdin_();
} else {
single_value->field_stdin_.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ASP__PExecuteBinary_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
case IMPLICATION_MATCH:
implication_.precondition = new ASP__PExecuteBinary_template(*other_value.implication_.precondition);
implication_.implied_template = new ASP__PExecuteBinary_template(*other_value.implication_.implied_template);
break;
case DYNAMIC_MATCH:
dyn_match = other_value.dyn_match;
dyn_match->ref_count++;
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PExecuteBinary.");
break;
}
set_selection(other_value);
}

ASP__PExecuteBinary_template::ASP__PExecuteBinary_template()
{
}

ASP__PExecuteBinary_template::ASP__PExecuteBinary_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ASP__PExecuteBinary_template::ASP__PExecuteBinary_template(const ASP__PExecuteBinary& other_value)
{
copy_value(other_value);
}

ASP__PExecuteBinary_template::ASP__PExecuteBinary_template(const OPTIONAL<ASP__PExecuteBinary>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__PExecuteBinary&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @PIPEasp_Types.ASP_PExecuteBinary from an unbound optional field.");
}
}

ASP__PExecuteBinary_template::ASP__PExecuteBinary_template(ASP__PExecuteBinary_template* p_precondition, ASP__PExecuteBinary_template* p_implied_template)
 : Base_Template(IMPLICATION_MATCH)
{
implication_.precondition = p_precondition;
implication_.implied_template = p_implied_template;
}

ASP__PExecuteBinary_template::ASP__PExecuteBinary_template(Dynamic_Match_Interface<ASP__PExecuteBinary>* p_dyn_match)
 : Base_Template(DYNAMIC_MATCH)
{
dyn_match = new dynmatch_struct<ASP__PExecuteBinary>;
dyn_match->ptr = p_dyn_match;
dyn_match->ref_count = 1;
}

ASP__PExecuteBinary_template::ASP__PExecuteBinary_template(const ASP__PExecuteBinary_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ASP__PExecuteBinary_template::~ASP__PExecuteBinary_template()
{
clean_up();
}

ASP__PExecuteBinary_template& ASP__PExecuteBinary_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ASP__PExecuteBinary_template& ASP__PExecuteBinary_template::operator=(const ASP__PExecuteBinary& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ASP__PExecuteBinary_template& ASP__PExecuteBinary_template::operator=(const OPTIONAL<ASP__PExecuteBinary>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__PExecuteBinary&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @PIPEasp_Types.ASP_PExecuteBinary.");
}
return *this;
}

ASP__PExecuteBinary_template& ASP__PExecuteBinary_template::operator=(const ASP__PExecuteBinary_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ASP__PExecuteBinary_template::match(const ASP__PExecuteBinary& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.command().is_bound()) return FALSE;
if(!single_value->field_command.match(other_value.command(), legacy))return FALSE;
if(!other_value.stdin_().is_bound()) return FALSE;
if(!single_value->field_stdin_.match(other_value.stdin_(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
case CONJUNCTION_MATCH:
for (unsigned int i = 0; i < value_list.n_values; i++) {
if (!value_list.list_value[i].match(other_value)) {
return FALSE;
}
}
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match(other_value) || implication_.implied_template->match(other_value);
case DYNAMIC_MATCH:
return dyn_match->ptr->match(other_value);
default:
TTCN_error("Matching an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PExecuteBinary.");
}
return FALSE;
}

boolean ASP__PExecuteBinary_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
return single_value->field_command.is_bound()
 || single_value->field_stdin_.is_bound();
}

boolean ASP__PExecuteBinary_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value->field_command.is_value()
 && single_value->field_stdin_.is_value();
}

void ASP__PExecuteBinary_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
delete [] value_list.list_value;
break;
case IMPLICATION_MATCH:
delete implication_.precondition;
delete implication_.implied_template;
break;
case DYNAMIC_MATCH:
dyn_match->ref_count--;
if (dyn_match->ref_count == 0) {
delete dyn_match->ptr;
delete dyn_match;
}
break;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ASP__PExecuteBinary ASP__PExecuteBinary_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @PIPEasp_Types.ASP_PExecuteBinary.");
ASP__PExecuteBinary ret_val;
if (single_value->field_command.is_bound()) {
ret_val.command() = single_value->field_command.valueof();
}
if (single_value->field_stdin_.is_bound()) {
ret_val.stdin_() = single_value->field_stdin_.valueof();
}
return ret_val;
}

void ASP__PExecuteBinary_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST&& template_type != CONJUNCTION_MATCH)
TTCN_error("Setting an invalid list for a template of type @PIPEasp_Types.ASP_PExecuteBinary.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ASP__PExecuteBinary_template[list_length];
}

ASP__PExecuteBinary_template& ASP__PExecuteBinary_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST&& template_selection != CONJUNCTION_MATCH)
TTCN_error("Accessing a list element of a non-list template of type @PIPEasp_Types.ASP_PExecuteBinary.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @PIPEasp_Types.ASP_PExecuteBinary.");
return value_list.list_value[list_index];
}

CHARSTRING_template& ASP__PExecuteBinary_template::command()
{
set_specific();
return single_value->field_command;
}

const CHARSTRING_template& ASP__PExecuteBinary_template::command() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field command of a non-specific template of type @PIPEasp_Types.ASP_PExecuteBinary.");
return single_value->field_command;
}

OCTETSTRING_template& ASP__PExecuteBinary_template::stdin_()
{
set_specific();
return single_value->field_stdin_;
}

const OCTETSTRING_template& ASP__PExecuteBinary_template::stdin_() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field stdin of a non-specific template of type @PIPEasp_Types.ASP_PExecuteBinary.");
return single_value->field_stdin_;
}

int ASP__PExecuteBinary_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecuteBinary which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecuteBinary containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecuteBinary containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecuteBinary containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecuteBinary containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecuteBinary containing complemented list.");
  case CONJUNCTION_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecuteBinary containing a conjunction list match.");
  case IMPLICATION_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecuteBinary containing an implication match.");
  case DYNAMIC_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecuteBinary containing a dynamic match.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PExecuteBinary.");
  }
  return 0;
}

void ASP__PExecuteBinary_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ command := ");
single_value->field_command.log();
TTCN_Logger::log_event_str(", stdin := ");
single_value->field_stdin_.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case CONJUNCTION_MATCH:
if (template_selection == CONJUNCTION_MATCH) {
TTCN_Logger::log_event_str("conjunct");
}
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
case IMPLICATION_MATCH:
implication_.precondition->log();
TTCN_Logger::log_event_str(" implies ");
implication_.implied_template->log();
break;
case DYNAMIC_MATCH:
TTCN_Logger::log_event_str("@dynamic template");
break;
default:
log_generic();
}
log_ifpresent();
}

void ASP__PExecuteBinary_template::log_match(const ASP__PExecuteBinary& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_command.match(match_value.command(), legacy)){
TTCN_Logger::log_logmatch_info(".command");
single_value->field_command.log_match(match_value.command(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_stdin_.match(match_value.stdin_(), legacy)){
TTCN_Logger::log_logmatch_info(".stdin");
single_value->field_stdin_.log_match(match_value.stdin_(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ command := ");
single_value->field_command.log_match(match_value.command(), legacy);
TTCN_Logger::log_event_str(", stdin := ");
single_value->field_stdin_.log_match(match_value.stdin_(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ASP__PExecuteBinary_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_command.encode_text(text_buf);
single_value->field_stdin_.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PExecuteBinary.");
}
}

void ASP__PExecuteBinary_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_command.decode_text(text_buf);
single_value->field_stdin_.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ASP__PExecuteBinary_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @PIPEasp_Types.ASP_PExecuteBinary.");
}
}

void ASP__PExecuteBinary_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
  case Module_Param::MP_ConjunctList_Template: {
    ASP__PExecuteBinary_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : (param.get_type() == Module_Param::MP_ConjunctList_Template ? CONJUNCTION_MATCH : COMPLEMENTED_LIST), param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record template of type @PIPEasp_Types.ASP_PExecuteBinary has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) command().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) stdin_().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "command")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          command().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stdin")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stdin_().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PIPEasp_Types.ASP_PExecuteBinary: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  case Module_Param::MP_Implication_Template: {
    ASP__PExecuteBinary_template* precondition = new ASP__PExecuteBinary_template;
    precondition->set_param(*param.get_elem(0));
    ASP__PExecuteBinary_template* implied_template = new ASP__PExecuteBinary_template;
    implied_template->set_param(*param.get_elem(1));
    *this = ASP__PExecuteBinary_template(precondition, implied_template);
  } break;
  default:
    param.type_error("record template", "@PIPEasp_Types.ASP_PExecuteBinary");
  }
  is_ifpresent = param.get_ifpresent();
}

void ASP__PExecuteBinary_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_command.check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_PExecuteBinary");
single_value->field_stdin_.check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_PExecuteBinary");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@PIPEasp_Types.ASP_PExecuteBinary");
}

boolean ASP__PExecuteBinary_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ASP__PExecuteBinary_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match_omit() || implication_.implied_template->match_omit();
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ASP__PExecuteBinaryPty::ASP__PExecuteBinaryPty()
{
}

ASP__PExecuteBinaryPty::ASP__PExecuteBinaryPty(const CHARSTRING& par_command,
    const OCTETSTRING& par_stdin_)
  :   field_command(par_command),
  field_stdin_(par_stdin_)
{
}

ASP__PExecuteBinaryPty::ASP__PExecuteBinaryPty(const ASP__PExecuteBinaryPty& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @PIPEasp_Types.ASP_PExecuteBinaryPty.");
if (other_value.command().is_bound()) field_command = other_value.command();
else field_command.clean_up();
if (other_value.stdin_().is_bound()) field_stdin_ = other_value.stdin_();
else field_stdin_.clean_up();
}

void ASP__PExecuteBinaryPty::clean_up()
{
field_command.clean_up();
field_stdin_.clean_up();
}

const TTCN_Typedescriptor_t* ASP__PExecuteBinaryPty::get_descriptor() const { return &ASP__PExecuteBinaryPty_descr_; }
ASP__PExecuteBinaryPty& ASP__PExecuteBinaryPty::operator=(const ASP__PExecuteBinaryPty& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @PIPEasp_Types.ASP_PExecuteBinaryPty.");
  if (other_value.command().is_bound()) field_command = other_value.command();
  else field_command.clean_up();
  if (other_value.stdin_().is_bound()) field_stdin_ = other_value.stdin_();
  else field_stdin_.clean_up();
}
return *this;
}

boolean ASP__PExecuteBinaryPty::operator==(const ASP__PExecuteBinaryPty& other_value) const
{
return field_command==other_value.field_command
  && field_stdin_==other_value.field_stdin_;
}

boolean ASP__PExecuteBinaryPty::is_bound() const
{
return (field_command.is_bound())
  || (field_stdin_.is_bound());
}
boolean ASP__PExecuteBinaryPty::is_value() const
{
return field_command.is_value()
  && field_stdin_.is_value();
}
void ASP__PExecuteBinaryPty::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ command := ");
field_command.log();
TTCN_Logger::log_event_str(", stdin := ");
field_stdin_.log();
TTCN_Logger::log_event_str(" }");
}

void ASP__PExecuteBinaryPty::set_implicit_omit()
{
if (command().is_bound()) command().set_implicit_omit();
if (stdin_().is_bound()) stdin_().set_implicit_omit();
}

void ASP__PExecuteBinaryPty::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record value of type @PIPEasp_Types.ASP_PExecuteBinaryPty has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) command().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) stdin_().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "command")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          command().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stdin")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stdin_().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PIPEasp_Types.ASP_PExecuteBinaryPty: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@PIPEasp_Types.ASP_PExecuteBinaryPty");
  }
}

void ASP__PExecuteBinaryPty::encode_text(Text_Buf& text_buf) const
{
field_command.encode_text(text_buf);
field_stdin_.encode_text(text_buf);
}

void ASP__PExecuteBinaryPty::decode_text(Text_Buf& text_buf)
{
field_command.decode_text(text_buf);
field_stdin_.decode_text(text_buf);
}

struct ASP__PExecuteBinaryPty_template::single_value_struct {
CHARSTRING_template field_command;
OCTETSTRING_template field_stdin_;
};

void ASP__PExecuteBinaryPty_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_command = ANY_VALUE;
single_value->field_stdin_ = ANY_VALUE;
}
}
}

void ASP__PExecuteBinaryPty_template::copy_value(const ASP__PExecuteBinaryPty& other_value)
{
single_value = new single_value_struct;
if (other_value.command().is_bound()) {
  single_value->field_command = other_value.command();
} else {
  single_value->field_command.clean_up();
}
if (other_value.stdin_().is_bound()) {
  single_value->field_stdin_ = other_value.stdin_();
} else {
  single_value->field_stdin_.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ASP__PExecuteBinaryPty_template::copy_template(const ASP__PExecuteBinaryPty_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.command().get_selection()) {
single_value->field_command = other_value.command();
} else {
single_value->field_command.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.stdin_().get_selection()) {
single_value->field_stdin_ = other_value.stdin_();
} else {
single_value->field_stdin_.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ASP__PExecuteBinaryPty_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
case IMPLICATION_MATCH:
implication_.precondition = new ASP__PExecuteBinaryPty_template(*other_value.implication_.precondition);
implication_.implied_template = new ASP__PExecuteBinaryPty_template(*other_value.implication_.implied_template);
break;
case DYNAMIC_MATCH:
dyn_match = other_value.dyn_match;
dyn_match->ref_count++;
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PExecuteBinaryPty.");
break;
}
set_selection(other_value);
}

ASP__PExecuteBinaryPty_template::ASP__PExecuteBinaryPty_template()
{
}

ASP__PExecuteBinaryPty_template::ASP__PExecuteBinaryPty_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ASP__PExecuteBinaryPty_template::ASP__PExecuteBinaryPty_template(const ASP__PExecuteBinaryPty& other_value)
{
copy_value(other_value);
}

ASP__PExecuteBinaryPty_template::ASP__PExecuteBinaryPty_template(const OPTIONAL<ASP__PExecuteBinaryPty>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__PExecuteBinaryPty&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @PIPEasp_Types.ASP_PExecuteBinaryPty from an unbound optional field.");
}
}

ASP__PExecuteBinaryPty_template::ASP__PExecuteBinaryPty_template(ASP__PExecuteBinaryPty_template* p_precondition, ASP__PExecuteBinaryPty_template* p_implied_template)
 : Base_Template(IMPLICATION_MATCH)
{
implication_.precondition = p_precondition;
implication_.implied_template = p_implied_template;
}

ASP__PExecuteBinaryPty_template::ASP__PExecuteBinaryPty_template(Dynamic_Match_Interface<ASP__PExecuteBinaryPty>* p_dyn_match)
 : Base_Template(DYNAMIC_MATCH)
{
dyn_match = new dynmatch_struct<ASP__PExecuteBinaryPty>;
dyn_match->ptr = p_dyn_match;
dyn_match->ref_count = 1;
}

ASP__PExecuteBinaryPty_template::ASP__PExecuteBinaryPty_template(const ASP__PExecuteBinaryPty_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ASP__PExecuteBinaryPty_template::~ASP__PExecuteBinaryPty_template()
{
clean_up();
}

ASP__PExecuteBinaryPty_template& ASP__PExecuteBinaryPty_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ASP__PExecuteBinaryPty_template& ASP__PExecuteBinaryPty_template::operator=(const ASP__PExecuteBinaryPty& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ASP__PExecuteBinaryPty_template& ASP__PExecuteBinaryPty_template::operator=(const OPTIONAL<ASP__PExecuteBinaryPty>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__PExecuteBinaryPty&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @PIPEasp_Types.ASP_PExecuteBinaryPty.");
}
return *this;
}

ASP__PExecuteBinaryPty_template& ASP__PExecuteBinaryPty_template::operator=(const ASP__PExecuteBinaryPty_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ASP__PExecuteBinaryPty_template::match(const ASP__PExecuteBinaryPty& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.command().is_bound()) return FALSE;
if(!single_value->field_command.match(other_value.command(), legacy))return FALSE;
if(!other_value.stdin_().is_bound()) return FALSE;
if(!single_value->field_stdin_.match(other_value.stdin_(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
case CONJUNCTION_MATCH:
for (unsigned int i = 0; i < value_list.n_values; i++) {
if (!value_list.list_value[i].match(other_value)) {
return FALSE;
}
}
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match(other_value) || implication_.implied_template->match(other_value);
case DYNAMIC_MATCH:
return dyn_match->ptr->match(other_value);
default:
TTCN_error("Matching an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PExecuteBinaryPty.");
}
return FALSE;
}

boolean ASP__PExecuteBinaryPty_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
return single_value->field_command.is_bound()
 || single_value->field_stdin_.is_bound();
}

boolean ASP__PExecuteBinaryPty_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value->field_command.is_value()
 && single_value->field_stdin_.is_value();
}

void ASP__PExecuteBinaryPty_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
delete [] value_list.list_value;
break;
case IMPLICATION_MATCH:
delete implication_.precondition;
delete implication_.implied_template;
break;
case DYNAMIC_MATCH:
dyn_match->ref_count--;
if (dyn_match->ref_count == 0) {
delete dyn_match->ptr;
delete dyn_match;
}
break;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ASP__PExecuteBinaryPty ASP__PExecuteBinaryPty_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @PIPEasp_Types.ASP_PExecuteBinaryPty.");
ASP__PExecuteBinaryPty ret_val;
if (single_value->field_command.is_bound()) {
ret_val.command() = single_value->field_command.valueof();
}
if (single_value->field_stdin_.is_bound()) {
ret_val.stdin_() = single_value->field_stdin_.valueof();
}
return ret_val;
}

void ASP__PExecuteBinaryPty_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST&& template_type != CONJUNCTION_MATCH)
TTCN_error("Setting an invalid list for a template of type @PIPEasp_Types.ASP_PExecuteBinaryPty.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ASP__PExecuteBinaryPty_template[list_length];
}

ASP__PExecuteBinaryPty_template& ASP__PExecuteBinaryPty_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST&& template_selection != CONJUNCTION_MATCH)
TTCN_error("Accessing a list element of a non-list template of type @PIPEasp_Types.ASP_PExecuteBinaryPty.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @PIPEasp_Types.ASP_PExecuteBinaryPty.");
return value_list.list_value[list_index];
}

CHARSTRING_template& ASP__PExecuteBinaryPty_template::command()
{
set_specific();
return single_value->field_command;
}

const CHARSTRING_template& ASP__PExecuteBinaryPty_template::command() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field command of a non-specific template of type @PIPEasp_Types.ASP_PExecuteBinaryPty.");
return single_value->field_command;
}

OCTETSTRING_template& ASP__PExecuteBinaryPty_template::stdin_()
{
set_specific();
return single_value->field_stdin_;
}

const OCTETSTRING_template& ASP__PExecuteBinaryPty_template::stdin_() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field stdin of a non-specific template of type @PIPEasp_Types.ASP_PExecuteBinaryPty.");
return single_value->field_stdin_;
}

int ASP__PExecuteBinaryPty_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecuteBinaryPty which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecuteBinaryPty containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecuteBinaryPty containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecuteBinaryPty containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecuteBinaryPty containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecuteBinaryPty containing complemented list.");
  case CONJUNCTION_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecuteBinaryPty containing a conjunction list match.");
  case IMPLICATION_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecuteBinaryPty containing an implication match.");
  case DYNAMIC_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecuteBinaryPty containing a dynamic match.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PExecuteBinaryPty.");
  }
  return 0;
}

void ASP__PExecuteBinaryPty_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ command := ");
single_value->field_command.log();
TTCN_Logger::log_event_str(", stdin := ");
single_value->field_stdin_.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case CONJUNCTION_MATCH:
if (template_selection == CONJUNCTION_MATCH) {
TTCN_Logger::log_event_str("conjunct");
}
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
case IMPLICATION_MATCH:
implication_.precondition->log();
TTCN_Logger::log_event_str(" implies ");
implication_.implied_template->log();
break;
case DYNAMIC_MATCH:
TTCN_Logger::log_event_str("@dynamic template");
break;
default:
log_generic();
}
log_ifpresent();
}

void ASP__PExecuteBinaryPty_template::log_match(const ASP__PExecuteBinaryPty& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_command.match(match_value.command(), legacy)){
TTCN_Logger::log_logmatch_info(".command");
single_value->field_command.log_match(match_value.command(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_stdin_.match(match_value.stdin_(), legacy)){
TTCN_Logger::log_logmatch_info(".stdin");
single_value->field_stdin_.log_match(match_value.stdin_(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ command := ");
single_value->field_command.log_match(match_value.command(), legacy);
TTCN_Logger::log_event_str(", stdin := ");
single_value->field_stdin_.log_match(match_value.stdin_(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ASP__PExecuteBinaryPty_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_command.encode_text(text_buf);
single_value->field_stdin_.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PExecuteBinaryPty.");
}
}

void ASP__PExecuteBinaryPty_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_command.decode_text(text_buf);
single_value->field_stdin_.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ASP__PExecuteBinaryPty_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @PIPEasp_Types.ASP_PExecuteBinaryPty.");
}
}

void ASP__PExecuteBinaryPty_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
  case Module_Param::MP_ConjunctList_Template: {
    ASP__PExecuteBinaryPty_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : (param.get_type() == Module_Param::MP_ConjunctList_Template ? CONJUNCTION_MATCH : COMPLEMENTED_LIST), param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record template of type @PIPEasp_Types.ASP_PExecuteBinaryPty has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) command().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) stdin_().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "command")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          command().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stdin")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stdin_().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PIPEasp_Types.ASP_PExecuteBinaryPty: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  case Module_Param::MP_Implication_Template: {
    ASP__PExecuteBinaryPty_template* precondition = new ASP__PExecuteBinaryPty_template;
    precondition->set_param(*param.get_elem(0));
    ASP__PExecuteBinaryPty_template* implied_template = new ASP__PExecuteBinaryPty_template;
    implied_template->set_param(*param.get_elem(1));
    *this = ASP__PExecuteBinaryPty_template(precondition, implied_template);
  } break;
  default:
    param.type_error("record template", "@PIPEasp_Types.ASP_PExecuteBinaryPty");
  }
  is_ifpresent = param.get_ifpresent();
}

void ASP__PExecuteBinaryPty_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_command.check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_PExecuteBinaryPty");
single_value->field_stdin_.check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_PExecuteBinaryPty");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@PIPEasp_Types.ASP_PExecuteBinaryPty");
}

boolean ASP__PExecuteBinaryPty_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ASP__PExecuteBinaryPty_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match_omit() || implication_.implied_template->match_omit();
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ASP__PResultBinary::ASP__PResultBinary()
{
}

ASP__PResultBinary::ASP__PResultBinary(const OCTETSTRING& par_stdout_,
    const OCTETSTRING& par_stderr_,
    const INTEGER& par_code)
  :   field_stdout_(par_stdout_),
  field_stderr_(par_stderr_),
  field_code(par_code)
{
}

ASP__PResultBinary::ASP__PResultBinary(const ASP__PResultBinary& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @PIPEasp_Types.ASP_PResultBinary.");
if (other_value.stdout_().is_bound()) field_stdout_ = other_value.stdout_();
else field_stdout_.clean_up();
if (other_value.stderr_().is_bound()) field_stderr_ = other_value.stderr_();
else field_stderr_.clean_up();
if (other_value.code().is_bound()) field_code = other_value.code();
else field_code.clean_up();
}

void ASP__PResultBinary::clean_up()
{
field_stdout_.clean_up();
field_stderr_.clean_up();
field_code.clean_up();
}

const TTCN_Typedescriptor_t* ASP__PResultBinary::get_descriptor() const { return &ASP__PResultBinary_descr_; }
ASP__PResultBinary& ASP__PResultBinary::operator=(const ASP__PResultBinary& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @PIPEasp_Types.ASP_PResultBinary.");
  if (other_value.stdout_().is_bound()) field_stdout_ = other_value.stdout_();
  else field_stdout_.clean_up();
  if (other_value.stderr_().is_bound()) field_stderr_ = other_value.stderr_();
  else field_stderr_.clean_up();
  if (other_value.code().is_bound()) field_code = other_value.code();
  else field_code.clean_up();
}
return *this;
}

boolean ASP__PResultBinary::operator==(const ASP__PResultBinary& other_value) const
{
return field_stdout_==other_value.field_stdout_
  && field_stderr_==other_value.field_stderr_
  && field_code==other_value.field_code;
}

boolean ASP__PResultBinary::is_bound() const
{
return (field_stdout_.is_bound())
  || (field_stderr_.is_bound())
  || (field_code.is_bound());
}
boolean ASP__PResultBinary::is_value() const
{
return field_stdout_.is_value()
  && field_stderr_.is_value()
  && field_code.is_value();
}
void ASP__PResultBinary::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ stdout := ");
field_stdout_.log();
TTCN_Logger::log_event_str(", stderr := ");
field_stderr_.log();
TTCN_Logger::log_event_str(", code := ");
field_code.log();
TTCN_Logger::log_event_str(" }");
}

void ASP__PResultBinary::set_implicit_omit()
{
if (stdout_().is_bound()) stdout_().set_implicit_omit();
if (stderr_().is_bound()) stderr_().set_implicit_omit();
if (code().is_bound()) code().set_implicit_omit();
}

void ASP__PResultBinary::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (3<param.get_size()) {
      param.error("record value of type @PIPEasp_Types.ASP_PResultBinary has 3 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) stdout_().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) stderr_().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) code().set_param(*param.get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stdout")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stdout_().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stderr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stderr_().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "code")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          code().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PIPEasp_Types.ASP_PResultBinary: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@PIPEasp_Types.ASP_PResultBinary");
  }
}

void ASP__PResultBinary::encode_text(Text_Buf& text_buf) const
{
field_stdout_.encode_text(text_buf);
field_stderr_.encode_text(text_buf);
field_code.encode_text(text_buf);
}

void ASP__PResultBinary::decode_text(Text_Buf& text_buf)
{
field_stdout_.decode_text(text_buf);
field_stderr_.decode_text(text_buf);
field_code.decode_text(text_buf);
}

struct ASP__PResultBinary_template::single_value_struct {
OCTETSTRING_template field_stdout_;
OCTETSTRING_template field_stderr_;
INTEGER_template field_code;
};

void ASP__PResultBinary_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_stdout_ = ANY_VALUE;
single_value->field_stderr_ = ANY_VALUE;
single_value->field_code = ANY_VALUE;
}
}
}

void ASP__PResultBinary_template::copy_value(const ASP__PResultBinary& other_value)
{
single_value = new single_value_struct;
if (other_value.stdout_().is_bound()) {
  single_value->field_stdout_ = other_value.stdout_();
} else {
  single_value->field_stdout_.clean_up();
}
if (other_value.stderr_().is_bound()) {
  single_value->field_stderr_ = other_value.stderr_();
} else {
  single_value->field_stderr_.clean_up();
}
if (other_value.code().is_bound()) {
  single_value->field_code = other_value.code();
} else {
  single_value->field_code.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ASP__PResultBinary_template::copy_template(const ASP__PResultBinary_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.stdout_().get_selection()) {
single_value->field_stdout_ = other_value.stdout_();
} else {
single_value->field_stdout_.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.stderr_().get_selection()) {
single_value->field_stderr_ = other_value.stderr_();
} else {
single_value->field_stderr_.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.code().get_selection()) {
single_value->field_code = other_value.code();
} else {
single_value->field_code.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ASP__PResultBinary_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
case IMPLICATION_MATCH:
implication_.precondition = new ASP__PResultBinary_template(*other_value.implication_.precondition);
implication_.implied_template = new ASP__PResultBinary_template(*other_value.implication_.implied_template);
break;
case DYNAMIC_MATCH:
dyn_match = other_value.dyn_match;
dyn_match->ref_count++;
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PResultBinary.");
break;
}
set_selection(other_value);
}

ASP__PResultBinary_template::ASP__PResultBinary_template()
{
}

ASP__PResultBinary_template::ASP__PResultBinary_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ASP__PResultBinary_template::ASP__PResultBinary_template(const ASP__PResultBinary& other_value)
{
copy_value(other_value);
}

ASP__PResultBinary_template::ASP__PResultBinary_template(const OPTIONAL<ASP__PResultBinary>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__PResultBinary&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @PIPEasp_Types.ASP_PResultBinary from an unbound optional field.");
}
}

ASP__PResultBinary_template::ASP__PResultBinary_template(ASP__PResultBinary_template* p_precondition, ASP__PResultBinary_template* p_implied_template)
 : Base_Template(IMPLICATION_MATCH)
{
implication_.precondition = p_precondition;
implication_.implied_template = p_implied_template;
}

ASP__PResultBinary_template::ASP__PResultBinary_template(Dynamic_Match_Interface<ASP__PResultBinary>* p_dyn_match)
 : Base_Template(DYNAMIC_MATCH)
{
dyn_match = new dynmatch_struct<ASP__PResultBinary>;
dyn_match->ptr = p_dyn_match;
dyn_match->ref_count = 1;
}

ASP__PResultBinary_template::ASP__PResultBinary_template(const ASP__PResultBinary_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ASP__PResultBinary_template::~ASP__PResultBinary_template()
{
clean_up();
}

ASP__PResultBinary_template& ASP__PResultBinary_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ASP__PResultBinary_template& ASP__PResultBinary_template::operator=(const ASP__PResultBinary& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ASP__PResultBinary_template& ASP__PResultBinary_template::operator=(const OPTIONAL<ASP__PResultBinary>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__PResultBinary&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @PIPEasp_Types.ASP_PResultBinary.");
}
return *this;
}

ASP__PResultBinary_template& ASP__PResultBinary_template::operator=(const ASP__PResultBinary_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ASP__PResultBinary_template::match(const ASP__PResultBinary& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.stdout_().is_bound()) return FALSE;
if(!single_value->field_stdout_.match(other_value.stdout_(), legacy))return FALSE;
if(!other_value.stderr_().is_bound()) return FALSE;
if(!single_value->field_stderr_.match(other_value.stderr_(), legacy))return FALSE;
if(!other_value.code().is_bound()) return FALSE;
if(!single_value->field_code.match(other_value.code(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
case CONJUNCTION_MATCH:
for (unsigned int i = 0; i < value_list.n_values; i++) {
if (!value_list.list_value[i].match(other_value)) {
return FALSE;
}
}
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match(other_value) || implication_.implied_template->match(other_value);
case DYNAMIC_MATCH:
return dyn_match->ptr->match(other_value);
default:
TTCN_error("Matching an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PResultBinary.");
}
return FALSE;
}

boolean ASP__PResultBinary_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
return single_value->field_stdout_.is_bound()
 || single_value->field_stderr_.is_bound()
 || single_value->field_code.is_bound();
}

boolean ASP__PResultBinary_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value->field_stdout_.is_value()
 && single_value->field_stderr_.is_value()
 && single_value->field_code.is_value();
}

void ASP__PResultBinary_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
delete [] value_list.list_value;
break;
case IMPLICATION_MATCH:
delete implication_.precondition;
delete implication_.implied_template;
break;
case DYNAMIC_MATCH:
dyn_match->ref_count--;
if (dyn_match->ref_count == 0) {
delete dyn_match->ptr;
delete dyn_match;
}
break;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ASP__PResultBinary ASP__PResultBinary_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @PIPEasp_Types.ASP_PResultBinary.");
ASP__PResultBinary ret_val;
if (single_value->field_stdout_.is_bound()) {
ret_val.stdout_() = single_value->field_stdout_.valueof();
}
if (single_value->field_stderr_.is_bound()) {
ret_val.stderr_() = single_value->field_stderr_.valueof();
}
if (single_value->field_code.is_bound()) {
ret_val.code() = single_value->field_code.valueof();
}
return ret_val;
}

void ASP__PResultBinary_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST&& template_type != CONJUNCTION_MATCH)
TTCN_error("Setting an invalid list for a template of type @PIPEasp_Types.ASP_PResultBinary.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ASP__PResultBinary_template[list_length];
}

ASP__PResultBinary_template& ASP__PResultBinary_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST&& template_selection != CONJUNCTION_MATCH)
TTCN_error("Accessing a list element of a non-list template of type @PIPEasp_Types.ASP_PResultBinary.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @PIPEasp_Types.ASP_PResultBinary.");
return value_list.list_value[list_index];
}

OCTETSTRING_template& ASP__PResultBinary_template::stdout_()
{
set_specific();
return single_value->field_stdout_;
}

const OCTETSTRING_template& ASP__PResultBinary_template::stdout_() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field stdout of a non-specific template of type @PIPEasp_Types.ASP_PResultBinary.");
return single_value->field_stdout_;
}

OCTETSTRING_template& ASP__PResultBinary_template::stderr_()
{
set_specific();
return single_value->field_stderr_;
}

const OCTETSTRING_template& ASP__PResultBinary_template::stderr_() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field stderr of a non-specific template of type @PIPEasp_Types.ASP_PResultBinary.");
return single_value->field_stderr_;
}

INTEGER_template& ASP__PResultBinary_template::code()
{
set_specific();
return single_value->field_code;
}

const INTEGER_template& ASP__PResultBinary_template::code() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field code of a non-specific template of type @PIPEasp_Types.ASP_PResultBinary.");
return single_value->field_code;
}

int ASP__PResultBinary_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PResultBinary which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 3;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PResultBinary containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PResultBinary containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PResultBinary containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PResultBinary containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PResultBinary containing complemented list.");
  case CONJUNCTION_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PResultBinary containing a conjunction list match.");
  case IMPLICATION_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PResultBinary containing an implication match.");
  case DYNAMIC_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PResultBinary containing a dynamic match.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PResultBinary.");
  }
  return 0;
}

void ASP__PResultBinary_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ stdout := ");
single_value->field_stdout_.log();
TTCN_Logger::log_event_str(", stderr := ");
single_value->field_stderr_.log();
TTCN_Logger::log_event_str(", code := ");
single_value->field_code.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case CONJUNCTION_MATCH:
if (template_selection == CONJUNCTION_MATCH) {
TTCN_Logger::log_event_str("conjunct");
}
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
case IMPLICATION_MATCH:
implication_.precondition->log();
TTCN_Logger::log_event_str(" implies ");
implication_.implied_template->log();
break;
case DYNAMIC_MATCH:
TTCN_Logger::log_event_str("@dynamic template");
break;
default:
log_generic();
}
log_ifpresent();
}

void ASP__PResultBinary_template::log_match(const ASP__PResultBinary& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_stdout_.match(match_value.stdout_(), legacy)){
TTCN_Logger::log_logmatch_info(".stdout");
single_value->field_stdout_.log_match(match_value.stdout_(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_stderr_.match(match_value.stderr_(), legacy)){
TTCN_Logger::log_logmatch_info(".stderr");
single_value->field_stderr_.log_match(match_value.stderr_(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_code.match(match_value.code(), legacy)){
TTCN_Logger::log_logmatch_info(".code");
single_value->field_code.log_match(match_value.code(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ stdout := ");
single_value->field_stdout_.log_match(match_value.stdout_(), legacy);
TTCN_Logger::log_event_str(", stderr := ");
single_value->field_stderr_.log_match(match_value.stderr_(), legacy);
TTCN_Logger::log_event_str(", code := ");
single_value->field_code.log_match(match_value.code(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ASP__PResultBinary_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_stdout_.encode_text(text_buf);
single_value->field_stderr_.encode_text(text_buf);
single_value->field_code.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PResultBinary.");
}
}

void ASP__PResultBinary_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_stdout_.decode_text(text_buf);
single_value->field_stderr_.decode_text(text_buf);
single_value->field_code.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ASP__PResultBinary_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @PIPEasp_Types.ASP_PResultBinary.");
}
}

void ASP__PResultBinary_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
  case Module_Param::MP_ConjunctList_Template: {
    ASP__PResultBinary_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : (param.get_type() == Module_Param::MP_ConjunctList_Template ? CONJUNCTION_MATCH : COMPLEMENTED_LIST), param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (3<param.get_size()) {
      param.error("record template of type @PIPEasp_Types.ASP_PResultBinary has 3 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) stdout_().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) stderr_().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) code().set_param(*param.get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stdout")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stdout_().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stderr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stderr_().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "code")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          code().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PIPEasp_Types.ASP_PResultBinary: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  case Module_Param::MP_Implication_Template: {
    ASP__PResultBinary_template* precondition = new ASP__PResultBinary_template;
    precondition->set_param(*param.get_elem(0));
    ASP__PResultBinary_template* implied_template = new ASP__PResultBinary_template;
    implied_template->set_param(*param.get_elem(1));
    *this = ASP__PResultBinary_template(precondition, implied_template);
  } break;
  default:
    param.type_error("record template", "@PIPEasp_Types.ASP_PResultBinary");
  }
  is_ifpresent = param.get_ifpresent();
}

void ASP__PResultBinary_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_stdout_.check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_PResultBinary");
single_value->field_stderr_.check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_PResultBinary");
single_value->field_code.check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_PResultBinary");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@PIPEasp_Types.ASP_PResultBinary");
}

boolean ASP__PResultBinary_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ASP__PResultBinary_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match_omit() || implication_.implied_template->match_omit();
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ASP__PExecuteBackground::ASP__PExecuteBackground()
{
}

ASP__PExecuteBackground::ASP__PExecuteBackground(const CHARSTRING& par_command)
  :   field_command(par_command)
{
}

ASP__PExecuteBackground::ASP__PExecuteBackground(const ASP__PExecuteBackground& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @PIPEasp_Types.ASP_PExecuteBackground.");
if (other_value.command().is_bound()) field_command = other_value.command();
else field_command.clean_up();
}

void ASP__PExecuteBackground::clean_up()
{
field_command.clean_up();
}

const TTCN_Typedescriptor_t* ASP__PExecuteBackground::get_descriptor() const { return &ASP__PExecuteBackground_descr_; }
ASP__PExecuteBackground& ASP__PExecuteBackground::operator=(const ASP__PExecuteBackground& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @PIPEasp_Types.ASP_PExecuteBackground.");
  if (other_value.command().is_bound()) field_command = other_value.command();
  else field_command.clean_up();
}
return *this;
}

boolean ASP__PExecuteBackground::operator==(const ASP__PExecuteBackground& other_value) const
{
return field_command==other_value.field_command;
}

boolean ASP__PExecuteBackground::is_bound() const
{
return (field_command.is_bound());
}
boolean ASP__PExecuteBackground::is_value() const
{
return field_command.is_value();
}
void ASP__PExecuteBackground::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ command := ");
field_command.log();
TTCN_Logger::log_event_str(" }");
}

void ASP__PExecuteBackground::set_implicit_omit()
{
if (command().is_bound()) command().set_implicit_omit();
}

void ASP__PExecuteBackground::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record value of type @PIPEasp_Types.ASP_PExecuteBackground has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) command().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "command")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          command().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PIPEasp_Types.ASP_PExecuteBackground: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@PIPEasp_Types.ASP_PExecuteBackground");
  }
}

void ASP__PExecuteBackground::encode_text(Text_Buf& text_buf) const
{
field_command.encode_text(text_buf);
}

void ASP__PExecuteBackground::decode_text(Text_Buf& text_buf)
{
field_command.decode_text(text_buf);
}

struct ASP__PExecuteBackground_template::single_value_struct {
CHARSTRING_template field_command;
};

void ASP__PExecuteBackground_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_command = ANY_VALUE;
}
}
}

void ASP__PExecuteBackground_template::copy_value(const ASP__PExecuteBackground& other_value)
{
single_value = new single_value_struct;
if (other_value.command().is_bound()) {
  single_value->field_command = other_value.command();
} else {
  single_value->field_command.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ASP__PExecuteBackground_template::copy_template(const ASP__PExecuteBackground_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.command().get_selection()) {
single_value->field_command = other_value.command();
} else {
single_value->field_command.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ASP__PExecuteBackground_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
case IMPLICATION_MATCH:
implication_.precondition = new ASP__PExecuteBackground_template(*other_value.implication_.precondition);
implication_.implied_template = new ASP__PExecuteBackground_template(*other_value.implication_.implied_template);
break;
case DYNAMIC_MATCH:
dyn_match = other_value.dyn_match;
dyn_match->ref_count++;
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PExecuteBackground.");
break;
}
set_selection(other_value);
}

ASP__PExecuteBackground_template::ASP__PExecuteBackground_template()
{
}

ASP__PExecuteBackground_template::ASP__PExecuteBackground_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ASP__PExecuteBackground_template::ASP__PExecuteBackground_template(const ASP__PExecuteBackground& other_value)
{
copy_value(other_value);
}

ASP__PExecuteBackground_template::ASP__PExecuteBackground_template(const OPTIONAL<ASP__PExecuteBackground>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__PExecuteBackground&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @PIPEasp_Types.ASP_PExecuteBackground from an unbound optional field.");
}
}

ASP__PExecuteBackground_template::ASP__PExecuteBackground_template(ASP__PExecuteBackground_template* p_precondition, ASP__PExecuteBackground_template* p_implied_template)
 : Base_Template(IMPLICATION_MATCH)
{
implication_.precondition = p_precondition;
implication_.implied_template = p_implied_template;
}

ASP__PExecuteBackground_template::ASP__PExecuteBackground_template(Dynamic_Match_Interface<ASP__PExecuteBackground>* p_dyn_match)
 : Base_Template(DYNAMIC_MATCH)
{
dyn_match = new dynmatch_struct<ASP__PExecuteBackground>;
dyn_match->ptr = p_dyn_match;
dyn_match->ref_count = 1;
}

ASP__PExecuteBackground_template::ASP__PExecuteBackground_template(const ASP__PExecuteBackground_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ASP__PExecuteBackground_template::~ASP__PExecuteBackground_template()
{
clean_up();
}

ASP__PExecuteBackground_template& ASP__PExecuteBackground_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ASP__PExecuteBackground_template& ASP__PExecuteBackground_template::operator=(const ASP__PExecuteBackground& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ASP__PExecuteBackground_template& ASP__PExecuteBackground_template::operator=(const OPTIONAL<ASP__PExecuteBackground>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__PExecuteBackground&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @PIPEasp_Types.ASP_PExecuteBackground.");
}
return *this;
}

ASP__PExecuteBackground_template& ASP__PExecuteBackground_template::operator=(const ASP__PExecuteBackground_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ASP__PExecuteBackground_template::match(const ASP__PExecuteBackground& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.command().is_bound()) return FALSE;
if(!single_value->field_command.match(other_value.command(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
case CONJUNCTION_MATCH:
for (unsigned int i = 0; i < value_list.n_values; i++) {
if (!value_list.list_value[i].match(other_value)) {
return FALSE;
}
}
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match(other_value) || implication_.implied_template->match(other_value);
case DYNAMIC_MATCH:
return dyn_match->ptr->match(other_value);
default:
TTCN_error("Matching an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PExecuteBackground.");
}
return FALSE;
}

boolean ASP__PExecuteBackground_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
return single_value->field_command.is_bound();
}

boolean ASP__PExecuteBackground_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value->field_command.is_value();
}

void ASP__PExecuteBackground_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
delete [] value_list.list_value;
break;
case IMPLICATION_MATCH:
delete implication_.precondition;
delete implication_.implied_template;
break;
case DYNAMIC_MATCH:
dyn_match->ref_count--;
if (dyn_match->ref_count == 0) {
delete dyn_match->ptr;
delete dyn_match;
}
break;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ASP__PExecuteBackground ASP__PExecuteBackground_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @PIPEasp_Types.ASP_PExecuteBackground.");
ASP__PExecuteBackground ret_val;
if (single_value->field_command.is_bound()) {
ret_val.command() = single_value->field_command.valueof();
}
return ret_val;
}

void ASP__PExecuteBackground_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST&& template_type != CONJUNCTION_MATCH)
TTCN_error("Setting an invalid list for a template of type @PIPEasp_Types.ASP_PExecuteBackground.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ASP__PExecuteBackground_template[list_length];
}

ASP__PExecuteBackground_template& ASP__PExecuteBackground_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST&& template_selection != CONJUNCTION_MATCH)
TTCN_error("Accessing a list element of a non-list template of type @PIPEasp_Types.ASP_PExecuteBackground.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @PIPEasp_Types.ASP_PExecuteBackground.");
return value_list.list_value[list_index];
}

CHARSTRING_template& ASP__PExecuteBackground_template::command()
{
set_specific();
return single_value->field_command;
}

const CHARSTRING_template& ASP__PExecuteBackground_template::command() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field command of a non-specific template of type @PIPEasp_Types.ASP_PExecuteBackground.");
return single_value->field_command;
}

int ASP__PExecuteBackground_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecuteBackground which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecuteBackground containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecuteBackground containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecuteBackground containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecuteBackground containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecuteBackground containing complemented list.");
  case CONJUNCTION_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecuteBackground containing a conjunction list match.");
  case IMPLICATION_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecuteBackground containing an implication match.");
  case DYNAMIC_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecuteBackground containing a dynamic match.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PExecuteBackground.");
  }
  return 0;
}

void ASP__PExecuteBackground_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ command := ");
single_value->field_command.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case CONJUNCTION_MATCH:
if (template_selection == CONJUNCTION_MATCH) {
TTCN_Logger::log_event_str("conjunct");
}
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
case IMPLICATION_MATCH:
implication_.precondition->log();
TTCN_Logger::log_event_str(" implies ");
implication_.implied_template->log();
break;
case DYNAMIC_MATCH:
TTCN_Logger::log_event_str("@dynamic template");
break;
default:
log_generic();
}
log_ifpresent();
}

void ASP__PExecuteBackground_template::log_match(const ASP__PExecuteBackground& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_command.match(match_value.command(), legacy)){
TTCN_Logger::log_logmatch_info(".command");
single_value->field_command.log_match(match_value.command(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ command := ");
single_value->field_command.log_match(match_value.command(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ASP__PExecuteBackground_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_command.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PExecuteBackground.");
}
}

void ASP__PExecuteBackground_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_command.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ASP__PExecuteBackground_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @PIPEasp_Types.ASP_PExecuteBackground.");
}
}

void ASP__PExecuteBackground_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
  case Module_Param::MP_ConjunctList_Template: {
    ASP__PExecuteBackground_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : (param.get_type() == Module_Param::MP_ConjunctList_Template ? CONJUNCTION_MATCH : COMPLEMENTED_LIST), param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record template of type @PIPEasp_Types.ASP_PExecuteBackground has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) command().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "command")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          command().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PIPEasp_Types.ASP_PExecuteBackground: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  case Module_Param::MP_Implication_Template: {
    ASP__PExecuteBackground_template* precondition = new ASP__PExecuteBackground_template;
    precondition->set_param(*param.get_elem(0));
    ASP__PExecuteBackground_template* implied_template = new ASP__PExecuteBackground_template;
    implied_template->set_param(*param.get_elem(1));
    *this = ASP__PExecuteBackground_template(precondition, implied_template);
  } break;
  default:
    param.type_error("record template", "@PIPEasp_Types.ASP_PExecuteBackground");
  }
  is_ifpresent = param.get_ifpresent();
}

void ASP__PExecuteBackground_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_command.check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_PExecuteBackground");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@PIPEasp_Types.ASP_PExecuteBackground");
}

boolean ASP__PExecuteBackground_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ASP__PExecuteBackground_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match_omit() || implication_.implied_template->match_omit();
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ASP__PExecuteBackgroundPty::ASP__PExecuteBackgroundPty()
{
}

ASP__PExecuteBackgroundPty::ASP__PExecuteBackgroundPty(const CHARSTRING& par_command)
  :   field_command(par_command)
{
}

ASP__PExecuteBackgroundPty::ASP__PExecuteBackgroundPty(const ASP__PExecuteBackgroundPty& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @PIPEasp_Types.ASP_PExecuteBackgroundPty.");
if (other_value.command().is_bound()) field_command = other_value.command();
else field_command.clean_up();
}

void ASP__PExecuteBackgroundPty::clean_up()
{
field_command.clean_up();
}

const TTCN_Typedescriptor_t* ASP__PExecuteBackgroundPty::get_descriptor() const { return &ASP__PExecuteBackgroundPty_descr_; }
ASP__PExecuteBackgroundPty& ASP__PExecuteBackgroundPty::operator=(const ASP__PExecuteBackgroundPty& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @PIPEasp_Types.ASP_PExecuteBackgroundPty.");
  if (other_value.command().is_bound()) field_command = other_value.command();
  else field_command.clean_up();
}
return *this;
}

boolean ASP__PExecuteBackgroundPty::operator==(const ASP__PExecuteBackgroundPty& other_value) const
{
return field_command==other_value.field_command;
}

boolean ASP__PExecuteBackgroundPty::is_bound() const
{
return (field_command.is_bound());
}
boolean ASP__PExecuteBackgroundPty::is_value() const
{
return field_command.is_value();
}
void ASP__PExecuteBackgroundPty::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ command := ");
field_command.log();
TTCN_Logger::log_event_str(" }");
}

void ASP__PExecuteBackgroundPty::set_implicit_omit()
{
if (command().is_bound()) command().set_implicit_omit();
}

void ASP__PExecuteBackgroundPty::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record value of type @PIPEasp_Types.ASP_PExecuteBackgroundPty has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) command().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "command")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          command().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PIPEasp_Types.ASP_PExecuteBackgroundPty: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@PIPEasp_Types.ASP_PExecuteBackgroundPty");
  }
}

void ASP__PExecuteBackgroundPty::encode_text(Text_Buf& text_buf) const
{
field_command.encode_text(text_buf);
}

void ASP__PExecuteBackgroundPty::decode_text(Text_Buf& text_buf)
{
field_command.decode_text(text_buf);
}

struct ASP__PExecuteBackgroundPty_template::single_value_struct {
CHARSTRING_template field_command;
};

void ASP__PExecuteBackgroundPty_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_command = ANY_VALUE;
}
}
}

void ASP__PExecuteBackgroundPty_template::copy_value(const ASP__PExecuteBackgroundPty& other_value)
{
single_value = new single_value_struct;
if (other_value.command().is_bound()) {
  single_value->field_command = other_value.command();
} else {
  single_value->field_command.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ASP__PExecuteBackgroundPty_template::copy_template(const ASP__PExecuteBackgroundPty_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.command().get_selection()) {
single_value->field_command = other_value.command();
} else {
single_value->field_command.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ASP__PExecuteBackgroundPty_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
case IMPLICATION_MATCH:
implication_.precondition = new ASP__PExecuteBackgroundPty_template(*other_value.implication_.precondition);
implication_.implied_template = new ASP__PExecuteBackgroundPty_template(*other_value.implication_.implied_template);
break;
case DYNAMIC_MATCH:
dyn_match = other_value.dyn_match;
dyn_match->ref_count++;
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PExecuteBackgroundPty.");
break;
}
set_selection(other_value);
}

ASP__PExecuteBackgroundPty_template::ASP__PExecuteBackgroundPty_template()
{
}

ASP__PExecuteBackgroundPty_template::ASP__PExecuteBackgroundPty_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ASP__PExecuteBackgroundPty_template::ASP__PExecuteBackgroundPty_template(const ASP__PExecuteBackgroundPty& other_value)
{
copy_value(other_value);
}

ASP__PExecuteBackgroundPty_template::ASP__PExecuteBackgroundPty_template(const OPTIONAL<ASP__PExecuteBackgroundPty>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__PExecuteBackgroundPty&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @PIPEasp_Types.ASP_PExecuteBackgroundPty from an unbound optional field.");
}
}

ASP__PExecuteBackgroundPty_template::ASP__PExecuteBackgroundPty_template(ASP__PExecuteBackgroundPty_template* p_precondition, ASP__PExecuteBackgroundPty_template* p_implied_template)
 : Base_Template(IMPLICATION_MATCH)
{
implication_.precondition = p_precondition;
implication_.implied_template = p_implied_template;
}

ASP__PExecuteBackgroundPty_template::ASP__PExecuteBackgroundPty_template(Dynamic_Match_Interface<ASP__PExecuteBackgroundPty>* p_dyn_match)
 : Base_Template(DYNAMIC_MATCH)
{
dyn_match = new dynmatch_struct<ASP__PExecuteBackgroundPty>;
dyn_match->ptr = p_dyn_match;
dyn_match->ref_count = 1;
}

ASP__PExecuteBackgroundPty_template::ASP__PExecuteBackgroundPty_template(const ASP__PExecuteBackgroundPty_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ASP__PExecuteBackgroundPty_template::~ASP__PExecuteBackgroundPty_template()
{
clean_up();
}

ASP__PExecuteBackgroundPty_template& ASP__PExecuteBackgroundPty_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ASP__PExecuteBackgroundPty_template& ASP__PExecuteBackgroundPty_template::operator=(const ASP__PExecuteBackgroundPty& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ASP__PExecuteBackgroundPty_template& ASP__PExecuteBackgroundPty_template::operator=(const OPTIONAL<ASP__PExecuteBackgroundPty>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__PExecuteBackgroundPty&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @PIPEasp_Types.ASP_PExecuteBackgroundPty.");
}
return *this;
}

ASP__PExecuteBackgroundPty_template& ASP__PExecuteBackgroundPty_template::operator=(const ASP__PExecuteBackgroundPty_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ASP__PExecuteBackgroundPty_template::match(const ASP__PExecuteBackgroundPty& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.command().is_bound()) return FALSE;
if(!single_value->field_command.match(other_value.command(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
case CONJUNCTION_MATCH:
for (unsigned int i = 0; i < value_list.n_values; i++) {
if (!value_list.list_value[i].match(other_value)) {
return FALSE;
}
}
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match(other_value) || implication_.implied_template->match(other_value);
case DYNAMIC_MATCH:
return dyn_match->ptr->match(other_value);
default:
TTCN_error("Matching an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PExecuteBackgroundPty.");
}
return FALSE;
}

boolean ASP__PExecuteBackgroundPty_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
return single_value->field_command.is_bound();
}

boolean ASP__PExecuteBackgroundPty_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value->field_command.is_value();
}

void ASP__PExecuteBackgroundPty_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
delete [] value_list.list_value;
break;
case IMPLICATION_MATCH:
delete implication_.precondition;
delete implication_.implied_template;
break;
case DYNAMIC_MATCH:
dyn_match->ref_count--;
if (dyn_match->ref_count == 0) {
delete dyn_match->ptr;
delete dyn_match;
}
break;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ASP__PExecuteBackgroundPty ASP__PExecuteBackgroundPty_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @PIPEasp_Types.ASP_PExecuteBackgroundPty.");
ASP__PExecuteBackgroundPty ret_val;
if (single_value->field_command.is_bound()) {
ret_val.command() = single_value->field_command.valueof();
}
return ret_val;
}

void ASP__PExecuteBackgroundPty_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST&& template_type != CONJUNCTION_MATCH)
TTCN_error("Setting an invalid list for a template of type @PIPEasp_Types.ASP_PExecuteBackgroundPty.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ASP__PExecuteBackgroundPty_template[list_length];
}

ASP__PExecuteBackgroundPty_template& ASP__PExecuteBackgroundPty_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST&& template_selection != CONJUNCTION_MATCH)
TTCN_error("Accessing a list element of a non-list template of type @PIPEasp_Types.ASP_PExecuteBackgroundPty.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @PIPEasp_Types.ASP_PExecuteBackgroundPty.");
return value_list.list_value[list_index];
}

CHARSTRING_template& ASP__PExecuteBackgroundPty_template::command()
{
set_specific();
return single_value->field_command;
}

const CHARSTRING_template& ASP__PExecuteBackgroundPty_template::command() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field command of a non-specific template of type @PIPEasp_Types.ASP_PExecuteBackgroundPty.");
return single_value->field_command;
}

int ASP__PExecuteBackgroundPty_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecuteBackgroundPty which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecuteBackgroundPty containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecuteBackgroundPty containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecuteBackgroundPty containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecuteBackgroundPty containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecuteBackgroundPty containing complemented list.");
  case CONJUNCTION_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecuteBackgroundPty containing a conjunction list match.");
  case IMPLICATION_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecuteBackgroundPty containing an implication match.");
  case DYNAMIC_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExecuteBackgroundPty containing a dynamic match.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PExecuteBackgroundPty.");
  }
  return 0;
}

void ASP__PExecuteBackgroundPty_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ command := ");
single_value->field_command.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case CONJUNCTION_MATCH:
if (template_selection == CONJUNCTION_MATCH) {
TTCN_Logger::log_event_str("conjunct");
}
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
case IMPLICATION_MATCH:
implication_.precondition->log();
TTCN_Logger::log_event_str(" implies ");
implication_.implied_template->log();
break;
case DYNAMIC_MATCH:
TTCN_Logger::log_event_str("@dynamic template");
break;
default:
log_generic();
}
log_ifpresent();
}

void ASP__PExecuteBackgroundPty_template::log_match(const ASP__PExecuteBackgroundPty& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_command.match(match_value.command(), legacy)){
TTCN_Logger::log_logmatch_info(".command");
single_value->field_command.log_match(match_value.command(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ command := ");
single_value->field_command.log_match(match_value.command(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ASP__PExecuteBackgroundPty_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_command.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PExecuteBackgroundPty.");
}
}

void ASP__PExecuteBackgroundPty_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_command.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ASP__PExecuteBackgroundPty_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @PIPEasp_Types.ASP_PExecuteBackgroundPty.");
}
}

void ASP__PExecuteBackgroundPty_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
  case Module_Param::MP_ConjunctList_Template: {
    ASP__PExecuteBackgroundPty_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : (param.get_type() == Module_Param::MP_ConjunctList_Template ? CONJUNCTION_MATCH : COMPLEMENTED_LIST), param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record template of type @PIPEasp_Types.ASP_PExecuteBackgroundPty has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) command().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "command")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          command().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PIPEasp_Types.ASP_PExecuteBackgroundPty: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  case Module_Param::MP_Implication_Template: {
    ASP__PExecuteBackgroundPty_template* precondition = new ASP__PExecuteBackgroundPty_template;
    precondition->set_param(*param.get_elem(0));
    ASP__PExecuteBackgroundPty_template* implied_template = new ASP__PExecuteBackgroundPty_template;
    implied_template->set_param(*param.get_elem(1));
    *this = ASP__PExecuteBackgroundPty_template(precondition, implied_template);
  } break;
  default:
    param.type_error("record template", "@PIPEasp_Types.ASP_PExecuteBackgroundPty");
  }
  is_ifpresent = param.get_ifpresent();
}

void ASP__PExecuteBackgroundPty_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_command.check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_PExecuteBackgroundPty");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@PIPEasp_Types.ASP_PExecuteBackgroundPty");
}

boolean ASP__PExecuteBackgroundPty_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ASP__PExecuteBackgroundPty_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match_omit() || implication_.implied_template->match_omit();
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ASP__PStdin::ASP__PStdin()
{
}

ASP__PStdin::ASP__PStdin(const CHARSTRING& par_stdin_)
  :   field_stdin_(par_stdin_)
{
}

ASP__PStdin::ASP__PStdin(const ASP__PStdin& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @PIPEasp_Types.ASP_PStdin.");
if (other_value.stdin_().is_bound()) field_stdin_ = other_value.stdin_();
else field_stdin_.clean_up();
}

void ASP__PStdin::clean_up()
{
field_stdin_.clean_up();
}

const TTCN_Typedescriptor_t* ASP__PStdin::get_descriptor() const { return &ASP__PStdin_descr_; }
ASP__PStdin& ASP__PStdin::operator=(const ASP__PStdin& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @PIPEasp_Types.ASP_PStdin.");
  if (other_value.stdin_().is_bound()) field_stdin_ = other_value.stdin_();
  else field_stdin_.clean_up();
}
return *this;
}

boolean ASP__PStdin::operator==(const ASP__PStdin& other_value) const
{
return field_stdin_==other_value.field_stdin_;
}

boolean ASP__PStdin::is_bound() const
{
return (field_stdin_.is_bound());
}
boolean ASP__PStdin::is_value() const
{
return field_stdin_.is_value();
}
void ASP__PStdin::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ stdin := ");
field_stdin_.log();
TTCN_Logger::log_event_str(" }");
}

void ASP__PStdin::set_implicit_omit()
{
if (stdin_().is_bound()) stdin_().set_implicit_omit();
}

void ASP__PStdin::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record value of type @PIPEasp_Types.ASP_PStdin has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) stdin_().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stdin")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stdin_().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PIPEasp_Types.ASP_PStdin: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@PIPEasp_Types.ASP_PStdin");
  }
}

void ASP__PStdin::encode_text(Text_Buf& text_buf) const
{
field_stdin_.encode_text(text_buf);
}

void ASP__PStdin::decode_text(Text_Buf& text_buf)
{
field_stdin_.decode_text(text_buf);
}

struct ASP__PStdin_template::single_value_struct {
CHARSTRING_template field_stdin_;
};

void ASP__PStdin_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_stdin_ = ANY_VALUE;
}
}
}

void ASP__PStdin_template::copy_value(const ASP__PStdin& other_value)
{
single_value = new single_value_struct;
if (other_value.stdin_().is_bound()) {
  single_value->field_stdin_ = other_value.stdin_();
} else {
  single_value->field_stdin_.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ASP__PStdin_template::copy_template(const ASP__PStdin_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.stdin_().get_selection()) {
single_value->field_stdin_ = other_value.stdin_();
} else {
single_value->field_stdin_.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ASP__PStdin_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
case IMPLICATION_MATCH:
implication_.precondition = new ASP__PStdin_template(*other_value.implication_.precondition);
implication_.implied_template = new ASP__PStdin_template(*other_value.implication_.implied_template);
break;
case DYNAMIC_MATCH:
dyn_match = other_value.dyn_match;
dyn_match->ref_count++;
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PStdin.");
break;
}
set_selection(other_value);
}

ASP__PStdin_template::ASP__PStdin_template()
{
}

ASP__PStdin_template::ASP__PStdin_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ASP__PStdin_template::ASP__PStdin_template(const ASP__PStdin& other_value)
{
copy_value(other_value);
}

ASP__PStdin_template::ASP__PStdin_template(const OPTIONAL<ASP__PStdin>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__PStdin&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @PIPEasp_Types.ASP_PStdin from an unbound optional field.");
}
}

ASP__PStdin_template::ASP__PStdin_template(ASP__PStdin_template* p_precondition, ASP__PStdin_template* p_implied_template)
 : Base_Template(IMPLICATION_MATCH)
{
implication_.precondition = p_precondition;
implication_.implied_template = p_implied_template;
}

ASP__PStdin_template::ASP__PStdin_template(Dynamic_Match_Interface<ASP__PStdin>* p_dyn_match)
 : Base_Template(DYNAMIC_MATCH)
{
dyn_match = new dynmatch_struct<ASP__PStdin>;
dyn_match->ptr = p_dyn_match;
dyn_match->ref_count = 1;
}

ASP__PStdin_template::ASP__PStdin_template(const ASP__PStdin_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ASP__PStdin_template::~ASP__PStdin_template()
{
clean_up();
}

ASP__PStdin_template& ASP__PStdin_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ASP__PStdin_template& ASP__PStdin_template::operator=(const ASP__PStdin& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ASP__PStdin_template& ASP__PStdin_template::operator=(const OPTIONAL<ASP__PStdin>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__PStdin&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @PIPEasp_Types.ASP_PStdin.");
}
return *this;
}

ASP__PStdin_template& ASP__PStdin_template::operator=(const ASP__PStdin_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ASP__PStdin_template::match(const ASP__PStdin& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.stdin_().is_bound()) return FALSE;
if(!single_value->field_stdin_.match(other_value.stdin_(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
case CONJUNCTION_MATCH:
for (unsigned int i = 0; i < value_list.n_values; i++) {
if (!value_list.list_value[i].match(other_value)) {
return FALSE;
}
}
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match(other_value) || implication_.implied_template->match(other_value);
case DYNAMIC_MATCH:
return dyn_match->ptr->match(other_value);
default:
TTCN_error("Matching an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PStdin.");
}
return FALSE;
}

boolean ASP__PStdin_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
return single_value->field_stdin_.is_bound();
}

boolean ASP__PStdin_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value->field_stdin_.is_value();
}

void ASP__PStdin_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
delete [] value_list.list_value;
break;
case IMPLICATION_MATCH:
delete implication_.precondition;
delete implication_.implied_template;
break;
case DYNAMIC_MATCH:
dyn_match->ref_count--;
if (dyn_match->ref_count == 0) {
delete dyn_match->ptr;
delete dyn_match;
}
break;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ASP__PStdin ASP__PStdin_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @PIPEasp_Types.ASP_PStdin.");
ASP__PStdin ret_val;
if (single_value->field_stdin_.is_bound()) {
ret_val.stdin_() = single_value->field_stdin_.valueof();
}
return ret_val;
}

void ASP__PStdin_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST&& template_type != CONJUNCTION_MATCH)
TTCN_error("Setting an invalid list for a template of type @PIPEasp_Types.ASP_PStdin.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ASP__PStdin_template[list_length];
}

ASP__PStdin_template& ASP__PStdin_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST&& template_selection != CONJUNCTION_MATCH)
TTCN_error("Accessing a list element of a non-list template of type @PIPEasp_Types.ASP_PStdin.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @PIPEasp_Types.ASP_PStdin.");
return value_list.list_value[list_index];
}

CHARSTRING_template& ASP__PStdin_template::stdin_()
{
set_specific();
return single_value->field_stdin_;
}

const CHARSTRING_template& ASP__PStdin_template::stdin_() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field stdin of a non-specific template of type @PIPEasp_Types.ASP_PStdin.");
return single_value->field_stdin_;
}

int ASP__PStdin_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStdin which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStdin containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStdin containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStdin containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStdin containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStdin containing complemented list.");
  case CONJUNCTION_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStdin containing a conjunction list match.");
  case IMPLICATION_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStdin containing an implication match.");
  case DYNAMIC_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStdin containing a dynamic match.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PStdin.");
  }
  return 0;
}

void ASP__PStdin_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ stdin := ");
single_value->field_stdin_.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case CONJUNCTION_MATCH:
if (template_selection == CONJUNCTION_MATCH) {
TTCN_Logger::log_event_str("conjunct");
}
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
case IMPLICATION_MATCH:
implication_.precondition->log();
TTCN_Logger::log_event_str(" implies ");
implication_.implied_template->log();
break;
case DYNAMIC_MATCH:
TTCN_Logger::log_event_str("@dynamic template");
break;
default:
log_generic();
}
log_ifpresent();
}

void ASP__PStdin_template::log_match(const ASP__PStdin& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_stdin_.match(match_value.stdin_(), legacy)){
TTCN_Logger::log_logmatch_info(".stdin");
single_value->field_stdin_.log_match(match_value.stdin_(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ stdin := ");
single_value->field_stdin_.log_match(match_value.stdin_(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ASP__PStdin_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_stdin_.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PStdin.");
}
}

void ASP__PStdin_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_stdin_.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ASP__PStdin_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @PIPEasp_Types.ASP_PStdin.");
}
}

void ASP__PStdin_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
  case Module_Param::MP_ConjunctList_Template: {
    ASP__PStdin_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : (param.get_type() == Module_Param::MP_ConjunctList_Template ? CONJUNCTION_MATCH : COMPLEMENTED_LIST), param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record template of type @PIPEasp_Types.ASP_PStdin has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) stdin_().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stdin")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stdin_().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PIPEasp_Types.ASP_PStdin: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  case Module_Param::MP_Implication_Template: {
    ASP__PStdin_template* precondition = new ASP__PStdin_template;
    precondition->set_param(*param.get_elem(0));
    ASP__PStdin_template* implied_template = new ASP__PStdin_template;
    implied_template->set_param(*param.get_elem(1));
    *this = ASP__PStdin_template(precondition, implied_template);
  } break;
  default:
    param.type_error("record template", "@PIPEasp_Types.ASP_PStdin");
  }
  is_ifpresent = param.get_ifpresent();
}

void ASP__PStdin_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_stdin_.check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_PStdin");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@PIPEasp_Types.ASP_PStdin");
}

boolean ASP__PStdin_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ASP__PStdin_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match_omit() || implication_.implied_template->match_omit();
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ASP__PStdout::ASP__PStdout()
{
}

ASP__PStdout::ASP__PStdout(const CHARSTRING& par_stdout_)
  :   field_stdout_(par_stdout_)
{
}

ASP__PStdout::ASP__PStdout(const ASP__PStdout& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @PIPEasp_Types.ASP_PStdout.");
if (other_value.stdout_().is_bound()) field_stdout_ = other_value.stdout_();
else field_stdout_.clean_up();
}

void ASP__PStdout::clean_up()
{
field_stdout_.clean_up();
}

const TTCN_Typedescriptor_t* ASP__PStdout::get_descriptor() const { return &ASP__PStdout_descr_; }
ASP__PStdout& ASP__PStdout::operator=(const ASP__PStdout& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @PIPEasp_Types.ASP_PStdout.");
  if (other_value.stdout_().is_bound()) field_stdout_ = other_value.stdout_();
  else field_stdout_.clean_up();
}
return *this;
}

boolean ASP__PStdout::operator==(const ASP__PStdout& other_value) const
{
return field_stdout_==other_value.field_stdout_;
}

boolean ASP__PStdout::is_bound() const
{
return (field_stdout_.is_bound());
}
boolean ASP__PStdout::is_value() const
{
return field_stdout_.is_value();
}
void ASP__PStdout::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ stdout := ");
field_stdout_.log();
TTCN_Logger::log_event_str(" }");
}

void ASP__PStdout::set_implicit_omit()
{
if (stdout_().is_bound()) stdout_().set_implicit_omit();
}

void ASP__PStdout::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record value of type @PIPEasp_Types.ASP_PStdout has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) stdout_().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stdout")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stdout_().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PIPEasp_Types.ASP_PStdout: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@PIPEasp_Types.ASP_PStdout");
  }
}

void ASP__PStdout::encode_text(Text_Buf& text_buf) const
{
field_stdout_.encode_text(text_buf);
}

void ASP__PStdout::decode_text(Text_Buf& text_buf)
{
field_stdout_.decode_text(text_buf);
}

struct ASP__PStdout_template::single_value_struct {
CHARSTRING_template field_stdout_;
};

void ASP__PStdout_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_stdout_ = ANY_VALUE;
}
}
}

void ASP__PStdout_template::copy_value(const ASP__PStdout& other_value)
{
single_value = new single_value_struct;
if (other_value.stdout_().is_bound()) {
  single_value->field_stdout_ = other_value.stdout_();
} else {
  single_value->field_stdout_.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ASP__PStdout_template::copy_template(const ASP__PStdout_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.stdout_().get_selection()) {
single_value->field_stdout_ = other_value.stdout_();
} else {
single_value->field_stdout_.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ASP__PStdout_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
case IMPLICATION_MATCH:
implication_.precondition = new ASP__PStdout_template(*other_value.implication_.precondition);
implication_.implied_template = new ASP__PStdout_template(*other_value.implication_.implied_template);
break;
case DYNAMIC_MATCH:
dyn_match = other_value.dyn_match;
dyn_match->ref_count++;
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PStdout.");
break;
}
set_selection(other_value);
}

ASP__PStdout_template::ASP__PStdout_template()
{
}

ASP__PStdout_template::ASP__PStdout_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ASP__PStdout_template::ASP__PStdout_template(const ASP__PStdout& other_value)
{
copy_value(other_value);
}

ASP__PStdout_template::ASP__PStdout_template(const OPTIONAL<ASP__PStdout>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__PStdout&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @PIPEasp_Types.ASP_PStdout from an unbound optional field.");
}
}

ASP__PStdout_template::ASP__PStdout_template(ASP__PStdout_template* p_precondition, ASP__PStdout_template* p_implied_template)
 : Base_Template(IMPLICATION_MATCH)
{
implication_.precondition = p_precondition;
implication_.implied_template = p_implied_template;
}

ASP__PStdout_template::ASP__PStdout_template(Dynamic_Match_Interface<ASP__PStdout>* p_dyn_match)
 : Base_Template(DYNAMIC_MATCH)
{
dyn_match = new dynmatch_struct<ASP__PStdout>;
dyn_match->ptr = p_dyn_match;
dyn_match->ref_count = 1;
}

ASP__PStdout_template::ASP__PStdout_template(const ASP__PStdout_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ASP__PStdout_template::~ASP__PStdout_template()
{
clean_up();
}

ASP__PStdout_template& ASP__PStdout_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ASP__PStdout_template& ASP__PStdout_template::operator=(const ASP__PStdout& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ASP__PStdout_template& ASP__PStdout_template::operator=(const OPTIONAL<ASP__PStdout>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__PStdout&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @PIPEasp_Types.ASP_PStdout.");
}
return *this;
}

ASP__PStdout_template& ASP__PStdout_template::operator=(const ASP__PStdout_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ASP__PStdout_template::match(const ASP__PStdout& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.stdout_().is_bound()) return FALSE;
if(!single_value->field_stdout_.match(other_value.stdout_(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
case CONJUNCTION_MATCH:
for (unsigned int i = 0; i < value_list.n_values; i++) {
if (!value_list.list_value[i].match(other_value)) {
return FALSE;
}
}
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match(other_value) || implication_.implied_template->match(other_value);
case DYNAMIC_MATCH:
return dyn_match->ptr->match(other_value);
default:
TTCN_error("Matching an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PStdout.");
}
return FALSE;
}

boolean ASP__PStdout_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
return single_value->field_stdout_.is_bound();
}

boolean ASP__PStdout_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value->field_stdout_.is_value();
}

void ASP__PStdout_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
delete [] value_list.list_value;
break;
case IMPLICATION_MATCH:
delete implication_.precondition;
delete implication_.implied_template;
break;
case DYNAMIC_MATCH:
dyn_match->ref_count--;
if (dyn_match->ref_count == 0) {
delete dyn_match->ptr;
delete dyn_match;
}
break;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ASP__PStdout ASP__PStdout_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @PIPEasp_Types.ASP_PStdout.");
ASP__PStdout ret_val;
if (single_value->field_stdout_.is_bound()) {
ret_val.stdout_() = single_value->field_stdout_.valueof();
}
return ret_val;
}

void ASP__PStdout_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST&& template_type != CONJUNCTION_MATCH)
TTCN_error("Setting an invalid list for a template of type @PIPEasp_Types.ASP_PStdout.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ASP__PStdout_template[list_length];
}

ASP__PStdout_template& ASP__PStdout_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST&& template_selection != CONJUNCTION_MATCH)
TTCN_error("Accessing a list element of a non-list template of type @PIPEasp_Types.ASP_PStdout.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @PIPEasp_Types.ASP_PStdout.");
return value_list.list_value[list_index];
}

CHARSTRING_template& ASP__PStdout_template::stdout_()
{
set_specific();
return single_value->field_stdout_;
}

const CHARSTRING_template& ASP__PStdout_template::stdout_() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field stdout of a non-specific template of type @PIPEasp_Types.ASP_PStdout.");
return single_value->field_stdout_;
}

int ASP__PStdout_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStdout which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStdout containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStdout containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStdout containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStdout containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStdout containing complemented list.");
  case CONJUNCTION_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStdout containing a conjunction list match.");
  case IMPLICATION_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStdout containing an implication match.");
  case DYNAMIC_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStdout containing a dynamic match.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PStdout.");
  }
  return 0;
}

void ASP__PStdout_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ stdout := ");
single_value->field_stdout_.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case CONJUNCTION_MATCH:
if (template_selection == CONJUNCTION_MATCH) {
TTCN_Logger::log_event_str("conjunct");
}
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
case IMPLICATION_MATCH:
implication_.precondition->log();
TTCN_Logger::log_event_str(" implies ");
implication_.implied_template->log();
break;
case DYNAMIC_MATCH:
TTCN_Logger::log_event_str("@dynamic template");
break;
default:
log_generic();
}
log_ifpresent();
}

void ASP__PStdout_template::log_match(const ASP__PStdout& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_stdout_.match(match_value.stdout_(), legacy)){
TTCN_Logger::log_logmatch_info(".stdout");
single_value->field_stdout_.log_match(match_value.stdout_(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ stdout := ");
single_value->field_stdout_.log_match(match_value.stdout_(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ASP__PStdout_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_stdout_.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PStdout.");
}
}

void ASP__PStdout_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_stdout_.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ASP__PStdout_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @PIPEasp_Types.ASP_PStdout.");
}
}

void ASP__PStdout_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
  case Module_Param::MP_ConjunctList_Template: {
    ASP__PStdout_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : (param.get_type() == Module_Param::MP_ConjunctList_Template ? CONJUNCTION_MATCH : COMPLEMENTED_LIST), param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record template of type @PIPEasp_Types.ASP_PStdout has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) stdout_().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stdout")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stdout_().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PIPEasp_Types.ASP_PStdout: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  case Module_Param::MP_Implication_Template: {
    ASP__PStdout_template* precondition = new ASP__PStdout_template;
    precondition->set_param(*param.get_elem(0));
    ASP__PStdout_template* implied_template = new ASP__PStdout_template;
    implied_template->set_param(*param.get_elem(1));
    *this = ASP__PStdout_template(precondition, implied_template);
  } break;
  default:
    param.type_error("record template", "@PIPEasp_Types.ASP_PStdout");
  }
  is_ifpresent = param.get_ifpresent();
}

void ASP__PStdout_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_stdout_.check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_PStdout");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@PIPEasp_Types.ASP_PStdout");
}

boolean ASP__PStdout_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ASP__PStdout_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match_omit() || implication_.implied_template->match_omit();
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ASP__PStderr::ASP__PStderr()
{
}

ASP__PStderr::ASP__PStderr(const CHARSTRING& par_stderr_)
  :   field_stderr_(par_stderr_)
{
}

ASP__PStderr::ASP__PStderr(const ASP__PStderr& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @PIPEasp_Types.ASP_PStderr.");
if (other_value.stderr_().is_bound()) field_stderr_ = other_value.stderr_();
else field_stderr_.clean_up();
}

void ASP__PStderr::clean_up()
{
field_stderr_.clean_up();
}

const TTCN_Typedescriptor_t* ASP__PStderr::get_descriptor() const { return &ASP__PStderr_descr_; }
ASP__PStderr& ASP__PStderr::operator=(const ASP__PStderr& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @PIPEasp_Types.ASP_PStderr.");
  if (other_value.stderr_().is_bound()) field_stderr_ = other_value.stderr_();
  else field_stderr_.clean_up();
}
return *this;
}

boolean ASP__PStderr::operator==(const ASP__PStderr& other_value) const
{
return field_stderr_==other_value.field_stderr_;
}

boolean ASP__PStderr::is_bound() const
{
return (field_stderr_.is_bound());
}
boolean ASP__PStderr::is_value() const
{
return field_stderr_.is_value();
}
void ASP__PStderr::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ stderr := ");
field_stderr_.log();
TTCN_Logger::log_event_str(" }");
}

void ASP__PStderr::set_implicit_omit()
{
if (stderr_().is_bound()) stderr_().set_implicit_omit();
}

void ASP__PStderr::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record value of type @PIPEasp_Types.ASP_PStderr has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) stderr_().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stderr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stderr_().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PIPEasp_Types.ASP_PStderr: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@PIPEasp_Types.ASP_PStderr");
  }
}

void ASP__PStderr::encode_text(Text_Buf& text_buf) const
{
field_stderr_.encode_text(text_buf);
}

void ASP__PStderr::decode_text(Text_Buf& text_buf)
{
field_stderr_.decode_text(text_buf);
}

struct ASP__PStderr_template::single_value_struct {
CHARSTRING_template field_stderr_;
};

void ASP__PStderr_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_stderr_ = ANY_VALUE;
}
}
}

void ASP__PStderr_template::copy_value(const ASP__PStderr& other_value)
{
single_value = new single_value_struct;
if (other_value.stderr_().is_bound()) {
  single_value->field_stderr_ = other_value.stderr_();
} else {
  single_value->field_stderr_.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ASP__PStderr_template::copy_template(const ASP__PStderr_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.stderr_().get_selection()) {
single_value->field_stderr_ = other_value.stderr_();
} else {
single_value->field_stderr_.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ASP__PStderr_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
case IMPLICATION_MATCH:
implication_.precondition = new ASP__PStderr_template(*other_value.implication_.precondition);
implication_.implied_template = new ASP__PStderr_template(*other_value.implication_.implied_template);
break;
case DYNAMIC_MATCH:
dyn_match = other_value.dyn_match;
dyn_match->ref_count++;
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PStderr.");
break;
}
set_selection(other_value);
}

ASP__PStderr_template::ASP__PStderr_template()
{
}

ASP__PStderr_template::ASP__PStderr_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ASP__PStderr_template::ASP__PStderr_template(const ASP__PStderr& other_value)
{
copy_value(other_value);
}

ASP__PStderr_template::ASP__PStderr_template(const OPTIONAL<ASP__PStderr>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__PStderr&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @PIPEasp_Types.ASP_PStderr from an unbound optional field.");
}
}

ASP__PStderr_template::ASP__PStderr_template(ASP__PStderr_template* p_precondition, ASP__PStderr_template* p_implied_template)
 : Base_Template(IMPLICATION_MATCH)
{
implication_.precondition = p_precondition;
implication_.implied_template = p_implied_template;
}

ASP__PStderr_template::ASP__PStderr_template(Dynamic_Match_Interface<ASP__PStderr>* p_dyn_match)
 : Base_Template(DYNAMIC_MATCH)
{
dyn_match = new dynmatch_struct<ASP__PStderr>;
dyn_match->ptr = p_dyn_match;
dyn_match->ref_count = 1;
}

ASP__PStderr_template::ASP__PStderr_template(const ASP__PStderr_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ASP__PStderr_template::~ASP__PStderr_template()
{
clean_up();
}

ASP__PStderr_template& ASP__PStderr_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ASP__PStderr_template& ASP__PStderr_template::operator=(const ASP__PStderr& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ASP__PStderr_template& ASP__PStderr_template::operator=(const OPTIONAL<ASP__PStderr>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__PStderr&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @PIPEasp_Types.ASP_PStderr.");
}
return *this;
}

ASP__PStderr_template& ASP__PStderr_template::operator=(const ASP__PStderr_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ASP__PStderr_template::match(const ASP__PStderr& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.stderr_().is_bound()) return FALSE;
if(!single_value->field_stderr_.match(other_value.stderr_(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
case CONJUNCTION_MATCH:
for (unsigned int i = 0; i < value_list.n_values; i++) {
if (!value_list.list_value[i].match(other_value)) {
return FALSE;
}
}
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match(other_value) || implication_.implied_template->match(other_value);
case DYNAMIC_MATCH:
return dyn_match->ptr->match(other_value);
default:
TTCN_error("Matching an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PStderr.");
}
return FALSE;
}

boolean ASP__PStderr_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
return single_value->field_stderr_.is_bound();
}

boolean ASP__PStderr_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value->field_stderr_.is_value();
}

void ASP__PStderr_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
delete [] value_list.list_value;
break;
case IMPLICATION_MATCH:
delete implication_.precondition;
delete implication_.implied_template;
break;
case DYNAMIC_MATCH:
dyn_match->ref_count--;
if (dyn_match->ref_count == 0) {
delete dyn_match->ptr;
delete dyn_match;
}
break;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ASP__PStderr ASP__PStderr_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @PIPEasp_Types.ASP_PStderr.");
ASP__PStderr ret_val;
if (single_value->field_stderr_.is_bound()) {
ret_val.stderr_() = single_value->field_stderr_.valueof();
}
return ret_val;
}

void ASP__PStderr_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST&& template_type != CONJUNCTION_MATCH)
TTCN_error("Setting an invalid list for a template of type @PIPEasp_Types.ASP_PStderr.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ASP__PStderr_template[list_length];
}

ASP__PStderr_template& ASP__PStderr_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST&& template_selection != CONJUNCTION_MATCH)
TTCN_error("Accessing a list element of a non-list template of type @PIPEasp_Types.ASP_PStderr.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @PIPEasp_Types.ASP_PStderr.");
return value_list.list_value[list_index];
}

CHARSTRING_template& ASP__PStderr_template::stderr_()
{
set_specific();
return single_value->field_stderr_;
}

const CHARSTRING_template& ASP__PStderr_template::stderr_() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field stderr of a non-specific template of type @PIPEasp_Types.ASP_PStderr.");
return single_value->field_stderr_;
}

int ASP__PStderr_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStderr which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStderr containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStderr containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStderr containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStderr containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStderr containing complemented list.");
  case CONJUNCTION_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStderr containing a conjunction list match.");
  case IMPLICATION_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStderr containing an implication match.");
  case DYNAMIC_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStderr containing a dynamic match.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PStderr.");
  }
  return 0;
}

void ASP__PStderr_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ stderr := ");
single_value->field_stderr_.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case CONJUNCTION_MATCH:
if (template_selection == CONJUNCTION_MATCH) {
TTCN_Logger::log_event_str("conjunct");
}
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
case IMPLICATION_MATCH:
implication_.precondition->log();
TTCN_Logger::log_event_str(" implies ");
implication_.implied_template->log();
break;
case DYNAMIC_MATCH:
TTCN_Logger::log_event_str("@dynamic template");
break;
default:
log_generic();
}
log_ifpresent();
}

void ASP__PStderr_template::log_match(const ASP__PStderr& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_stderr_.match(match_value.stderr_(), legacy)){
TTCN_Logger::log_logmatch_info(".stderr");
single_value->field_stderr_.log_match(match_value.stderr_(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ stderr := ");
single_value->field_stderr_.log_match(match_value.stderr_(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ASP__PStderr_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_stderr_.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PStderr.");
}
}

void ASP__PStderr_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_stderr_.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ASP__PStderr_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @PIPEasp_Types.ASP_PStderr.");
}
}

void ASP__PStderr_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
  case Module_Param::MP_ConjunctList_Template: {
    ASP__PStderr_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : (param.get_type() == Module_Param::MP_ConjunctList_Template ? CONJUNCTION_MATCH : COMPLEMENTED_LIST), param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record template of type @PIPEasp_Types.ASP_PStderr has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) stderr_().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stderr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stderr_().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PIPEasp_Types.ASP_PStderr: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  case Module_Param::MP_Implication_Template: {
    ASP__PStderr_template* precondition = new ASP__PStderr_template;
    precondition->set_param(*param.get_elem(0));
    ASP__PStderr_template* implied_template = new ASP__PStderr_template;
    implied_template->set_param(*param.get_elem(1));
    *this = ASP__PStderr_template(precondition, implied_template);
  } break;
  default:
    param.type_error("record template", "@PIPEasp_Types.ASP_PStderr");
  }
  is_ifpresent = param.get_ifpresent();
}

void ASP__PStderr_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_stderr_.check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_PStderr");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@PIPEasp_Types.ASP_PStderr");
}

boolean ASP__PStderr_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ASP__PStderr_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match_omit() || implication_.implied_template->match_omit();
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ASP__PStdinBinary::ASP__PStdinBinary()
{
}

ASP__PStdinBinary::ASP__PStdinBinary(const OCTETSTRING& par_stdin_)
  :   field_stdin_(par_stdin_)
{
}

ASP__PStdinBinary::ASP__PStdinBinary(const ASP__PStdinBinary& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @PIPEasp_Types.ASP_PStdinBinary.");
if (other_value.stdin_().is_bound()) field_stdin_ = other_value.stdin_();
else field_stdin_.clean_up();
}

void ASP__PStdinBinary::clean_up()
{
field_stdin_.clean_up();
}

const TTCN_Typedescriptor_t* ASP__PStdinBinary::get_descriptor() const { return &ASP__PStdinBinary_descr_; }
ASP__PStdinBinary& ASP__PStdinBinary::operator=(const ASP__PStdinBinary& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @PIPEasp_Types.ASP_PStdinBinary.");
  if (other_value.stdin_().is_bound()) field_stdin_ = other_value.stdin_();
  else field_stdin_.clean_up();
}
return *this;
}

boolean ASP__PStdinBinary::operator==(const ASP__PStdinBinary& other_value) const
{
return field_stdin_==other_value.field_stdin_;
}

boolean ASP__PStdinBinary::is_bound() const
{
return (field_stdin_.is_bound());
}
boolean ASP__PStdinBinary::is_value() const
{
return field_stdin_.is_value();
}
void ASP__PStdinBinary::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ stdin := ");
field_stdin_.log();
TTCN_Logger::log_event_str(" }");
}

void ASP__PStdinBinary::set_implicit_omit()
{
if (stdin_().is_bound()) stdin_().set_implicit_omit();
}

void ASP__PStdinBinary::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record value of type @PIPEasp_Types.ASP_PStdinBinary has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) stdin_().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stdin")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stdin_().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PIPEasp_Types.ASP_PStdinBinary: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@PIPEasp_Types.ASP_PStdinBinary");
  }
}

void ASP__PStdinBinary::encode_text(Text_Buf& text_buf) const
{
field_stdin_.encode_text(text_buf);
}

void ASP__PStdinBinary::decode_text(Text_Buf& text_buf)
{
field_stdin_.decode_text(text_buf);
}

struct ASP__PStdinBinary_template::single_value_struct {
OCTETSTRING_template field_stdin_;
};

void ASP__PStdinBinary_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_stdin_ = ANY_VALUE;
}
}
}

void ASP__PStdinBinary_template::copy_value(const ASP__PStdinBinary& other_value)
{
single_value = new single_value_struct;
if (other_value.stdin_().is_bound()) {
  single_value->field_stdin_ = other_value.stdin_();
} else {
  single_value->field_stdin_.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ASP__PStdinBinary_template::copy_template(const ASP__PStdinBinary_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.stdin_().get_selection()) {
single_value->field_stdin_ = other_value.stdin_();
} else {
single_value->field_stdin_.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ASP__PStdinBinary_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
case IMPLICATION_MATCH:
implication_.precondition = new ASP__PStdinBinary_template(*other_value.implication_.precondition);
implication_.implied_template = new ASP__PStdinBinary_template(*other_value.implication_.implied_template);
break;
case DYNAMIC_MATCH:
dyn_match = other_value.dyn_match;
dyn_match->ref_count++;
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PStdinBinary.");
break;
}
set_selection(other_value);
}

ASP__PStdinBinary_template::ASP__PStdinBinary_template()
{
}

ASP__PStdinBinary_template::ASP__PStdinBinary_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ASP__PStdinBinary_template::ASP__PStdinBinary_template(const ASP__PStdinBinary& other_value)
{
copy_value(other_value);
}

ASP__PStdinBinary_template::ASP__PStdinBinary_template(const OPTIONAL<ASP__PStdinBinary>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__PStdinBinary&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @PIPEasp_Types.ASP_PStdinBinary from an unbound optional field.");
}
}

ASP__PStdinBinary_template::ASP__PStdinBinary_template(ASP__PStdinBinary_template* p_precondition, ASP__PStdinBinary_template* p_implied_template)
 : Base_Template(IMPLICATION_MATCH)
{
implication_.precondition = p_precondition;
implication_.implied_template = p_implied_template;
}

ASP__PStdinBinary_template::ASP__PStdinBinary_template(Dynamic_Match_Interface<ASP__PStdinBinary>* p_dyn_match)
 : Base_Template(DYNAMIC_MATCH)
{
dyn_match = new dynmatch_struct<ASP__PStdinBinary>;
dyn_match->ptr = p_dyn_match;
dyn_match->ref_count = 1;
}

ASP__PStdinBinary_template::ASP__PStdinBinary_template(const ASP__PStdinBinary_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ASP__PStdinBinary_template::~ASP__PStdinBinary_template()
{
clean_up();
}

ASP__PStdinBinary_template& ASP__PStdinBinary_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ASP__PStdinBinary_template& ASP__PStdinBinary_template::operator=(const ASP__PStdinBinary& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ASP__PStdinBinary_template& ASP__PStdinBinary_template::operator=(const OPTIONAL<ASP__PStdinBinary>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__PStdinBinary&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @PIPEasp_Types.ASP_PStdinBinary.");
}
return *this;
}

ASP__PStdinBinary_template& ASP__PStdinBinary_template::operator=(const ASP__PStdinBinary_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ASP__PStdinBinary_template::match(const ASP__PStdinBinary& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.stdin_().is_bound()) return FALSE;
if(!single_value->field_stdin_.match(other_value.stdin_(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
case CONJUNCTION_MATCH:
for (unsigned int i = 0; i < value_list.n_values; i++) {
if (!value_list.list_value[i].match(other_value)) {
return FALSE;
}
}
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match(other_value) || implication_.implied_template->match(other_value);
case DYNAMIC_MATCH:
return dyn_match->ptr->match(other_value);
default:
TTCN_error("Matching an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PStdinBinary.");
}
return FALSE;
}

boolean ASP__PStdinBinary_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
return single_value->field_stdin_.is_bound();
}

boolean ASP__PStdinBinary_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value->field_stdin_.is_value();
}

void ASP__PStdinBinary_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
delete [] value_list.list_value;
break;
case IMPLICATION_MATCH:
delete implication_.precondition;
delete implication_.implied_template;
break;
case DYNAMIC_MATCH:
dyn_match->ref_count--;
if (dyn_match->ref_count == 0) {
delete dyn_match->ptr;
delete dyn_match;
}
break;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ASP__PStdinBinary ASP__PStdinBinary_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @PIPEasp_Types.ASP_PStdinBinary.");
ASP__PStdinBinary ret_val;
if (single_value->field_stdin_.is_bound()) {
ret_val.stdin_() = single_value->field_stdin_.valueof();
}
return ret_val;
}

void ASP__PStdinBinary_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST&& template_type != CONJUNCTION_MATCH)
TTCN_error("Setting an invalid list for a template of type @PIPEasp_Types.ASP_PStdinBinary.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ASP__PStdinBinary_template[list_length];
}

ASP__PStdinBinary_template& ASP__PStdinBinary_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST&& template_selection != CONJUNCTION_MATCH)
TTCN_error("Accessing a list element of a non-list template of type @PIPEasp_Types.ASP_PStdinBinary.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @PIPEasp_Types.ASP_PStdinBinary.");
return value_list.list_value[list_index];
}

OCTETSTRING_template& ASP__PStdinBinary_template::stdin_()
{
set_specific();
return single_value->field_stdin_;
}

const OCTETSTRING_template& ASP__PStdinBinary_template::stdin_() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field stdin of a non-specific template of type @PIPEasp_Types.ASP_PStdinBinary.");
return single_value->field_stdin_;
}

int ASP__PStdinBinary_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStdinBinary which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStdinBinary containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStdinBinary containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStdinBinary containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStdinBinary containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStdinBinary containing complemented list.");
  case CONJUNCTION_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStdinBinary containing a conjunction list match.");
  case IMPLICATION_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStdinBinary containing an implication match.");
  case DYNAMIC_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStdinBinary containing a dynamic match.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PStdinBinary.");
  }
  return 0;
}

void ASP__PStdinBinary_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ stdin := ");
single_value->field_stdin_.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case CONJUNCTION_MATCH:
if (template_selection == CONJUNCTION_MATCH) {
TTCN_Logger::log_event_str("conjunct");
}
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
case IMPLICATION_MATCH:
implication_.precondition->log();
TTCN_Logger::log_event_str(" implies ");
implication_.implied_template->log();
break;
case DYNAMIC_MATCH:
TTCN_Logger::log_event_str("@dynamic template");
break;
default:
log_generic();
}
log_ifpresent();
}

void ASP__PStdinBinary_template::log_match(const ASP__PStdinBinary& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_stdin_.match(match_value.stdin_(), legacy)){
TTCN_Logger::log_logmatch_info(".stdin");
single_value->field_stdin_.log_match(match_value.stdin_(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ stdin := ");
single_value->field_stdin_.log_match(match_value.stdin_(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ASP__PStdinBinary_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_stdin_.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PStdinBinary.");
}
}

void ASP__PStdinBinary_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_stdin_.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ASP__PStdinBinary_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @PIPEasp_Types.ASP_PStdinBinary.");
}
}

void ASP__PStdinBinary_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
  case Module_Param::MP_ConjunctList_Template: {
    ASP__PStdinBinary_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : (param.get_type() == Module_Param::MP_ConjunctList_Template ? CONJUNCTION_MATCH : COMPLEMENTED_LIST), param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record template of type @PIPEasp_Types.ASP_PStdinBinary has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) stdin_().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stdin")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stdin_().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PIPEasp_Types.ASP_PStdinBinary: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  case Module_Param::MP_Implication_Template: {
    ASP__PStdinBinary_template* precondition = new ASP__PStdinBinary_template;
    precondition->set_param(*param.get_elem(0));
    ASP__PStdinBinary_template* implied_template = new ASP__PStdinBinary_template;
    implied_template->set_param(*param.get_elem(1));
    *this = ASP__PStdinBinary_template(precondition, implied_template);
  } break;
  default:
    param.type_error("record template", "@PIPEasp_Types.ASP_PStdinBinary");
  }
  is_ifpresent = param.get_ifpresent();
}

void ASP__PStdinBinary_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_stdin_.check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_PStdinBinary");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@PIPEasp_Types.ASP_PStdinBinary");
}

boolean ASP__PStdinBinary_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ASP__PStdinBinary_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match_omit() || implication_.implied_template->match_omit();
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ASP__PStdoutBinary::ASP__PStdoutBinary()
{
}

ASP__PStdoutBinary::ASP__PStdoutBinary(const OCTETSTRING& par_stdout_)
  :   field_stdout_(par_stdout_)
{
}

ASP__PStdoutBinary::ASP__PStdoutBinary(const ASP__PStdoutBinary& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @PIPEasp_Types.ASP_PStdoutBinary.");
if (other_value.stdout_().is_bound()) field_stdout_ = other_value.stdout_();
else field_stdout_.clean_up();
}

void ASP__PStdoutBinary::clean_up()
{
field_stdout_.clean_up();
}

const TTCN_Typedescriptor_t* ASP__PStdoutBinary::get_descriptor() const { return &ASP__PStdoutBinary_descr_; }
ASP__PStdoutBinary& ASP__PStdoutBinary::operator=(const ASP__PStdoutBinary& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @PIPEasp_Types.ASP_PStdoutBinary.");
  if (other_value.stdout_().is_bound()) field_stdout_ = other_value.stdout_();
  else field_stdout_.clean_up();
}
return *this;
}

boolean ASP__PStdoutBinary::operator==(const ASP__PStdoutBinary& other_value) const
{
return field_stdout_==other_value.field_stdout_;
}

boolean ASP__PStdoutBinary::is_bound() const
{
return (field_stdout_.is_bound());
}
boolean ASP__PStdoutBinary::is_value() const
{
return field_stdout_.is_value();
}
void ASP__PStdoutBinary::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ stdout := ");
field_stdout_.log();
TTCN_Logger::log_event_str(" }");
}

void ASP__PStdoutBinary::set_implicit_omit()
{
if (stdout_().is_bound()) stdout_().set_implicit_omit();
}

void ASP__PStdoutBinary::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record value of type @PIPEasp_Types.ASP_PStdoutBinary has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) stdout_().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stdout")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stdout_().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PIPEasp_Types.ASP_PStdoutBinary: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@PIPEasp_Types.ASP_PStdoutBinary");
  }
}

void ASP__PStdoutBinary::encode_text(Text_Buf& text_buf) const
{
field_stdout_.encode_text(text_buf);
}

void ASP__PStdoutBinary::decode_text(Text_Buf& text_buf)
{
field_stdout_.decode_text(text_buf);
}

struct ASP__PStdoutBinary_template::single_value_struct {
OCTETSTRING_template field_stdout_;
};

void ASP__PStdoutBinary_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_stdout_ = ANY_VALUE;
}
}
}

void ASP__PStdoutBinary_template::copy_value(const ASP__PStdoutBinary& other_value)
{
single_value = new single_value_struct;
if (other_value.stdout_().is_bound()) {
  single_value->field_stdout_ = other_value.stdout_();
} else {
  single_value->field_stdout_.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ASP__PStdoutBinary_template::copy_template(const ASP__PStdoutBinary_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.stdout_().get_selection()) {
single_value->field_stdout_ = other_value.stdout_();
} else {
single_value->field_stdout_.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ASP__PStdoutBinary_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
case IMPLICATION_MATCH:
implication_.precondition = new ASP__PStdoutBinary_template(*other_value.implication_.precondition);
implication_.implied_template = new ASP__PStdoutBinary_template(*other_value.implication_.implied_template);
break;
case DYNAMIC_MATCH:
dyn_match = other_value.dyn_match;
dyn_match->ref_count++;
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PStdoutBinary.");
break;
}
set_selection(other_value);
}

ASP__PStdoutBinary_template::ASP__PStdoutBinary_template()
{
}

ASP__PStdoutBinary_template::ASP__PStdoutBinary_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ASP__PStdoutBinary_template::ASP__PStdoutBinary_template(const ASP__PStdoutBinary& other_value)
{
copy_value(other_value);
}

ASP__PStdoutBinary_template::ASP__PStdoutBinary_template(const OPTIONAL<ASP__PStdoutBinary>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__PStdoutBinary&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @PIPEasp_Types.ASP_PStdoutBinary from an unbound optional field.");
}
}

ASP__PStdoutBinary_template::ASP__PStdoutBinary_template(ASP__PStdoutBinary_template* p_precondition, ASP__PStdoutBinary_template* p_implied_template)
 : Base_Template(IMPLICATION_MATCH)
{
implication_.precondition = p_precondition;
implication_.implied_template = p_implied_template;
}

ASP__PStdoutBinary_template::ASP__PStdoutBinary_template(Dynamic_Match_Interface<ASP__PStdoutBinary>* p_dyn_match)
 : Base_Template(DYNAMIC_MATCH)
{
dyn_match = new dynmatch_struct<ASP__PStdoutBinary>;
dyn_match->ptr = p_dyn_match;
dyn_match->ref_count = 1;
}

ASP__PStdoutBinary_template::ASP__PStdoutBinary_template(const ASP__PStdoutBinary_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ASP__PStdoutBinary_template::~ASP__PStdoutBinary_template()
{
clean_up();
}

ASP__PStdoutBinary_template& ASP__PStdoutBinary_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ASP__PStdoutBinary_template& ASP__PStdoutBinary_template::operator=(const ASP__PStdoutBinary& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ASP__PStdoutBinary_template& ASP__PStdoutBinary_template::operator=(const OPTIONAL<ASP__PStdoutBinary>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__PStdoutBinary&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @PIPEasp_Types.ASP_PStdoutBinary.");
}
return *this;
}

ASP__PStdoutBinary_template& ASP__PStdoutBinary_template::operator=(const ASP__PStdoutBinary_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ASP__PStdoutBinary_template::match(const ASP__PStdoutBinary& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.stdout_().is_bound()) return FALSE;
if(!single_value->field_stdout_.match(other_value.stdout_(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
case CONJUNCTION_MATCH:
for (unsigned int i = 0; i < value_list.n_values; i++) {
if (!value_list.list_value[i].match(other_value)) {
return FALSE;
}
}
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match(other_value) || implication_.implied_template->match(other_value);
case DYNAMIC_MATCH:
return dyn_match->ptr->match(other_value);
default:
TTCN_error("Matching an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PStdoutBinary.");
}
return FALSE;
}

boolean ASP__PStdoutBinary_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
return single_value->field_stdout_.is_bound();
}

boolean ASP__PStdoutBinary_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value->field_stdout_.is_value();
}

void ASP__PStdoutBinary_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
delete [] value_list.list_value;
break;
case IMPLICATION_MATCH:
delete implication_.precondition;
delete implication_.implied_template;
break;
case DYNAMIC_MATCH:
dyn_match->ref_count--;
if (dyn_match->ref_count == 0) {
delete dyn_match->ptr;
delete dyn_match;
}
break;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ASP__PStdoutBinary ASP__PStdoutBinary_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @PIPEasp_Types.ASP_PStdoutBinary.");
ASP__PStdoutBinary ret_val;
if (single_value->field_stdout_.is_bound()) {
ret_val.stdout_() = single_value->field_stdout_.valueof();
}
return ret_val;
}

void ASP__PStdoutBinary_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST&& template_type != CONJUNCTION_MATCH)
TTCN_error("Setting an invalid list for a template of type @PIPEasp_Types.ASP_PStdoutBinary.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ASP__PStdoutBinary_template[list_length];
}

ASP__PStdoutBinary_template& ASP__PStdoutBinary_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST&& template_selection != CONJUNCTION_MATCH)
TTCN_error("Accessing a list element of a non-list template of type @PIPEasp_Types.ASP_PStdoutBinary.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @PIPEasp_Types.ASP_PStdoutBinary.");
return value_list.list_value[list_index];
}

OCTETSTRING_template& ASP__PStdoutBinary_template::stdout_()
{
set_specific();
return single_value->field_stdout_;
}

const OCTETSTRING_template& ASP__PStdoutBinary_template::stdout_() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field stdout of a non-specific template of type @PIPEasp_Types.ASP_PStdoutBinary.");
return single_value->field_stdout_;
}

int ASP__PStdoutBinary_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStdoutBinary which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStdoutBinary containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStdoutBinary containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStdoutBinary containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStdoutBinary containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStdoutBinary containing complemented list.");
  case CONJUNCTION_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStdoutBinary containing a conjunction list match.");
  case IMPLICATION_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStdoutBinary containing an implication match.");
  case DYNAMIC_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStdoutBinary containing a dynamic match.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PStdoutBinary.");
  }
  return 0;
}

void ASP__PStdoutBinary_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ stdout := ");
single_value->field_stdout_.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case CONJUNCTION_MATCH:
if (template_selection == CONJUNCTION_MATCH) {
TTCN_Logger::log_event_str("conjunct");
}
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
case IMPLICATION_MATCH:
implication_.precondition->log();
TTCN_Logger::log_event_str(" implies ");
implication_.implied_template->log();
break;
case DYNAMIC_MATCH:
TTCN_Logger::log_event_str("@dynamic template");
break;
default:
log_generic();
}
log_ifpresent();
}

void ASP__PStdoutBinary_template::log_match(const ASP__PStdoutBinary& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_stdout_.match(match_value.stdout_(), legacy)){
TTCN_Logger::log_logmatch_info(".stdout");
single_value->field_stdout_.log_match(match_value.stdout_(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ stdout := ");
single_value->field_stdout_.log_match(match_value.stdout_(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ASP__PStdoutBinary_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_stdout_.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PStdoutBinary.");
}
}

void ASP__PStdoutBinary_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_stdout_.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ASP__PStdoutBinary_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @PIPEasp_Types.ASP_PStdoutBinary.");
}
}

void ASP__PStdoutBinary_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
  case Module_Param::MP_ConjunctList_Template: {
    ASP__PStdoutBinary_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : (param.get_type() == Module_Param::MP_ConjunctList_Template ? CONJUNCTION_MATCH : COMPLEMENTED_LIST), param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record template of type @PIPEasp_Types.ASP_PStdoutBinary has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) stdout_().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stdout")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stdout_().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PIPEasp_Types.ASP_PStdoutBinary: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  case Module_Param::MP_Implication_Template: {
    ASP__PStdoutBinary_template* precondition = new ASP__PStdoutBinary_template;
    precondition->set_param(*param.get_elem(0));
    ASP__PStdoutBinary_template* implied_template = new ASP__PStdoutBinary_template;
    implied_template->set_param(*param.get_elem(1));
    *this = ASP__PStdoutBinary_template(precondition, implied_template);
  } break;
  default:
    param.type_error("record template", "@PIPEasp_Types.ASP_PStdoutBinary");
  }
  is_ifpresent = param.get_ifpresent();
}

void ASP__PStdoutBinary_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_stdout_.check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_PStdoutBinary");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@PIPEasp_Types.ASP_PStdoutBinary");
}

boolean ASP__PStdoutBinary_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ASP__PStdoutBinary_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match_omit() || implication_.implied_template->match_omit();
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ASP__PStderrBinary::ASP__PStderrBinary()
{
}

ASP__PStderrBinary::ASP__PStderrBinary(const OCTETSTRING& par_stderr_)
  :   field_stderr_(par_stderr_)
{
}

ASP__PStderrBinary::ASP__PStderrBinary(const ASP__PStderrBinary& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @PIPEasp_Types.ASP_PStderrBinary.");
if (other_value.stderr_().is_bound()) field_stderr_ = other_value.stderr_();
else field_stderr_.clean_up();
}

void ASP__PStderrBinary::clean_up()
{
field_stderr_.clean_up();
}

const TTCN_Typedescriptor_t* ASP__PStderrBinary::get_descriptor() const { return &ASP__PStderrBinary_descr_; }
ASP__PStderrBinary& ASP__PStderrBinary::operator=(const ASP__PStderrBinary& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @PIPEasp_Types.ASP_PStderrBinary.");
  if (other_value.stderr_().is_bound()) field_stderr_ = other_value.stderr_();
  else field_stderr_.clean_up();
}
return *this;
}

boolean ASP__PStderrBinary::operator==(const ASP__PStderrBinary& other_value) const
{
return field_stderr_==other_value.field_stderr_;
}

boolean ASP__PStderrBinary::is_bound() const
{
return (field_stderr_.is_bound());
}
boolean ASP__PStderrBinary::is_value() const
{
return field_stderr_.is_value();
}
void ASP__PStderrBinary::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ stderr := ");
field_stderr_.log();
TTCN_Logger::log_event_str(" }");
}

void ASP__PStderrBinary::set_implicit_omit()
{
if (stderr_().is_bound()) stderr_().set_implicit_omit();
}

void ASP__PStderrBinary::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record value of type @PIPEasp_Types.ASP_PStderrBinary has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) stderr_().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stderr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stderr_().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PIPEasp_Types.ASP_PStderrBinary: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@PIPEasp_Types.ASP_PStderrBinary");
  }
}

void ASP__PStderrBinary::encode_text(Text_Buf& text_buf) const
{
field_stderr_.encode_text(text_buf);
}

void ASP__PStderrBinary::decode_text(Text_Buf& text_buf)
{
field_stderr_.decode_text(text_buf);
}

struct ASP__PStderrBinary_template::single_value_struct {
OCTETSTRING_template field_stderr_;
};

void ASP__PStderrBinary_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_stderr_ = ANY_VALUE;
}
}
}

void ASP__PStderrBinary_template::copy_value(const ASP__PStderrBinary& other_value)
{
single_value = new single_value_struct;
if (other_value.stderr_().is_bound()) {
  single_value->field_stderr_ = other_value.stderr_();
} else {
  single_value->field_stderr_.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ASP__PStderrBinary_template::copy_template(const ASP__PStderrBinary_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.stderr_().get_selection()) {
single_value->field_stderr_ = other_value.stderr_();
} else {
single_value->field_stderr_.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ASP__PStderrBinary_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
case IMPLICATION_MATCH:
implication_.precondition = new ASP__PStderrBinary_template(*other_value.implication_.precondition);
implication_.implied_template = new ASP__PStderrBinary_template(*other_value.implication_.implied_template);
break;
case DYNAMIC_MATCH:
dyn_match = other_value.dyn_match;
dyn_match->ref_count++;
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PStderrBinary.");
break;
}
set_selection(other_value);
}

ASP__PStderrBinary_template::ASP__PStderrBinary_template()
{
}

ASP__PStderrBinary_template::ASP__PStderrBinary_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ASP__PStderrBinary_template::ASP__PStderrBinary_template(const ASP__PStderrBinary& other_value)
{
copy_value(other_value);
}

ASP__PStderrBinary_template::ASP__PStderrBinary_template(const OPTIONAL<ASP__PStderrBinary>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__PStderrBinary&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @PIPEasp_Types.ASP_PStderrBinary from an unbound optional field.");
}
}

ASP__PStderrBinary_template::ASP__PStderrBinary_template(ASP__PStderrBinary_template* p_precondition, ASP__PStderrBinary_template* p_implied_template)
 : Base_Template(IMPLICATION_MATCH)
{
implication_.precondition = p_precondition;
implication_.implied_template = p_implied_template;
}

ASP__PStderrBinary_template::ASP__PStderrBinary_template(Dynamic_Match_Interface<ASP__PStderrBinary>* p_dyn_match)
 : Base_Template(DYNAMIC_MATCH)
{
dyn_match = new dynmatch_struct<ASP__PStderrBinary>;
dyn_match->ptr = p_dyn_match;
dyn_match->ref_count = 1;
}

ASP__PStderrBinary_template::ASP__PStderrBinary_template(const ASP__PStderrBinary_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ASP__PStderrBinary_template::~ASP__PStderrBinary_template()
{
clean_up();
}

ASP__PStderrBinary_template& ASP__PStderrBinary_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ASP__PStderrBinary_template& ASP__PStderrBinary_template::operator=(const ASP__PStderrBinary& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ASP__PStderrBinary_template& ASP__PStderrBinary_template::operator=(const OPTIONAL<ASP__PStderrBinary>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__PStderrBinary&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @PIPEasp_Types.ASP_PStderrBinary.");
}
return *this;
}

ASP__PStderrBinary_template& ASP__PStderrBinary_template::operator=(const ASP__PStderrBinary_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ASP__PStderrBinary_template::match(const ASP__PStderrBinary& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.stderr_().is_bound()) return FALSE;
if(!single_value->field_stderr_.match(other_value.stderr_(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
case CONJUNCTION_MATCH:
for (unsigned int i = 0; i < value_list.n_values; i++) {
if (!value_list.list_value[i].match(other_value)) {
return FALSE;
}
}
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match(other_value) || implication_.implied_template->match(other_value);
case DYNAMIC_MATCH:
return dyn_match->ptr->match(other_value);
default:
TTCN_error("Matching an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PStderrBinary.");
}
return FALSE;
}

boolean ASP__PStderrBinary_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
return single_value->field_stderr_.is_bound();
}

boolean ASP__PStderrBinary_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value->field_stderr_.is_value();
}

void ASP__PStderrBinary_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
delete [] value_list.list_value;
break;
case IMPLICATION_MATCH:
delete implication_.precondition;
delete implication_.implied_template;
break;
case DYNAMIC_MATCH:
dyn_match->ref_count--;
if (dyn_match->ref_count == 0) {
delete dyn_match->ptr;
delete dyn_match;
}
break;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ASP__PStderrBinary ASP__PStderrBinary_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @PIPEasp_Types.ASP_PStderrBinary.");
ASP__PStderrBinary ret_val;
if (single_value->field_stderr_.is_bound()) {
ret_val.stderr_() = single_value->field_stderr_.valueof();
}
return ret_val;
}

void ASP__PStderrBinary_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST&& template_type != CONJUNCTION_MATCH)
TTCN_error("Setting an invalid list for a template of type @PIPEasp_Types.ASP_PStderrBinary.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ASP__PStderrBinary_template[list_length];
}

ASP__PStderrBinary_template& ASP__PStderrBinary_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST&& template_selection != CONJUNCTION_MATCH)
TTCN_error("Accessing a list element of a non-list template of type @PIPEasp_Types.ASP_PStderrBinary.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @PIPEasp_Types.ASP_PStderrBinary.");
return value_list.list_value[list_index];
}

OCTETSTRING_template& ASP__PStderrBinary_template::stderr_()
{
set_specific();
return single_value->field_stderr_;
}

const OCTETSTRING_template& ASP__PStderrBinary_template::stderr_() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field stderr of a non-specific template of type @PIPEasp_Types.ASP_PStderrBinary.");
return single_value->field_stderr_;
}

int ASP__PStderrBinary_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStderrBinary which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStderrBinary containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStderrBinary containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStderrBinary containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStderrBinary containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStderrBinary containing complemented list.");
  case CONJUNCTION_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStderrBinary containing a conjunction list match.");
  case IMPLICATION_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStderrBinary containing an implication match.");
  case DYNAMIC_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PStderrBinary containing a dynamic match.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PStderrBinary.");
  }
  return 0;
}

void ASP__PStderrBinary_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ stderr := ");
single_value->field_stderr_.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case CONJUNCTION_MATCH:
if (template_selection == CONJUNCTION_MATCH) {
TTCN_Logger::log_event_str("conjunct");
}
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
case IMPLICATION_MATCH:
implication_.precondition->log();
TTCN_Logger::log_event_str(" implies ");
implication_.implied_template->log();
break;
case DYNAMIC_MATCH:
TTCN_Logger::log_event_str("@dynamic template");
break;
default:
log_generic();
}
log_ifpresent();
}

void ASP__PStderrBinary_template::log_match(const ASP__PStderrBinary& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_stderr_.match(match_value.stderr_(), legacy)){
TTCN_Logger::log_logmatch_info(".stderr");
single_value->field_stderr_.log_match(match_value.stderr_(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ stderr := ");
single_value->field_stderr_.log_match(match_value.stderr_(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ASP__PStderrBinary_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_stderr_.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PStderrBinary.");
}
}

void ASP__PStderrBinary_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_stderr_.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ASP__PStderrBinary_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @PIPEasp_Types.ASP_PStderrBinary.");
}
}

void ASP__PStderrBinary_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
  case Module_Param::MP_ConjunctList_Template: {
    ASP__PStderrBinary_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : (param.get_type() == Module_Param::MP_ConjunctList_Template ? CONJUNCTION_MATCH : COMPLEMENTED_LIST), param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record template of type @PIPEasp_Types.ASP_PStderrBinary has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) stderr_().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stderr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stderr_().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PIPEasp_Types.ASP_PStderrBinary: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  case Module_Param::MP_Implication_Template: {
    ASP__PStderrBinary_template* precondition = new ASP__PStderrBinary_template;
    precondition->set_param(*param.get_elem(0));
    ASP__PStderrBinary_template* implied_template = new ASP__PStderrBinary_template;
    implied_template->set_param(*param.get_elem(1));
    *this = ASP__PStderrBinary_template(precondition, implied_template);
  } break;
  default:
    param.type_error("record template", "@PIPEasp_Types.ASP_PStderrBinary");
  }
  is_ifpresent = param.get_ifpresent();
}

void ASP__PStderrBinary_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_stderr_.check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_PStderrBinary");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@PIPEasp_Types.ASP_PStderrBinary");
}

boolean ASP__PStderrBinary_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ASP__PStderrBinary_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match_omit() || implication_.implied_template->match_omit();
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ASP__PKill::ASP__PKill()
{
}

ASP__PKill::ASP__PKill(const INTEGER& par_signal)
  :   field_signal(par_signal)
{
}

ASP__PKill::ASP__PKill(const ASP__PKill& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @PIPEasp_Types.ASP_PKill.");
if (other_value.signal().is_bound()) field_signal = other_value.signal();
else field_signal.clean_up();
}

void ASP__PKill::clean_up()
{
field_signal.clean_up();
}

const TTCN_Typedescriptor_t* ASP__PKill::get_descriptor() const { return &ASP__PKill_descr_; }
ASP__PKill& ASP__PKill::operator=(const ASP__PKill& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @PIPEasp_Types.ASP_PKill.");
  if (other_value.signal().is_bound()) field_signal = other_value.signal();
  else field_signal.clean_up();
}
return *this;
}

boolean ASP__PKill::operator==(const ASP__PKill& other_value) const
{
return field_signal==other_value.field_signal;
}

boolean ASP__PKill::is_bound() const
{
return (field_signal.is_bound());
}
boolean ASP__PKill::is_value() const
{
return field_signal.is_value();
}
void ASP__PKill::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ signal := ");
field_signal.log();
TTCN_Logger::log_event_str(" }");
}

void ASP__PKill::set_implicit_omit()
{
if (signal().is_bound()) signal().set_implicit_omit();
}

void ASP__PKill::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record value of type @PIPEasp_Types.ASP_PKill has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) signal().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "signal")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          signal().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PIPEasp_Types.ASP_PKill: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@PIPEasp_Types.ASP_PKill");
  }
}

void ASP__PKill::encode_text(Text_Buf& text_buf) const
{
field_signal.encode_text(text_buf);
}

void ASP__PKill::decode_text(Text_Buf& text_buf)
{
field_signal.decode_text(text_buf);
}

struct ASP__PKill_template::single_value_struct {
INTEGER_template field_signal;
};

void ASP__PKill_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_signal = ANY_VALUE;
}
}
}

void ASP__PKill_template::copy_value(const ASP__PKill& other_value)
{
single_value = new single_value_struct;
if (other_value.signal().is_bound()) {
  single_value->field_signal = other_value.signal();
} else {
  single_value->field_signal.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ASP__PKill_template::copy_template(const ASP__PKill_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.signal().get_selection()) {
single_value->field_signal = other_value.signal();
} else {
single_value->field_signal.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ASP__PKill_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
case IMPLICATION_MATCH:
implication_.precondition = new ASP__PKill_template(*other_value.implication_.precondition);
implication_.implied_template = new ASP__PKill_template(*other_value.implication_.implied_template);
break;
case DYNAMIC_MATCH:
dyn_match = other_value.dyn_match;
dyn_match->ref_count++;
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PKill.");
break;
}
set_selection(other_value);
}

ASP__PKill_template::ASP__PKill_template()
{
}

ASP__PKill_template::ASP__PKill_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ASP__PKill_template::ASP__PKill_template(const ASP__PKill& other_value)
{
copy_value(other_value);
}

ASP__PKill_template::ASP__PKill_template(const OPTIONAL<ASP__PKill>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__PKill&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @PIPEasp_Types.ASP_PKill from an unbound optional field.");
}
}

ASP__PKill_template::ASP__PKill_template(ASP__PKill_template* p_precondition, ASP__PKill_template* p_implied_template)
 : Base_Template(IMPLICATION_MATCH)
{
implication_.precondition = p_precondition;
implication_.implied_template = p_implied_template;
}

ASP__PKill_template::ASP__PKill_template(Dynamic_Match_Interface<ASP__PKill>* p_dyn_match)
 : Base_Template(DYNAMIC_MATCH)
{
dyn_match = new dynmatch_struct<ASP__PKill>;
dyn_match->ptr = p_dyn_match;
dyn_match->ref_count = 1;
}

ASP__PKill_template::ASP__PKill_template(const ASP__PKill_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ASP__PKill_template::~ASP__PKill_template()
{
clean_up();
}

ASP__PKill_template& ASP__PKill_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ASP__PKill_template& ASP__PKill_template::operator=(const ASP__PKill& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ASP__PKill_template& ASP__PKill_template::operator=(const OPTIONAL<ASP__PKill>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__PKill&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @PIPEasp_Types.ASP_PKill.");
}
return *this;
}

ASP__PKill_template& ASP__PKill_template::operator=(const ASP__PKill_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ASP__PKill_template::match(const ASP__PKill& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.signal().is_bound()) return FALSE;
if(!single_value->field_signal.match(other_value.signal(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
case CONJUNCTION_MATCH:
for (unsigned int i = 0; i < value_list.n_values; i++) {
if (!value_list.list_value[i].match(other_value)) {
return FALSE;
}
}
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match(other_value) || implication_.implied_template->match(other_value);
case DYNAMIC_MATCH:
return dyn_match->ptr->match(other_value);
default:
TTCN_error("Matching an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PKill.");
}
return FALSE;
}

boolean ASP__PKill_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
return single_value->field_signal.is_bound();
}

boolean ASP__PKill_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value->field_signal.is_value();
}

void ASP__PKill_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
delete [] value_list.list_value;
break;
case IMPLICATION_MATCH:
delete implication_.precondition;
delete implication_.implied_template;
break;
case DYNAMIC_MATCH:
dyn_match->ref_count--;
if (dyn_match->ref_count == 0) {
delete dyn_match->ptr;
delete dyn_match;
}
break;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ASP__PKill ASP__PKill_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @PIPEasp_Types.ASP_PKill.");
ASP__PKill ret_val;
if (single_value->field_signal.is_bound()) {
ret_val.signal() = single_value->field_signal.valueof();
}
return ret_val;
}

void ASP__PKill_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST&& template_type != CONJUNCTION_MATCH)
TTCN_error("Setting an invalid list for a template of type @PIPEasp_Types.ASP_PKill.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ASP__PKill_template[list_length];
}

ASP__PKill_template& ASP__PKill_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST&& template_selection != CONJUNCTION_MATCH)
TTCN_error("Accessing a list element of a non-list template of type @PIPEasp_Types.ASP_PKill.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @PIPEasp_Types.ASP_PKill.");
return value_list.list_value[list_index];
}

INTEGER_template& ASP__PKill_template::signal()
{
set_specific();
return single_value->field_signal;
}

const INTEGER_template& ASP__PKill_template::signal() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field signal of a non-specific template of type @PIPEasp_Types.ASP_PKill.");
return single_value->field_signal;
}

int ASP__PKill_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PKill which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PKill containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PKill containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PKill containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PKill containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PKill containing complemented list.");
  case CONJUNCTION_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PKill containing a conjunction list match.");
  case IMPLICATION_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PKill containing an implication match.");
  case DYNAMIC_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PKill containing a dynamic match.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PKill.");
  }
  return 0;
}

void ASP__PKill_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ signal := ");
single_value->field_signal.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case CONJUNCTION_MATCH:
if (template_selection == CONJUNCTION_MATCH) {
TTCN_Logger::log_event_str("conjunct");
}
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
case IMPLICATION_MATCH:
implication_.precondition->log();
TTCN_Logger::log_event_str(" implies ");
implication_.implied_template->log();
break;
case DYNAMIC_MATCH:
TTCN_Logger::log_event_str("@dynamic template");
break;
default:
log_generic();
}
log_ifpresent();
}

void ASP__PKill_template::log_match(const ASP__PKill& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_signal.match(match_value.signal(), legacy)){
TTCN_Logger::log_logmatch_info(".signal");
single_value->field_signal.log_match(match_value.signal(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ signal := ");
single_value->field_signal.log_match(match_value.signal(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ASP__PKill_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_signal.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PKill.");
}
}

void ASP__PKill_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_signal.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ASP__PKill_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @PIPEasp_Types.ASP_PKill.");
}
}

void ASP__PKill_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
  case Module_Param::MP_ConjunctList_Template: {
    ASP__PKill_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : (param.get_type() == Module_Param::MP_ConjunctList_Template ? CONJUNCTION_MATCH : COMPLEMENTED_LIST), param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record template of type @PIPEasp_Types.ASP_PKill has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) signal().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "signal")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          signal().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PIPEasp_Types.ASP_PKill: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  case Module_Param::MP_Implication_Template: {
    ASP__PKill_template* precondition = new ASP__PKill_template;
    precondition->set_param(*param.get_elem(0));
    ASP__PKill_template* implied_template = new ASP__PKill_template;
    implied_template->set_param(*param.get_elem(1));
    *this = ASP__PKill_template(precondition, implied_template);
  } break;
  default:
    param.type_error("record template", "@PIPEasp_Types.ASP_PKill");
  }
  is_ifpresent = param.get_ifpresent();
}

void ASP__PKill_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_signal.check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_PKill");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@PIPEasp_Types.ASP_PKill");
}

boolean ASP__PKill_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ASP__PKill_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match_omit() || implication_.implied_template->match_omit();
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ASP__PExit::ASP__PExit()
{
}

ASP__PExit::ASP__PExit(const INTEGER& par_code)
  :   field_code(par_code)
{
}

ASP__PExit::ASP__PExit(const ASP__PExit& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @PIPEasp_Types.ASP_PExit.");
if (other_value.code().is_bound()) field_code = other_value.code();
else field_code.clean_up();
}

void ASP__PExit::clean_up()
{
field_code.clean_up();
}

const TTCN_Typedescriptor_t* ASP__PExit::get_descriptor() const { return &ASP__PExit_descr_; }
ASP__PExit& ASP__PExit::operator=(const ASP__PExit& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @PIPEasp_Types.ASP_PExit.");
  if (other_value.code().is_bound()) field_code = other_value.code();
  else field_code.clean_up();
}
return *this;
}

boolean ASP__PExit::operator==(const ASP__PExit& other_value) const
{
return field_code==other_value.field_code;
}

boolean ASP__PExit::is_bound() const
{
return (field_code.is_bound());
}
boolean ASP__PExit::is_value() const
{
return field_code.is_value();
}
void ASP__PExit::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ code := ");
field_code.log();
TTCN_Logger::log_event_str(" }");
}

void ASP__PExit::set_implicit_omit()
{
if (code().is_bound()) code().set_implicit_omit();
}

void ASP__PExit::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record value of type @PIPEasp_Types.ASP_PExit has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) code().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "code")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          code().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PIPEasp_Types.ASP_PExit: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@PIPEasp_Types.ASP_PExit");
  }
}

void ASP__PExit::encode_text(Text_Buf& text_buf) const
{
field_code.encode_text(text_buf);
}

void ASP__PExit::decode_text(Text_Buf& text_buf)
{
field_code.decode_text(text_buf);
}

struct ASP__PExit_template::single_value_struct {
INTEGER_template field_code;
};

void ASP__PExit_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_code = ANY_VALUE;
}
}
}

void ASP__PExit_template::copy_value(const ASP__PExit& other_value)
{
single_value = new single_value_struct;
if (other_value.code().is_bound()) {
  single_value->field_code = other_value.code();
} else {
  single_value->field_code.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ASP__PExit_template::copy_template(const ASP__PExit_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.code().get_selection()) {
single_value->field_code = other_value.code();
} else {
single_value->field_code.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ASP__PExit_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
case IMPLICATION_MATCH:
implication_.precondition = new ASP__PExit_template(*other_value.implication_.precondition);
implication_.implied_template = new ASP__PExit_template(*other_value.implication_.implied_template);
break;
case DYNAMIC_MATCH:
dyn_match = other_value.dyn_match;
dyn_match->ref_count++;
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PExit.");
break;
}
set_selection(other_value);
}

ASP__PExit_template::ASP__PExit_template()
{
}

ASP__PExit_template::ASP__PExit_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ASP__PExit_template::ASP__PExit_template(const ASP__PExit& other_value)
{
copy_value(other_value);
}

ASP__PExit_template::ASP__PExit_template(const OPTIONAL<ASP__PExit>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__PExit&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @PIPEasp_Types.ASP_PExit from an unbound optional field.");
}
}

ASP__PExit_template::ASP__PExit_template(ASP__PExit_template* p_precondition, ASP__PExit_template* p_implied_template)
 : Base_Template(IMPLICATION_MATCH)
{
implication_.precondition = p_precondition;
implication_.implied_template = p_implied_template;
}

ASP__PExit_template::ASP__PExit_template(Dynamic_Match_Interface<ASP__PExit>* p_dyn_match)
 : Base_Template(DYNAMIC_MATCH)
{
dyn_match = new dynmatch_struct<ASP__PExit>;
dyn_match->ptr = p_dyn_match;
dyn_match->ref_count = 1;
}

ASP__PExit_template::ASP__PExit_template(const ASP__PExit_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ASP__PExit_template::~ASP__PExit_template()
{
clean_up();
}

ASP__PExit_template& ASP__PExit_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ASP__PExit_template& ASP__PExit_template::operator=(const ASP__PExit& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ASP__PExit_template& ASP__PExit_template::operator=(const OPTIONAL<ASP__PExit>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__PExit&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @PIPEasp_Types.ASP_PExit.");
}
return *this;
}

ASP__PExit_template& ASP__PExit_template::operator=(const ASP__PExit_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ASP__PExit_template::match(const ASP__PExit& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.code().is_bound()) return FALSE;
if(!single_value->field_code.match(other_value.code(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
case CONJUNCTION_MATCH:
for (unsigned int i = 0; i < value_list.n_values; i++) {
if (!value_list.list_value[i].match(other_value)) {
return FALSE;
}
}
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match(other_value) || implication_.implied_template->match(other_value);
case DYNAMIC_MATCH:
return dyn_match->ptr->match(other_value);
default:
TTCN_error("Matching an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PExit.");
}
return FALSE;
}

boolean ASP__PExit_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
return single_value->field_code.is_bound();
}

boolean ASP__PExit_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value->field_code.is_value();
}

void ASP__PExit_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
delete [] value_list.list_value;
break;
case IMPLICATION_MATCH:
delete implication_.precondition;
delete implication_.implied_template;
break;
case DYNAMIC_MATCH:
dyn_match->ref_count--;
if (dyn_match->ref_count == 0) {
delete dyn_match->ptr;
delete dyn_match;
}
break;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ASP__PExit ASP__PExit_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @PIPEasp_Types.ASP_PExit.");
ASP__PExit ret_val;
if (single_value->field_code.is_bound()) {
ret_val.code() = single_value->field_code.valueof();
}
return ret_val;
}

void ASP__PExit_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST&& template_type != CONJUNCTION_MATCH)
TTCN_error("Setting an invalid list for a template of type @PIPEasp_Types.ASP_PExit.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ASP__PExit_template[list_length];
}

ASP__PExit_template& ASP__PExit_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST&& template_selection != CONJUNCTION_MATCH)
TTCN_error("Accessing a list element of a non-list template of type @PIPEasp_Types.ASP_PExit.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @PIPEasp_Types.ASP_PExit.");
return value_list.list_value[list_index];
}

INTEGER_template& ASP__PExit_template::code()
{
set_specific();
return single_value->field_code;
}

const INTEGER_template& ASP__PExit_template::code() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field code of a non-specific template of type @PIPEasp_Types.ASP_PExit.");
return single_value->field_code;
}

int ASP__PExit_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExit which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExit containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExit containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExit containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExit containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExit containing complemented list.");
  case CONJUNCTION_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExit containing a conjunction list match.");
  case IMPLICATION_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExit containing an implication match.");
  case DYNAMIC_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PExit containing a dynamic match.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PExit.");
  }
  return 0;
}

void ASP__PExit_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ code := ");
single_value->field_code.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case CONJUNCTION_MATCH:
if (template_selection == CONJUNCTION_MATCH) {
TTCN_Logger::log_event_str("conjunct");
}
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
case IMPLICATION_MATCH:
implication_.precondition->log();
TTCN_Logger::log_event_str(" implies ");
implication_.implied_template->log();
break;
case DYNAMIC_MATCH:
TTCN_Logger::log_event_str("@dynamic template");
break;
default:
log_generic();
}
log_ifpresent();
}

void ASP__PExit_template::log_match(const ASP__PExit& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_code.match(match_value.code(), legacy)){
TTCN_Logger::log_logmatch_info(".code");
single_value->field_code.log_match(match_value.code(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ code := ");
single_value->field_code.log_match(match_value.code(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ASP__PExit_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_code.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PExit.");
}
}

void ASP__PExit_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_code.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ASP__PExit_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @PIPEasp_Types.ASP_PExit.");
}
}

void ASP__PExit_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
  case Module_Param::MP_ConjunctList_Template: {
    ASP__PExit_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : (param.get_type() == Module_Param::MP_ConjunctList_Template ? CONJUNCTION_MATCH : COMPLEMENTED_LIST), param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record template of type @PIPEasp_Types.ASP_PExit has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) code().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "code")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          code().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PIPEasp_Types.ASP_PExit: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  case Module_Param::MP_Implication_Template: {
    ASP__PExit_template* precondition = new ASP__PExit_template;
    precondition->set_param(*param.get_elem(0));
    ASP__PExit_template* implied_template = new ASP__PExit_template;
    implied_template->set_param(*param.get_elem(1));
    *this = ASP__PExit_template(precondition, implied_template);
  } break;
  default:
    param.type_error("record template", "@PIPEasp_Types.ASP_PExit");
  }
  is_ifpresent = param.get_ifpresent();
}

void ASP__PExit_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_code.check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_PExit");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@PIPEasp_Types.ASP_PExit");
}

boolean ASP__PExit_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ASP__PExit_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match_omit() || implication_.implied_template->match_omit();
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ASP__PLineMode::ASP__PLineMode()
{
}

ASP__PLineMode::ASP__PLineMode(const BOOLEAN& par_lineMode)
  :   field_lineMode(par_lineMode)
{
}

ASP__PLineMode::ASP__PLineMode(const ASP__PLineMode& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @PIPEasp_Types.ASP_PLineMode.");
if (other_value.lineMode().is_bound()) field_lineMode = other_value.lineMode();
else field_lineMode.clean_up();
}

void ASP__PLineMode::clean_up()
{
field_lineMode.clean_up();
}

const TTCN_Typedescriptor_t* ASP__PLineMode::get_descriptor() const { return &ASP__PLineMode_descr_; }
ASP__PLineMode& ASP__PLineMode::operator=(const ASP__PLineMode& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @PIPEasp_Types.ASP_PLineMode.");
  if (other_value.lineMode().is_bound()) field_lineMode = other_value.lineMode();
  else field_lineMode.clean_up();
}
return *this;
}

boolean ASP__PLineMode::operator==(const ASP__PLineMode& other_value) const
{
return field_lineMode==other_value.field_lineMode;
}

boolean ASP__PLineMode::is_bound() const
{
return (field_lineMode.is_bound());
}
boolean ASP__PLineMode::is_value() const
{
return field_lineMode.is_value();
}
void ASP__PLineMode::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ lineMode := ");
field_lineMode.log();
TTCN_Logger::log_event_str(" }");
}

void ASP__PLineMode::set_implicit_omit()
{
if (lineMode().is_bound()) lineMode().set_implicit_omit();
}

void ASP__PLineMode::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record value of type @PIPEasp_Types.ASP_PLineMode has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) lineMode().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lineMode")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lineMode().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PIPEasp_Types.ASP_PLineMode: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@PIPEasp_Types.ASP_PLineMode");
  }
}

void ASP__PLineMode::encode_text(Text_Buf& text_buf) const
{
field_lineMode.encode_text(text_buf);
}

void ASP__PLineMode::decode_text(Text_Buf& text_buf)
{
field_lineMode.decode_text(text_buf);
}

struct ASP__PLineMode_template::single_value_struct {
BOOLEAN_template field_lineMode;
};

void ASP__PLineMode_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_lineMode = ANY_VALUE;
}
}
}

void ASP__PLineMode_template::copy_value(const ASP__PLineMode& other_value)
{
single_value = new single_value_struct;
if (other_value.lineMode().is_bound()) {
  single_value->field_lineMode = other_value.lineMode();
} else {
  single_value->field_lineMode.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ASP__PLineMode_template::copy_template(const ASP__PLineMode_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.lineMode().get_selection()) {
single_value->field_lineMode = other_value.lineMode();
} else {
single_value->field_lineMode.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ASP__PLineMode_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
case IMPLICATION_MATCH:
implication_.precondition = new ASP__PLineMode_template(*other_value.implication_.precondition);
implication_.implied_template = new ASP__PLineMode_template(*other_value.implication_.implied_template);
break;
case DYNAMIC_MATCH:
dyn_match = other_value.dyn_match;
dyn_match->ref_count++;
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PLineMode.");
break;
}
set_selection(other_value);
}

ASP__PLineMode_template::ASP__PLineMode_template()
{
}

ASP__PLineMode_template::ASP__PLineMode_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ASP__PLineMode_template::ASP__PLineMode_template(const ASP__PLineMode& other_value)
{
copy_value(other_value);
}

ASP__PLineMode_template::ASP__PLineMode_template(const OPTIONAL<ASP__PLineMode>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__PLineMode&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @PIPEasp_Types.ASP_PLineMode from an unbound optional field.");
}
}

ASP__PLineMode_template::ASP__PLineMode_template(ASP__PLineMode_template* p_precondition, ASP__PLineMode_template* p_implied_template)
 : Base_Template(IMPLICATION_MATCH)
{
implication_.precondition = p_precondition;
implication_.implied_template = p_implied_template;
}

ASP__PLineMode_template::ASP__PLineMode_template(Dynamic_Match_Interface<ASP__PLineMode>* p_dyn_match)
 : Base_Template(DYNAMIC_MATCH)
{
dyn_match = new dynmatch_struct<ASP__PLineMode>;
dyn_match->ptr = p_dyn_match;
dyn_match->ref_count = 1;
}

ASP__PLineMode_template::ASP__PLineMode_template(const ASP__PLineMode_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ASP__PLineMode_template::~ASP__PLineMode_template()
{
clean_up();
}

ASP__PLineMode_template& ASP__PLineMode_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ASP__PLineMode_template& ASP__PLineMode_template::operator=(const ASP__PLineMode& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ASP__PLineMode_template& ASP__PLineMode_template::operator=(const OPTIONAL<ASP__PLineMode>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__PLineMode&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @PIPEasp_Types.ASP_PLineMode.");
}
return *this;
}

ASP__PLineMode_template& ASP__PLineMode_template::operator=(const ASP__PLineMode_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ASP__PLineMode_template::match(const ASP__PLineMode& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.lineMode().is_bound()) return FALSE;
if(!single_value->field_lineMode.match(other_value.lineMode(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
case CONJUNCTION_MATCH:
for (unsigned int i = 0; i < value_list.n_values; i++) {
if (!value_list.list_value[i].match(other_value)) {
return FALSE;
}
}
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match(other_value) || implication_.implied_template->match(other_value);
case DYNAMIC_MATCH:
return dyn_match->ptr->match(other_value);
default:
TTCN_error("Matching an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PLineMode.");
}
return FALSE;
}

boolean ASP__PLineMode_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
return single_value->field_lineMode.is_bound();
}

boolean ASP__PLineMode_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value->field_lineMode.is_value();
}

void ASP__PLineMode_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
delete [] value_list.list_value;
break;
case IMPLICATION_MATCH:
delete implication_.precondition;
delete implication_.implied_template;
break;
case DYNAMIC_MATCH:
dyn_match->ref_count--;
if (dyn_match->ref_count == 0) {
delete dyn_match->ptr;
delete dyn_match;
}
break;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ASP__PLineMode ASP__PLineMode_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @PIPEasp_Types.ASP_PLineMode.");
ASP__PLineMode ret_val;
if (single_value->field_lineMode.is_bound()) {
ret_val.lineMode() = single_value->field_lineMode.valueof();
}
return ret_val;
}

void ASP__PLineMode_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST&& template_type != CONJUNCTION_MATCH)
TTCN_error("Setting an invalid list for a template of type @PIPEasp_Types.ASP_PLineMode.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ASP__PLineMode_template[list_length];
}

ASP__PLineMode_template& ASP__PLineMode_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST&& template_selection != CONJUNCTION_MATCH)
TTCN_error("Accessing a list element of a non-list template of type @PIPEasp_Types.ASP_PLineMode.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @PIPEasp_Types.ASP_PLineMode.");
return value_list.list_value[list_index];
}

BOOLEAN_template& ASP__PLineMode_template::lineMode()
{
set_specific();
return single_value->field_lineMode;
}

const BOOLEAN_template& ASP__PLineMode_template::lineMode() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field lineMode of a non-specific template of type @PIPEasp_Types.ASP_PLineMode.");
return single_value->field_lineMode;
}

int ASP__PLineMode_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PLineMode which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PLineMode containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PLineMode containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PLineMode containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PLineMode containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PLineMode containing complemented list.");
  case CONJUNCTION_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PLineMode containing a conjunction list match.");
  case IMPLICATION_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PLineMode containing an implication match.");
  case DYNAMIC_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PLineMode containing a dynamic match.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PLineMode.");
  }
  return 0;
}

void ASP__PLineMode_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ lineMode := ");
single_value->field_lineMode.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case CONJUNCTION_MATCH:
if (template_selection == CONJUNCTION_MATCH) {
TTCN_Logger::log_event_str("conjunct");
}
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
case IMPLICATION_MATCH:
implication_.precondition->log();
TTCN_Logger::log_event_str(" implies ");
implication_.implied_template->log();
break;
case DYNAMIC_MATCH:
TTCN_Logger::log_event_str("@dynamic template");
break;
default:
log_generic();
}
log_ifpresent();
}

void ASP__PLineMode_template::log_match(const ASP__PLineMode& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_lineMode.match(match_value.lineMode(), legacy)){
TTCN_Logger::log_logmatch_info(".lineMode");
single_value->field_lineMode.log_match(match_value.lineMode(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ lineMode := ");
single_value->field_lineMode.log_match(match_value.lineMode(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ASP__PLineMode_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_lineMode.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PLineMode.");
}
}

void ASP__PLineMode_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_lineMode.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ASP__PLineMode_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @PIPEasp_Types.ASP_PLineMode.");
}
}

void ASP__PLineMode_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
  case Module_Param::MP_ConjunctList_Template: {
    ASP__PLineMode_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : (param.get_type() == Module_Param::MP_ConjunctList_Template ? CONJUNCTION_MATCH : COMPLEMENTED_LIST), param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record template of type @PIPEasp_Types.ASP_PLineMode has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) lineMode().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lineMode")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lineMode().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PIPEasp_Types.ASP_PLineMode: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  case Module_Param::MP_Implication_Template: {
    ASP__PLineMode_template* precondition = new ASP__PLineMode_template;
    precondition->set_param(*param.get_elem(0));
    ASP__PLineMode_template* implied_template = new ASP__PLineMode_template;
    implied_template->set_param(*param.get_elem(1));
    *this = ASP__PLineMode_template(precondition, implied_template);
  } break;
  default:
    param.type_error("record template", "@PIPEasp_Types.ASP_PLineMode");
  }
  is_ifpresent = param.get_ifpresent();
}

void ASP__PLineMode_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_lineMode.check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_PLineMode");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@PIPEasp_Types.ASP_PLineMode");
}

boolean ASP__PLineMode_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ASP__PLineMode_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match_omit() || implication_.implied_template->match_omit();
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ASP__PError::ASP__PError()
{
}

ASP__PError::ASP__PError(const CHARSTRING& par_errorMessage)
  :   field_errorMessage(par_errorMessage)
{
}

ASP__PError::ASP__PError(const ASP__PError& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @PIPEasp_Types.ASP_PError.");
if (other_value.errorMessage().is_bound()) field_errorMessage = other_value.errorMessage();
else field_errorMessage.clean_up();
}

void ASP__PError::clean_up()
{
field_errorMessage.clean_up();
}

const TTCN_Typedescriptor_t* ASP__PError::get_descriptor() const { return &ASP__PError_descr_; }
ASP__PError& ASP__PError::operator=(const ASP__PError& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @PIPEasp_Types.ASP_PError.");
  if (other_value.errorMessage().is_bound()) field_errorMessage = other_value.errorMessage();
  else field_errorMessage.clean_up();
}
return *this;
}

boolean ASP__PError::operator==(const ASP__PError& other_value) const
{
return field_errorMessage==other_value.field_errorMessage;
}

boolean ASP__PError::is_bound() const
{
return (field_errorMessage.is_bound());
}
boolean ASP__PError::is_value() const
{
return field_errorMessage.is_value();
}
void ASP__PError::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ errorMessage := ");
field_errorMessage.log();
TTCN_Logger::log_event_str(" }");
}

void ASP__PError::set_implicit_omit()
{
if (errorMessage().is_bound()) errorMessage().set_implicit_omit();
}

void ASP__PError::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record value of type @PIPEasp_Types.ASP_PError has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) errorMessage().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "errorMessage")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          errorMessage().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PIPEasp_Types.ASP_PError: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@PIPEasp_Types.ASP_PError");
  }
}

void ASP__PError::encode_text(Text_Buf& text_buf) const
{
field_errorMessage.encode_text(text_buf);
}

void ASP__PError::decode_text(Text_Buf& text_buf)
{
field_errorMessage.decode_text(text_buf);
}

struct ASP__PError_template::single_value_struct {
CHARSTRING_template field_errorMessage;
};

void ASP__PError_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_errorMessage = ANY_VALUE;
}
}
}

void ASP__PError_template::copy_value(const ASP__PError& other_value)
{
single_value = new single_value_struct;
if (other_value.errorMessage().is_bound()) {
  single_value->field_errorMessage = other_value.errorMessage();
} else {
  single_value->field_errorMessage.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ASP__PError_template::copy_template(const ASP__PError_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.errorMessage().get_selection()) {
single_value->field_errorMessage = other_value.errorMessage();
} else {
single_value->field_errorMessage.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ASP__PError_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
case IMPLICATION_MATCH:
implication_.precondition = new ASP__PError_template(*other_value.implication_.precondition);
implication_.implied_template = new ASP__PError_template(*other_value.implication_.implied_template);
break;
case DYNAMIC_MATCH:
dyn_match = other_value.dyn_match;
dyn_match->ref_count++;
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PError.");
break;
}
set_selection(other_value);
}

ASP__PError_template::ASP__PError_template()
{
}

ASP__PError_template::ASP__PError_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ASP__PError_template::ASP__PError_template(const ASP__PError& other_value)
{
copy_value(other_value);
}

ASP__PError_template::ASP__PError_template(const OPTIONAL<ASP__PError>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__PError&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @PIPEasp_Types.ASP_PError from an unbound optional field.");
}
}

ASP__PError_template::ASP__PError_template(ASP__PError_template* p_precondition, ASP__PError_template* p_implied_template)
 : Base_Template(IMPLICATION_MATCH)
{
implication_.precondition = p_precondition;
implication_.implied_template = p_implied_template;
}

ASP__PError_template::ASP__PError_template(Dynamic_Match_Interface<ASP__PError>* p_dyn_match)
 : Base_Template(DYNAMIC_MATCH)
{
dyn_match = new dynmatch_struct<ASP__PError>;
dyn_match->ptr = p_dyn_match;
dyn_match->ref_count = 1;
}

ASP__PError_template::ASP__PError_template(const ASP__PError_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ASP__PError_template::~ASP__PError_template()
{
clean_up();
}

ASP__PError_template& ASP__PError_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ASP__PError_template& ASP__PError_template::operator=(const ASP__PError& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ASP__PError_template& ASP__PError_template::operator=(const OPTIONAL<ASP__PError>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__PError&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @PIPEasp_Types.ASP_PError.");
}
return *this;
}

ASP__PError_template& ASP__PError_template::operator=(const ASP__PError_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ASP__PError_template::match(const ASP__PError& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.errorMessage().is_bound()) return FALSE;
if(!single_value->field_errorMessage.match(other_value.errorMessage(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
case CONJUNCTION_MATCH:
for (unsigned int i = 0; i < value_list.n_values; i++) {
if (!value_list.list_value[i].match(other_value)) {
return FALSE;
}
}
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match(other_value) || implication_.implied_template->match(other_value);
case DYNAMIC_MATCH:
return dyn_match->ptr->match(other_value);
default:
TTCN_error("Matching an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PError.");
}
return FALSE;
}

boolean ASP__PError_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
return single_value->field_errorMessage.is_bound();
}

boolean ASP__PError_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value->field_errorMessage.is_value();
}

void ASP__PError_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
delete [] value_list.list_value;
break;
case IMPLICATION_MATCH:
delete implication_.precondition;
delete implication_.implied_template;
break;
case DYNAMIC_MATCH:
dyn_match->ref_count--;
if (dyn_match->ref_count == 0) {
delete dyn_match->ptr;
delete dyn_match;
}
break;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ASP__PError ASP__PError_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @PIPEasp_Types.ASP_PError.");
ASP__PError ret_val;
if (single_value->field_errorMessage.is_bound()) {
ret_val.errorMessage() = single_value->field_errorMessage.valueof();
}
return ret_val;
}

void ASP__PError_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST&& template_type != CONJUNCTION_MATCH)
TTCN_error("Setting an invalid list for a template of type @PIPEasp_Types.ASP_PError.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ASP__PError_template[list_length];
}

ASP__PError_template& ASP__PError_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST&& template_selection != CONJUNCTION_MATCH)
TTCN_error("Accessing a list element of a non-list template of type @PIPEasp_Types.ASP_PError.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @PIPEasp_Types.ASP_PError.");
return value_list.list_value[list_index];
}

CHARSTRING_template& ASP__PError_template::errorMessage()
{
set_specific();
return single_value->field_errorMessage;
}

const CHARSTRING_template& ASP__PError_template::errorMessage() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field errorMessage of a non-specific template of type @PIPEasp_Types.ASP_PError.");
return single_value->field_errorMessage;
}

int ASP__PError_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PError which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PError containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PError containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PError containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PError containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PError containing complemented list.");
  case CONJUNCTION_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PError containing a conjunction list match.");
  case IMPLICATION_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PError containing an implication match.");
  case DYNAMIC_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_PError containing a dynamic match.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PError.");
  }
  return 0;
}

void ASP__PError_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ errorMessage := ");
single_value->field_errorMessage.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case CONJUNCTION_MATCH:
if (template_selection == CONJUNCTION_MATCH) {
TTCN_Logger::log_event_str("conjunct");
}
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
case IMPLICATION_MATCH:
implication_.precondition->log();
TTCN_Logger::log_event_str(" implies ");
implication_.implied_template->log();
break;
case DYNAMIC_MATCH:
TTCN_Logger::log_event_str("@dynamic template");
break;
default:
log_generic();
}
log_ifpresent();
}

void ASP__PError_template::log_match(const ASP__PError& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_errorMessage.match(match_value.errorMessage(), legacy)){
TTCN_Logger::log_logmatch_info(".errorMessage");
single_value->field_errorMessage.log_match(match_value.errorMessage(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ errorMessage := ");
single_value->field_errorMessage.log_match(match_value.errorMessage(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ASP__PError_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_errorMessage.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PError.");
}
}

void ASP__PError_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_errorMessage.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ASP__PError_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @PIPEasp_Types.ASP_PError.");
}
}

void ASP__PError_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
  case Module_Param::MP_ConjunctList_Template: {
    ASP__PError_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : (param.get_type() == Module_Param::MP_ConjunctList_Template ? CONJUNCTION_MATCH : COMPLEMENTED_LIST), param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record template of type @PIPEasp_Types.ASP_PError has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) errorMessage().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "errorMessage")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          errorMessage().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PIPEasp_Types.ASP_PError: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  case Module_Param::MP_Implication_Template: {
    ASP__PError_template* precondition = new ASP__PError_template;
    precondition->set_param(*param.get_elem(0));
    ASP__PError_template* implied_template = new ASP__PError_template;
    implied_template->set_param(*param.get_elem(1));
    *this = ASP__PError_template(precondition, implied_template);
  } break;
  default:
    param.type_error("record template", "@PIPEasp_Types.ASP_PError");
  }
  is_ifpresent = param.get_ifpresent();
}

void ASP__PError_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_errorMessage.check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_PError");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@PIPEasp_Types.ASP_PError");
}

boolean ASP__PError_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ASP__PError_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match_omit() || implication_.implied_template->match_omit();
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ASP__PEndOfInput::ASP__PEndOfInput()
{
bound_flag = FALSE;
}

ASP__PEndOfInput::ASP__PEndOfInput(null_type)
{
bound_flag = TRUE;
}

ASP__PEndOfInput::ASP__PEndOfInput(const ASP__PEndOfInput& other_value)
{
other_value.must_bound("Copying an unbound value of type @PIPEasp_Types.ASP_PEndOfInput.");
bound_flag = TRUE;
}

ASP__PEndOfInput& ASP__PEndOfInput::operator=(null_type)
{
bound_flag = TRUE;
return *this;
}

ASP__PEndOfInput& ASP__PEndOfInput::operator=(const ASP__PEndOfInput& other_value)
{
other_value.must_bound("Assignment of an unbound value of type @PIPEasp_Types.ASP_PEndOfInput.");
bound_flag = TRUE;
return *this;
}

boolean ASP__PEndOfInput::operator==(null_type) const
{
must_bound("Comparison of an unbound value of type @PIPEasp_Types.ASP_PEndOfInput.");
return TRUE;
}

boolean ASP__PEndOfInput::operator==(const ASP__PEndOfInput& other_value) const
{
must_bound("Comparison of an unbound value of type @PIPEasp_Types.ASP_PEndOfInput.");
other_value.must_bound("Comparison of an unbound value of type @PIPEasp_Types.ASP_PEndOfInput.");
return TRUE;
}

void ASP__PEndOfInput::log() const
{
if (bound_flag) TTCN_Logger::log_event_str("{ }");
else TTCN_Logger::log_event_unbound();
}

void ASP__PEndOfInput::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "empty record/set value (i.e. { })");
  if (param.get_type()!=Module_Param::MP_Value_List || param.get_size()>0) {
    param.type_error("empty record/set value (i.e. { })", "@PIPEasp_Types.ASP_PEndOfInput");
  }
  bound_flag = TRUE;
}

void ASP__PEndOfInput::encode_text(Text_Buf& /*text_buf*/) const
{
must_bound("Text encoder: Encoding an unbound value of type @PIPEasp_Types.ASP_PEndOfInput.");
}

void ASP__PEndOfInput::decode_text(Text_Buf& /*text_buf*/)
{
bound_flag = TRUE;
}

void ASP__PEndOfInput_template::copy_template(const ASP__PEndOfInput_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ASP__PEndOfInput_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
case IMPLICATION_MATCH:
implication_.precondition = new ASP__PEndOfInput_template(*other_value.implication_.precondition);
implication_.implied_template = new ASP__PEndOfInput_template(*other_value.implication_.implied_template);
break;
case DYNAMIC_MATCH:
dyn_match = other_value.dyn_match;
dyn_match->ref_count++;
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PEndOfInput.");
break;
}
}

ASP__PEndOfInput_template::ASP__PEndOfInput_template()
{
}

ASP__PEndOfInput_template::ASP__PEndOfInput_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ASP__PEndOfInput_template::ASP__PEndOfInput_template(null_type)
 : Base_Template(SPECIFIC_VALUE)
{
}

ASP__PEndOfInput_template::ASP__PEndOfInput_template(const ASP__PEndOfInput& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
other_value.must_bound("Creating a template from an unbound value of type @PIPEasp_Types.ASP_PEndOfInput.");
}

ASP__PEndOfInput_template::ASP__PEndOfInput_template(const OPTIONAL<ASP__PEndOfInput>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @PIPEasp_Types.ASP_PEndOfInput from an unbound optional field.");
}
}

ASP__PEndOfInput_template::ASP__PEndOfInput_template(ASP__PEndOfInput_template* p_precondition, ASP__PEndOfInput_template* p_implied_template)
 : Base_Template(IMPLICATION_MATCH)
{
implication_.precondition = p_precondition;
implication_.implied_template = p_implied_template;
}

ASP__PEndOfInput_template::ASP__PEndOfInput_template(Dynamic_Match_Interface<ASP__PEndOfInput>* p_dyn_match)
 : Base_Template(DYNAMIC_MATCH)
{
dyn_match = new dynmatch_struct<ASP__PEndOfInput>;
dyn_match->ptr = p_dyn_match;
dyn_match->ref_count = 1;
}

ASP__PEndOfInput_template::ASP__PEndOfInput_template(const ASP__PEndOfInput_template& other_value)
: Base_Template(){
copy_template(other_value);
}

ASP__PEndOfInput_template::~ASP__PEndOfInput_template()
{
clean_up();
}

void ASP__PEndOfInput_template::clean_up()
{
switch (template_selection) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
delete [] value_list.list_value;
break;
case IMPLICATION_MATCH:
delete implication_.precondition;
delete implication_.implied_template;
break;
case DYNAMIC_MATCH:
dyn_match->ref_count--;
if (dyn_match->ref_count == 0) {
delete dyn_match->ptr;
delete dyn_match;
}
break;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ASP__PEndOfInput_template& ASP__PEndOfInput_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ASP__PEndOfInput_template& ASP__PEndOfInput_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
return *this;
}

ASP__PEndOfInput_template& ASP__PEndOfInput_template::operator=(const ASP__PEndOfInput& other_value)
{
other_value.must_bound("Assignment of an unbound value of type @PIPEasp_Types.ASP_PEndOfInput to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
return *this;
}

ASP__PEndOfInput_template& ASP__PEndOfInput_template::operator=(const OPTIONAL<ASP__PEndOfInput>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @PIPEasp_Types.ASP_PEndOfInput.");
}
return *this;
}

ASP__PEndOfInput_template& ASP__PEndOfInput_template::operator=(const ASP__PEndOfInput_template& other_value)
{
if (&other_value != this) {
clean_up();
set_selection(other_value);
}
return *this;
}

boolean ASP__PEndOfInput_template::match(null_type other_value,boolean) const
{
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
return TRUE;
case OMIT_VALUE:
return FALSE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
case CONJUNCTION_MATCH:
for (unsigned int i = 0; i < value_list.n_values; i++) {
if (!value_list.list_value[i].match(other_value)) {
return FALSE;
}
}
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match(other_value) || implication_.implied_template->match(other_value);
case DYNAMIC_MATCH:
return dyn_match->ptr->match(other_value);
default:
TTCN_error("Matching an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PEndOfInput.");
}
return FALSE;
}

boolean ASP__PEndOfInput_template::match(const ASP__PEndOfInput& other_value, boolean) const
{
if (!other_value.is_bound()) return FALSE;
return match(NULL_VALUE);
}

ASP__PEndOfInput ASP__PEndOfInput_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @PIPEasp_Types.ASP_PEndOfInput.");
return NULL_VALUE;
}

void ASP__PEndOfInput_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST&& template_type != CONJUNCTION_MATCH)
TTCN_error("Setting an invalid list for a template of type @PIPEasp_Types.ASP_PEndOfInput.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ASP__PEndOfInput_template[list_length];
}

ASP__PEndOfInput_template& ASP__PEndOfInput_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST&& template_selection != CONJUNCTION_MATCH)
TTCN_error("Accessing a list element of a non-list template of type @PIPEasp_Types.ASP_PEndOfInput.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @PIPEasp_Types.ASP_PEndOfInput.");
return value_list.list_value[list_index];
}

void ASP__PEndOfInput_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case CONJUNCTION_MATCH:
if (template_selection == CONJUNCTION_MATCH) {
TTCN_Logger::log_event_str("conjunct");
}
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
case IMPLICATION_MATCH:
implication_.precondition->log();
TTCN_Logger::log_event_str(" implies ");
implication_.implied_template->log();
break;
case DYNAMIC_MATCH:
TTCN_Logger::log_event_str("@dynamic template");
break;
default:
log_generic();
}
log_ifpresent();
}

void ASP__PEndOfInput_template::log_match(const ASP__PEndOfInput& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void ASP__PEndOfInput_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @PIPEasp_Types.ASP_PEndOfInput.");
}
}

void ASP__PEndOfInput_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ASP__PEndOfInput_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @PIPEasp_Types.ASP_PEndOfInput.");
}
}

void ASP__PEndOfInput_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "empty record/set template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
  case Module_Param::MP_ConjunctList_Template: {
    ASP__PEndOfInput_template temp;
    temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : (param.get_type() == Module_Param::MP_ConjunctList_Template ? CONJUNCTION_MATCH : COMPLEMENTED_LIST), param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (param.get_size()>0) param.type_error("empty record/set template", "@PIPEasp_Types.ASP_PEndOfInput");
    *this = NULL_VALUE;
    break;
  case Module_Param::MP_Implication_Template: {
    ASP__PEndOfInput_template* precondition = new ASP__PEndOfInput_template;
    precondition->set_param(*param.get_elem(0));
    ASP__PEndOfInput_template* implied_template = new ASP__PEndOfInput_template;
    implied_template->set_param(*param.get_elem(1));
    *this = ASP__PEndOfInput_template(precondition, implied_template);
  } break;
  default:
    param.type_error("empty record/set template", "@PIPEasp_Types.ASP_PEndOfInput");
  }
  is_ifpresent = param.get_ifpresent();
}

void ASP__PEndOfInput_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@PIPEasp_Types.ASP_PEndOfInput");
}

boolean ASP__PEndOfInput_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ASP__PEndOfInput_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match_omit() || implication_.implied_template->match_omit();
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void ASP__Commands::copy_value(const ASP__Commands& other_value)
{
switch (other_value.union_selection) {
case ALT_pexecute:
field_pexecute = new ASP__PExecute(*other_value.field_pexecute);
break;
case ALT_pexecutePty:
field_pexecutePty = new ASP__PExecutePty(*other_value.field_pexecutePty);
break;
case ALT_pexecuteBinary:
field_pexecuteBinary = new ASP__PExecuteBinary(*other_value.field_pexecuteBinary);
break;
case ALT_pexecuteBinaryPty:
field_pexecuteBinaryPty = new ASP__PExecuteBinaryPty(*other_value.field_pexecuteBinaryPty);
break;
case ALT_pexecuteBackground:
field_pexecuteBackground = new ASP__PExecuteBackground(*other_value.field_pexecuteBackground);
break;
case ALT_pexecuteBackgroundPty:
field_pexecuteBackgroundPty = new ASP__PExecuteBackgroundPty(*other_value.field_pexecuteBackgroundPty);
break;
case ALT_pStdin:
field_pStdin = new ASP__PStdin(*other_value.field_pStdin);
break;
case ALT_pStdinBinary:
field_pStdinBinary = new ASP__PStdinBinary(*other_value.field_pStdinBinary);
break;
case ALT_pKill:
field_pKill = new ASP__PKill(*other_value.field_pKill);
break;
case ALT_pEndOfInput:
field_pEndOfInput = new ASP__PEndOfInput(*other_value.field_pEndOfInput);
break;
default:
TTCN_error("Assignment of an unbound union value of type @PIPEasp_Types.ASP_Commands.");
}
union_selection = other_value.union_selection;
}

ASP__Commands::ASP__Commands()
{
union_selection = UNBOUND_VALUE;
}

ASP__Commands::ASP__Commands(const ASP__Commands& other_value)
: Base_Type(){
copy_value(other_value);
}

ASP__Commands::~ASP__Commands()
{
clean_up();
}

ASP__Commands& ASP__Commands::operator=(const ASP__Commands& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean ASP__Commands::operator==(const ASP__Commands& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @PIPEasp_Types.ASP_Commands.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @PIPEasp_Types.ASP_Commands.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_pexecute:
return *field_pexecute == *other_value.field_pexecute;
case ALT_pexecutePty:
return *field_pexecutePty == *other_value.field_pexecutePty;
case ALT_pexecuteBinary:
return *field_pexecuteBinary == *other_value.field_pexecuteBinary;
case ALT_pexecuteBinaryPty:
return *field_pexecuteBinaryPty == *other_value.field_pexecuteBinaryPty;
case ALT_pexecuteBackground:
return *field_pexecuteBackground == *other_value.field_pexecuteBackground;
case ALT_pexecuteBackgroundPty:
return *field_pexecuteBackgroundPty == *other_value.field_pexecuteBackgroundPty;
case ALT_pStdin:
return *field_pStdin == *other_value.field_pStdin;
case ALT_pStdinBinary:
return *field_pStdinBinary == *other_value.field_pStdinBinary;
case ALT_pKill:
return *field_pKill == *other_value.field_pKill;
case ALT_pEndOfInput:
return *field_pEndOfInput == *other_value.field_pEndOfInput;
default:
return FALSE;
}
}

ASP__PExecute& ASP__Commands::pexecute()
{
if (union_selection != ALT_pexecute) {
clean_up();
field_pexecute = new ASP__PExecute;
union_selection = ALT_pexecute;
}
return *field_pexecute;
}

const ASP__PExecute& ASP__Commands::pexecute() const
{
if (union_selection != ALT_pexecute) TTCN_error("Using non-selected field pexecute in a value of union type @PIPEasp_Types.ASP_Commands.");
return *field_pexecute;
}

ASP__PExecutePty& ASP__Commands::pexecutePty()
{
if (union_selection != ALT_pexecutePty) {
clean_up();
field_pexecutePty = new ASP__PExecutePty;
union_selection = ALT_pexecutePty;
}
return *field_pexecutePty;
}

const ASP__PExecutePty& ASP__Commands::pexecutePty() const
{
if (union_selection != ALT_pexecutePty) TTCN_error("Using non-selected field pexecutePty in a value of union type @PIPEasp_Types.ASP_Commands.");
return *field_pexecutePty;
}

ASP__PExecuteBinary& ASP__Commands::pexecuteBinary()
{
if (union_selection != ALT_pexecuteBinary) {
clean_up();
field_pexecuteBinary = new ASP__PExecuteBinary;
union_selection = ALT_pexecuteBinary;
}
return *field_pexecuteBinary;
}

const ASP__PExecuteBinary& ASP__Commands::pexecuteBinary() const
{
if (union_selection != ALT_pexecuteBinary) TTCN_error("Using non-selected field pexecuteBinary in a value of union type @PIPEasp_Types.ASP_Commands.");
return *field_pexecuteBinary;
}

ASP__PExecuteBinaryPty& ASP__Commands::pexecuteBinaryPty()
{
if (union_selection != ALT_pexecuteBinaryPty) {
clean_up();
field_pexecuteBinaryPty = new ASP__PExecuteBinaryPty;
union_selection = ALT_pexecuteBinaryPty;
}
return *field_pexecuteBinaryPty;
}

const ASP__PExecuteBinaryPty& ASP__Commands::pexecuteBinaryPty() const
{
if (union_selection != ALT_pexecuteBinaryPty) TTCN_error("Using non-selected field pexecuteBinaryPty in a value of union type @PIPEasp_Types.ASP_Commands.");
return *field_pexecuteBinaryPty;
}

ASP__PExecuteBackground& ASP__Commands::pexecuteBackground()
{
if (union_selection != ALT_pexecuteBackground) {
clean_up();
field_pexecuteBackground = new ASP__PExecuteBackground;
union_selection = ALT_pexecuteBackground;
}
return *field_pexecuteBackground;
}

const ASP__PExecuteBackground& ASP__Commands::pexecuteBackground() const
{
if (union_selection != ALT_pexecuteBackground) TTCN_error("Using non-selected field pexecuteBackground in a value of union type @PIPEasp_Types.ASP_Commands.");
return *field_pexecuteBackground;
}

ASP__PExecuteBackgroundPty& ASP__Commands::pexecuteBackgroundPty()
{
if (union_selection != ALT_pexecuteBackgroundPty) {
clean_up();
field_pexecuteBackgroundPty = new ASP__PExecuteBackgroundPty;
union_selection = ALT_pexecuteBackgroundPty;
}
return *field_pexecuteBackgroundPty;
}

const ASP__PExecuteBackgroundPty& ASP__Commands::pexecuteBackgroundPty() const
{
if (union_selection != ALT_pexecuteBackgroundPty) TTCN_error("Using non-selected field pexecuteBackgroundPty in a value of union type @PIPEasp_Types.ASP_Commands.");
return *field_pexecuteBackgroundPty;
}

ASP__PStdin& ASP__Commands::pStdin()
{
if (union_selection != ALT_pStdin) {
clean_up();
field_pStdin = new ASP__PStdin;
union_selection = ALT_pStdin;
}
return *field_pStdin;
}

const ASP__PStdin& ASP__Commands::pStdin() const
{
if (union_selection != ALT_pStdin) TTCN_error("Using non-selected field pStdin in a value of union type @PIPEasp_Types.ASP_Commands.");
return *field_pStdin;
}

ASP__PStdinBinary& ASP__Commands::pStdinBinary()
{
if (union_selection != ALT_pStdinBinary) {
clean_up();
field_pStdinBinary = new ASP__PStdinBinary;
union_selection = ALT_pStdinBinary;
}
return *field_pStdinBinary;
}

const ASP__PStdinBinary& ASP__Commands::pStdinBinary() const
{
if (union_selection != ALT_pStdinBinary) TTCN_error("Using non-selected field pStdinBinary in a value of union type @PIPEasp_Types.ASP_Commands.");
return *field_pStdinBinary;
}

ASP__PKill& ASP__Commands::pKill()
{
if (union_selection != ALT_pKill) {
clean_up();
field_pKill = new ASP__PKill;
union_selection = ALT_pKill;
}
return *field_pKill;
}

const ASP__PKill& ASP__Commands::pKill() const
{
if (union_selection != ALT_pKill) TTCN_error("Using non-selected field pKill in a value of union type @PIPEasp_Types.ASP_Commands.");
return *field_pKill;
}

ASP__PEndOfInput& ASP__Commands::pEndOfInput()
{
if (union_selection != ALT_pEndOfInput) {
clean_up();
field_pEndOfInput = new ASP__PEndOfInput;
union_selection = ALT_pEndOfInput;
}
return *field_pEndOfInput;
}

const ASP__PEndOfInput& ASP__Commands::pEndOfInput() const
{
if (union_selection != ALT_pEndOfInput) TTCN_error("Using non-selected field pEndOfInput in a value of union type @PIPEasp_Types.ASP_Commands.");
return *field_pEndOfInput;
}

boolean ASP__Commands::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @PIPEasp_Types.ASP_Commands.");
return union_selection == checked_selection;
}

boolean ASP__Commands::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean ASP__Commands::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_pexecute: return field_pexecute->is_value();
case ALT_pexecutePty: return field_pexecutePty->is_value();
case ALT_pexecuteBinary: return field_pexecuteBinary->is_value();
case ALT_pexecuteBinaryPty: return field_pexecuteBinaryPty->is_value();
case ALT_pexecuteBackground: return field_pexecuteBackground->is_value();
case ALT_pexecuteBackgroundPty: return field_pexecuteBackgroundPty->is_value();
case ALT_pStdin: return field_pStdin->is_value();
case ALT_pStdinBinary: return field_pStdinBinary->is_value();
case ALT_pKill: return field_pKill->is_value();
case ALT_pEndOfInput: return field_pEndOfInput->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void ASP__Commands::clean_up()
{
switch (union_selection) {
case ALT_pexecute:
  delete field_pexecute;
  break;
case ALT_pexecutePty:
  delete field_pexecutePty;
  break;
case ALT_pexecuteBinary:
  delete field_pexecuteBinary;
  break;
case ALT_pexecuteBinaryPty:
  delete field_pexecuteBinaryPty;
  break;
case ALT_pexecuteBackground:
  delete field_pexecuteBackground;
  break;
case ALT_pexecuteBackgroundPty:
  delete field_pexecuteBackgroundPty;
  break;
case ALT_pStdin:
  delete field_pStdin;
  break;
case ALT_pStdinBinary:
  delete field_pStdinBinary;
  break;
case ALT_pKill:
  delete field_pKill;
  break;
case ALT_pEndOfInput:
  delete field_pEndOfInput;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void ASP__Commands::log() const
{
switch (union_selection) {
case ALT_pexecute:
TTCN_Logger::log_event_str("{ pexecute := ");
field_pexecute->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_pexecutePty:
TTCN_Logger::log_event_str("{ pexecutePty := ");
field_pexecutePty->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_pexecuteBinary:
TTCN_Logger::log_event_str("{ pexecuteBinary := ");
field_pexecuteBinary->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_pexecuteBinaryPty:
TTCN_Logger::log_event_str("{ pexecuteBinaryPty := ");
field_pexecuteBinaryPty->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_pexecuteBackground:
TTCN_Logger::log_event_str("{ pexecuteBackground := ");
field_pexecuteBackground->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_pexecuteBackgroundPty:
TTCN_Logger::log_event_str("{ pexecuteBackgroundPty := ");
field_pexecuteBackgroundPty->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_pStdin:
TTCN_Logger::log_event_str("{ pStdin := ");
field_pStdin->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_pStdinBinary:
TTCN_Logger::log_event_str("{ pStdinBinary := ");
field_pStdinBinary->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_pKill:
TTCN_Logger::log_event_str("{ pKill := ");
field_pKill->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_pEndOfInput:
TTCN_Logger::log_event_str("{ pEndOfInput := ");
field_pEndOfInput->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void ASP__Commands::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr m_p = &param;
  if (m_p->get_type()==Module_Param::MP_Value_List && m_p->get_size()==0) return;
  if (m_p->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = m_p->get_elem(m_p->get_size()-1);
  char* last_name = mp_last->get_id()->get_name();
  if (!strcmp(last_name, "pexecute")) {
    pexecute().set_param(*mp_last);
    if (!pexecute().is_bound()) clean_up();
    return;
  }
  if (!strcmp(last_name, "pexecutePty")) {
    pexecutePty().set_param(*mp_last);
    if (!pexecutePty().is_bound()) clean_up();
    return;
  }
  if (!strcmp(last_name, "pexecuteBinary")) {
    pexecuteBinary().set_param(*mp_last);
    if (!pexecuteBinary().is_bound()) clean_up();
    return;
  }
  if (!strcmp(last_name, "pexecuteBinaryPty")) {
    pexecuteBinaryPty().set_param(*mp_last);
    if (!pexecuteBinaryPty().is_bound()) clean_up();
    return;
  }
  if (!strcmp(last_name, "pexecuteBackground")) {
    pexecuteBackground().set_param(*mp_last);
    if (!pexecuteBackground().is_bound()) clean_up();
    return;
  }
  if (!strcmp(last_name, "pexecuteBackgroundPty")) {
    pexecuteBackgroundPty().set_param(*mp_last);
    if (!pexecuteBackgroundPty().is_bound()) clean_up();
    return;
  }
  if (!strcmp(last_name, "pStdin")) {
    pStdin().set_param(*mp_last);
    if (!pStdin().is_bound()) clean_up();
    return;
  }
  if (!strcmp(last_name, "pStdinBinary")) {
    pStdinBinary().set_param(*mp_last);
    if (!pStdinBinary().is_bound()) clean_up();
    return;
  }
  if (!strcmp(last_name, "pKill")) {
    pKill().set_param(*mp_last);
    if (!pKill().is_bound()) clean_up();
    return;
  }
  if (!strcmp(last_name, "pEndOfInput")) {
    pEndOfInput().set_param(*mp_last);
    if (!pEndOfInput().is_bound()) clean_up();
    return;
  }
  mp_last->error("Field %s does not exist in type @PIPEasp_Types.ASP_Commands.", last_name);
}

void ASP__Commands::set_implicit_omit()
{
switch (union_selection) {
case ALT_pexecute:
field_pexecute->set_implicit_omit(); break;
case ALT_pexecutePty:
field_pexecutePty->set_implicit_omit(); break;
case ALT_pexecuteBinary:
field_pexecuteBinary->set_implicit_omit(); break;
case ALT_pexecuteBinaryPty:
field_pexecuteBinaryPty->set_implicit_omit(); break;
case ALT_pexecuteBackground:
field_pexecuteBackground->set_implicit_omit(); break;
case ALT_pexecuteBackgroundPty:
field_pexecuteBackgroundPty->set_implicit_omit(); break;
case ALT_pStdin:
field_pStdin->set_implicit_omit(); break;
case ALT_pStdinBinary:
field_pStdinBinary->set_implicit_omit(); break;
case ALT_pKill:
field_pKill->set_implicit_omit(); break;
case ALT_pEndOfInput:
field_pEndOfInput->set_implicit_omit(); break;
default: break;
}
}

void ASP__Commands::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_pexecute:
field_pexecute->encode_text(text_buf);
break;
case ALT_pexecutePty:
field_pexecutePty->encode_text(text_buf);
break;
case ALT_pexecuteBinary:
field_pexecuteBinary->encode_text(text_buf);
break;
case ALT_pexecuteBinaryPty:
field_pexecuteBinaryPty->encode_text(text_buf);
break;
case ALT_pexecuteBackground:
field_pexecuteBackground->encode_text(text_buf);
break;
case ALT_pexecuteBackgroundPty:
field_pexecuteBackgroundPty->encode_text(text_buf);
break;
case ALT_pStdin:
field_pStdin->encode_text(text_buf);
break;
case ALT_pStdinBinary:
field_pStdinBinary->encode_text(text_buf);
break;
case ALT_pKill:
field_pKill->encode_text(text_buf);
break;
case ALT_pEndOfInput:
field_pEndOfInput->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @PIPEasp_Types.ASP_Commands.");
}
}

void ASP__Commands::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_pexecute:
pexecute().decode_text(text_buf);
break;
case ALT_pexecutePty:
pexecutePty().decode_text(text_buf);
break;
case ALT_pexecuteBinary:
pexecuteBinary().decode_text(text_buf);
break;
case ALT_pexecuteBinaryPty:
pexecuteBinaryPty().decode_text(text_buf);
break;
case ALT_pexecuteBackground:
pexecuteBackground().decode_text(text_buf);
break;
case ALT_pexecuteBackgroundPty:
pexecuteBackgroundPty().decode_text(text_buf);
break;
case ALT_pStdin:
pStdin().decode_text(text_buf);
break;
case ALT_pStdinBinary:
pStdinBinary().decode_text(text_buf);
break;
case ALT_pKill:
pKill().decode_text(text_buf);
break;
case ALT_pEndOfInput:
pEndOfInput().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @PIPEasp_Types.ASP_Commands.");
}
}

void ASP__Commands_template::copy_value(const ASP__Commands& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case ASP__Commands::ALT_pexecute:
single_value.field_pexecute = new ASP__PExecute_template(other_value.pexecute());
break;
case ASP__Commands::ALT_pexecutePty:
single_value.field_pexecutePty = new ASP__PExecutePty_template(other_value.pexecutePty());
break;
case ASP__Commands::ALT_pexecuteBinary:
single_value.field_pexecuteBinary = new ASP__PExecuteBinary_template(other_value.pexecuteBinary());
break;
case ASP__Commands::ALT_pexecuteBinaryPty:
single_value.field_pexecuteBinaryPty = new ASP__PExecuteBinaryPty_template(other_value.pexecuteBinaryPty());
break;
case ASP__Commands::ALT_pexecuteBackground:
single_value.field_pexecuteBackground = new ASP__PExecuteBackground_template(other_value.pexecuteBackground());
break;
case ASP__Commands::ALT_pexecuteBackgroundPty:
single_value.field_pexecuteBackgroundPty = new ASP__PExecuteBackgroundPty_template(other_value.pexecuteBackgroundPty());
break;
case ASP__Commands::ALT_pStdin:
single_value.field_pStdin = new ASP__PStdin_template(other_value.pStdin());
break;
case ASP__Commands::ALT_pStdinBinary:
single_value.field_pStdinBinary = new ASP__PStdinBinary_template(other_value.pStdinBinary());
break;
case ASP__Commands::ALT_pKill:
single_value.field_pKill = new ASP__PKill_template(other_value.pKill());
break;
case ASP__Commands::ALT_pEndOfInput:
single_value.field_pEndOfInput = new ASP__PEndOfInput_template(other_value.pEndOfInput());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @PIPEasp_Types.ASP_Commands.");
}
set_selection(SPECIFIC_VALUE);
}

void ASP__Commands_template::copy_template(const ASP__Commands_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case ASP__Commands::ALT_pexecute:
single_value.field_pexecute = new ASP__PExecute_template(*other_value.single_value.field_pexecute);
break;
case ASP__Commands::ALT_pexecutePty:
single_value.field_pexecutePty = new ASP__PExecutePty_template(*other_value.single_value.field_pexecutePty);
break;
case ASP__Commands::ALT_pexecuteBinary:
single_value.field_pexecuteBinary = new ASP__PExecuteBinary_template(*other_value.single_value.field_pexecuteBinary);
break;
case ASP__Commands::ALT_pexecuteBinaryPty:
single_value.field_pexecuteBinaryPty = new ASP__PExecuteBinaryPty_template(*other_value.single_value.field_pexecuteBinaryPty);
break;
case ASP__Commands::ALT_pexecuteBackground:
single_value.field_pexecuteBackground = new ASP__PExecuteBackground_template(*other_value.single_value.field_pexecuteBackground);
break;
case ASP__Commands::ALT_pexecuteBackgroundPty:
single_value.field_pexecuteBackgroundPty = new ASP__PExecuteBackgroundPty_template(*other_value.single_value.field_pexecuteBackgroundPty);
break;
case ASP__Commands::ALT_pStdin:
single_value.field_pStdin = new ASP__PStdin_template(*other_value.single_value.field_pStdin);
break;
case ASP__Commands::ALT_pStdinBinary:
single_value.field_pStdinBinary = new ASP__PStdinBinary_template(*other_value.single_value.field_pStdinBinary);
break;
case ASP__Commands::ALT_pKill:
single_value.field_pKill = new ASP__PKill_template(*other_value.single_value.field_pKill);
break;
case ASP__Commands::ALT_pEndOfInput:
single_value.field_pEndOfInput = new ASP__PEndOfInput_template(*other_value.single_value.field_pEndOfInput);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @PIPEasp_Types.ASP_Commands.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ASP__Commands_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
case IMPLICATION_MATCH:
implication_.precondition = new ASP__Commands_template(*other_value.implication_.precondition);
implication_.implied_template = new ASP__Commands_template(*other_value.implication_.implied_template);
break;
case DYNAMIC_MATCH:
dyn_match = other_value.dyn_match;
dyn_match->ref_count++;
break;
default:
TTCN_error("Copying an uninitialized template of union type @PIPEasp_Types.ASP_Commands.");
}
set_selection(other_value);
}

ASP__Commands_template::ASP__Commands_template()
{
}

ASP__Commands_template::ASP__Commands_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ASP__Commands_template::ASP__Commands_template(const ASP__Commands& other_value)
{
copy_value(other_value);
}

ASP__Commands_template::ASP__Commands_template(const OPTIONAL<ASP__Commands>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__Commands&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @PIPEasp_Types.ASP_Commands from an unbound optional field.");
}
}

ASP__Commands_template::ASP__Commands_template(ASP__Commands_template* p_precondition, ASP__Commands_template* p_implied_template)
 : Base_Template(IMPLICATION_MATCH)
{
implication_.precondition = p_precondition;
implication_.implied_template = p_implied_template;
}

ASP__Commands_template::ASP__Commands_template(Dynamic_Match_Interface<ASP__Commands>* p_dyn_match)
 : Base_Template(DYNAMIC_MATCH)
{
dyn_match = new dynmatch_struct<ASP__Commands>;
dyn_match->ptr = p_dyn_match;
dyn_match->ref_count = 1;
}

ASP__Commands_template::ASP__Commands_template(const ASP__Commands_template& other_value)
: Base_Template(){
copy_template(other_value);
}

ASP__Commands_template::~ASP__Commands_template()
{
clean_up();
}

void ASP__Commands_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case ASP__Commands::ALT_pexecute:
delete single_value.field_pexecute;
break;
case ASP__Commands::ALT_pexecutePty:
delete single_value.field_pexecutePty;
break;
case ASP__Commands::ALT_pexecuteBinary:
delete single_value.field_pexecuteBinary;
break;
case ASP__Commands::ALT_pexecuteBinaryPty:
delete single_value.field_pexecuteBinaryPty;
break;
case ASP__Commands::ALT_pexecuteBackground:
delete single_value.field_pexecuteBackground;
break;
case ASP__Commands::ALT_pexecuteBackgroundPty:
delete single_value.field_pexecuteBackgroundPty;
break;
case ASP__Commands::ALT_pStdin:
delete single_value.field_pStdin;
break;
case ASP__Commands::ALT_pStdinBinary:
delete single_value.field_pStdinBinary;
break;
case ASP__Commands::ALT_pKill:
delete single_value.field_pKill;
break;
case ASP__Commands::ALT_pEndOfInput:
delete single_value.field_pEndOfInput;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
delete [] value_list.list_value;
break;
case IMPLICATION_MATCH:
delete implication_.precondition;
delete implication_.implied_template;
break;
case DYNAMIC_MATCH:
dyn_match->ref_count--;
if (dyn_match->ref_count == 0) {
delete dyn_match->ptr;
delete dyn_match;
}
break;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ASP__Commands_template& ASP__Commands_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ASP__Commands_template& ASP__Commands_template::operator=(const ASP__Commands& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ASP__Commands_template& ASP__Commands_template::operator=(const OPTIONAL<ASP__Commands>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__Commands&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @PIPEasp_Types.ASP_Commands.");
}
return *this;
}

ASP__Commands_template& ASP__Commands_template::operator=(const ASP__Commands_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ASP__Commands_template::match(const ASP__Commands& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
ASP__Commands::union_selection_type value_selection = other_value.get_selection();
if (value_selection == ASP__Commands::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case ASP__Commands::ALT_pexecute:
return single_value.field_pexecute->match(other_value.pexecute(), legacy);
case ASP__Commands::ALT_pexecutePty:
return single_value.field_pexecutePty->match(other_value.pexecutePty(), legacy);
case ASP__Commands::ALT_pexecuteBinary:
return single_value.field_pexecuteBinary->match(other_value.pexecuteBinary(), legacy);
case ASP__Commands::ALT_pexecuteBinaryPty:
return single_value.field_pexecuteBinaryPty->match(other_value.pexecuteBinaryPty(), legacy);
case ASP__Commands::ALT_pexecuteBackground:
return single_value.field_pexecuteBackground->match(other_value.pexecuteBackground(), legacy);
case ASP__Commands::ALT_pexecuteBackgroundPty:
return single_value.field_pexecuteBackgroundPty->match(other_value.pexecuteBackgroundPty(), legacy);
case ASP__Commands::ALT_pStdin:
return single_value.field_pStdin->match(other_value.pStdin(), legacy);
case ASP__Commands::ALT_pStdinBinary:
return single_value.field_pStdinBinary->match(other_value.pStdinBinary(), legacy);
case ASP__Commands::ALT_pKill:
return single_value.field_pKill->match(other_value.pKill(), legacy);
case ASP__Commands::ALT_pEndOfInput:
return single_value.field_pEndOfInput->match(other_value.pEndOfInput(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @PIPEasp_Types.ASP_Commands.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
case CONJUNCTION_MATCH:
for (unsigned int i = 0; i < value_list.n_values; i++) {
if (!value_list.list_value[i].match(other_value)) {
return FALSE;
}
}
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match(other_value) || implication_.implied_template->match(other_value);
case DYNAMIC_MATCH:
return dyn_match->ptr->match(other_value);
default:
TTCN_error ("Matching an uninitialized template of union type @PIPEasp_Types.ASP_Commands.");
}
return FALSE;
}

boolean ASP__Commands_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
switch (single_value.union_selection) {
case ASP__Commands::ALT_pexecute:
return single_value.field_pexecute->is_value();
case ASP__Commands::ALT_pexecutePty:
return single_value.field_pexecutePty->is_value();
case ASP__Commands::ALT_pexecuteBinary:
return single_value.field_pexecuteBinary->is_value();
case ASP__Commands::ALT_pexecuteBinaryPty:
return single_value.field_pexecuteBinaryPty->is_value();
case ASP__Commands::ALT_pexecuteBackground:
return single_value.field_pexecuteBackground->is_value();
case ASP__Commands::ALT_pexecuteBackgroundPty:
return single_value.field_pexecuteBackgroundPty->is_value();
case ASP__Commands::ALT_pStdin:
return single_value.field_pStdin->is_value();
case ASP__Commands::ALT_pStdinBinary:
return single_value.field_pStdinBinary->is_value();
case ASP__Commands::ALT_pKill:
return single_value.field_pKill->is_value();
case ASP__Commands::ALT_pEndOfInput:
return single_value.field_pEndOfInput->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @PIPEasp_Types.ASP_Commands.");
}
}

ASP__Commands ASP__Commands_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of union type @PIPEasp_Types.ASP_Commands.");
ASP__Commands ret_val;
switch (single_value.union_selection) {
case ASP__Commands::ALT_pexecute:
ret_val.pexecute() = single_value.field_pexecute->valueof();
break;
case ASP__Commands::ALT_pexecutePty:
ret_val.pexecutePty() = single_value.field_pexecutePty->valueof();
break;
case ASP__Commands::ALT_pexecuteBinary:
ret_val.pexecuteBinary() = single_value.field_pexecuteBinary->valueof();
break;
case ASP__Commands::ALT_pexecuteBinaryPty:
ret_val.pexecuteBinaryPty() = single_value.field_pexecuteBinaryPty->valueof();
break;
case ASP__Commands::ALT_pexecuteBackground:
ret_val.pexecuteBackground() = single_value.field_pexecuteBackground->valueof();
break;
case ASP__Commands::ALT_pexecuteBackgroundPty:
ret_val.pexecuteBackgroundPty() = single_value.field_pexecuteBackgroundPty->valueof();
break;
case ASP__Commands::ALT_pStdin:
ret_val.pStdin() = single_value.field_pStdin->valueof();
break;
case ASP__Commands::ALT_pStdinBinary:
ret_val.pStdinBinary() = single_value.field_pStdinBinary->valueof();
break;
case ASP__Commands::ALT_pKill:
ret_val.pKill() = single_value.field_pKill->valueof();
break;
case ASP__Commands::ALT_pEndOfInput:
ret_val.pEndOfInput() = single_value.field_pEndOfInput->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @PIPEasp_Types.ASP_Commands.");
}
return ret_val;
}

ASP__Commands_template& ASP__Commands_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST && template_selection != CONJUNCTION_MATCH) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @PIPEasp_Types.ASP_Commands.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @PIPEasp_Types.ASP_Commands.");
return value_list.list_value[list_index];
}
void ASP__Commands_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST && template_type != CONJUNCTION_MATCH) TTCN_error ("Internal error: Setting an invalid list for a template of union type @PIPEasp_Types.ASP_Commands.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ASP__Commands_template[list_length];
}

ASP__PExecute_template& ASP__Commands_template::pexecute()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ASP__Commands::ALT_pexecute) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_pexecute = new ASP__PExecute_template(ANY_VALUE);
else single_value.field_pexecute = new ASP__PExecute_template;
single_value.union_selection = ASP__Commands::ALT_pexecute;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_pexecute;
}

const ASP__PExecute_template& ASP__Commands_template::pexecute() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field pexecute in a non-specific template of union type @PIPEasp_Types.ASP_Commands.");
if (single_value.union_selection != ASP__Commands::ALT_pexecute) TTCN_error("Accessing non-selected field pexecute in a template of union type @PIPEasp_Types.ASP_Commands.");
return *single_value.field_pexecute;
}

ASP__PExecutePty_template& ASP__Commands_template::pexecutePty()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ASP__Commands::ALT_pexecutePty) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_pexecutePty = new ASP__PExecutePty_template(ANY_VALUE);
else single_value.field_pexecutePty = new ASP__PExecutePty_template;
single_value.union_selection = ASP__Commands::ALT_pexecutePty;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_pexecutePty;
}

const ASP__PExecutePty_template& ASP__Commands_template::pexecutePty() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field pexecutePty in a non-specific template of union type @PIPEasp_Types.ASP_Commands.");
if (single_value.union_selection != ASP__Commands::ALT_pexecutePty) TTCN_error("Accessing non-selected field pexecutePty in a template of union type @PIPEasp_Types.ASP_Commands.");
return *single_value.field_pexecutePty;
}

ASP__PExecuteBinary_template& ASP__Commands_template::pexecuteBinary()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ASP__Commands::ALT_pexecuteBinary) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_pexecuteBinary = new ASP__PExecuteBinary_template(ANY_VALUE);
else single_value.field_pexecuteBinary = new ASP__PExecuteBinary_template;
single_value.union_selection = ASP__Commands::ALT_pexecuteBinary;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_pexecuteBinary;
}

const ASP__PExecuteBinary_template& ASP__Commands_template::pexecuteBinary() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field pexecuteBinary in a non-specific template of union type @PIPEasp_Types.ASP_Commands.");
if (single_value.union_selection != ASP__Commands::ALT_pexecuteBinary) TTCN_error("Accessing non-selected field pexecuteBinary in a template of union type @PIPEasp_Types.ASP_Commands.");
return *single_value.field_pexecuteBinary;
}

ASP__PExecuteBinaryPty_template& ASP__Commands_template::pexecuteBinaryPty()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ASP__Commands::ALT_pexecuteBinaryPty) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_pexecuteBinaryPty = new ASP__PExecuteBinaryPty_template(ANY_VALUE);
else single_value.field_pexecuteBinaryPty = new ASP__PExecuteBinaryPty_template;
single_value.union_selection = ASP__Commands::ALT_pexecuteBinaryPty;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_pexecuteBinaryPty;
}

const ASP__PExecuteBinaryPty_template& ASP__Commands_template::pexecuteBinaryPty() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field pexecuteBinaryPty in a non-specific template of union type @PIPEasp_Types.ASP_Commands.");
if (single_value.union_selection != ASP__Commands::ALT_pexecuteBinaryPty) TTCN_error("Accessing non-selected field pexecuteBinaryPty in a template of union type @PIPEasp_Types.ASP_Commands.");
return *single_value.field_pexecuteBinaryPty;
}

ASP__PExecuteBackground_template& ASP__Commands_template::pexecuteBackground()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ASP__Commands::ALT_pexecuteBackground) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_pexecuteBackground = new ASP__PExecuteBackground_template(ANY_VALUE);
else single_value.field_pexecuteBackground = new ASP__PExecuteBackground_template;
single_value.union_selection = ASP__Commands::ALT_pexecuteBackground;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_pexecuteBackground;
}

const ASP__PExecuteBackground_template& ASP__Commands_template::pexecuteBackground() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field pexecuteBackground in a non-specific template of union type @PIPEasp_Types.ASP_Commands.");
if (single_value.union_selection != ASP__Commands::ALT_pexecuteBackground) TTCN_error("Accessing non-selected field pexecuteBackground in a template of union type @PIPEasp_Types.ASP_Commands.");
return *single_value.field_pexecuteBackground;
}

ASP__PExecuteBackgroundPty_template& ASP__Commands_template::pexecuteBackgroundPty()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ASP__Commands::ALT_pexecuteBackgroundPty) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_pexecuteBackgroundPty = new ASP__PExecuteBackgroundPty_template(ANY_VALUE);
else single_value.field_pexecuteBackgroundPty = new ASP__PExecuteBackgroundPty_template;
single_value.union_selection = ASP__Commands::ALT_pexecuteBackgroundPty;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_pexecuteBackgroundPty;
}

const ASP__PExecuteBackgroundPty_template& ASP__Commands_template::pexecuteBackgroundPty() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field pexecuteBackgroundPty in a non-specific template of union type @PIPEasp_Types.ASP_Commands.");
if (single_value.union_selection != ASP__Commands::ALT_pexecuteBackgroundPty) TTCN_error("Accessing non-selected field pexecuteBackgroundPty in a template of union type @PIPEasp_Types.ASP_Commands.");
return *single_value.field_pexecuteBackgroundPty;
}

ASP__PStdin_template& ASP__Commands_template::pStdin()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ASP__Commands::ALT_pStdin) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_pStdin = new ASP__PStdin_template(ANY_VALUE);
else single_value.field_pStdin = new ASP__PStdin_template;
single_value.union_selection = ASP__Commands::ALT_pStdin;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_pStdin;
}

const ASP__PStdin_template& ASP__Commands_template::pStdin() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field pStdin in a non-specific template of union type @PIPEasp_Types.ASP_Commands.");
if (single_value.union_selection != ASP__Commands::ALT_pStdin) TTCN_error("Accessing non-selected field pStdin in a template of union type @PIPEasp_Types.ASP_Commands.");
return *single_value.field_pStdin;
}

ASP__PStdinBinary_template& ASP__Commands_template::pStdinBinary()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ASP__Commands::ALT_pStdinBinary) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_pStdinBinary = new ASP__PStdinBinary_template(ANY_VALUE);
else single_value.field_pStdinBinary = new ASP__PStdinBinary_template;
single_value.union_selection = ASP__Commands::ALT_pStdinBinary;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_pStdinBinary;
}

const ASP__PStdinBinary_template& ASP__Commands_template::pStdinBinary() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field pStdinBinary in a non-specific template of union type @PIPEasp_Types.ASP_Commands.");
if (single_value.union_selection != ASP__Commands::ALT_pStdinBinary) TTCN_error("Accessing non-selected field pStdinBinary in a template of union type @PIPEasp_Types.ASP_Commands.");
return *single_value.field_pStdinBinary;
}

ASP__PKill_template& ASP__Commands_template::pKill()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ASP__Commands::ALT_pKill) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_pKill = new ASP__PKill_template(ANY_VALUE);
else single_value.field_pKill = new ASP__PKill_template;
single_value.union_selection = ASP__Commands::ALT_pKill;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_pKill;
}

const ASP__PKill_template& ASP__Commands_template::pKill() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field pKill in a non-specific template of union type @PIPEasp_Types.ASP_Commands.");
if (single_value.union_selection != ASP__Commands::ALT_pKill) TTCN_error("Accessing non-selected field pKill in a template of union type @PIPEasp_Types.ASP_Commands.");
return *single_value.field_pKill;
}

ASP__PEndOfInput_template& ASP__Commands_template::pEndOfInput()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ASP__Commands::ALT_pEndOfInput) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_pEndOfInput = new ASP__PEndOfInput_template(ANY_VALUE);
else single_value.field_pEndOfInput = new ASP__PEndOfInput_template;
single_value.union_selection = ASP__Commands::ALT_pEndOfInput;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_pEndOfInput;
}

const ASP__PEndOfInput_template& ASP__Commands_template::pEndOfInput() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field pEndOfInput in a non-specific template of union type @PIPEasp_Types.ASP_Commands.");
if (single_value.union_selection != ASP__Commands::ALT_pEndOfInput) TTCN_error("Accessing non-selected field pEndOfInput in a template of union type @PIPEasp_Types.ASP_Commands.");
return *single_value.field_pEndOfInput;
}

boolean ASP__Commands_template::ischosen(ASP__Commands::union_selection_type checked_selection) const
{
if (checked_selection == ASP__Commands::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @PIPEasp_Types.ASP_Commands.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == ASP__Commands::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @PIPEasp_Types.ASP_Commands.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @PIPEasp_Types.ASP_Commands containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
for (unsigned int list_count = 1; ret_val == TRUE && list_count < value_list.n_values; list_count++) {
ret_val = value_list.list_value[list_count].ischosen(checked_selection);
}
return ret_val;
}
default:
return FALSE;
}
return FALSE;
}

void ASP__Commands_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case ASP__Commands::ALT_pexecute:
TTCN_Logger::log_event_str("{ pexecute := ");
single_value.field_pexecute->log();
TTCN_Logger::log_event_str(" }");
break;
case ASP__Commands::ALT_pexecutePty:
TTCN_Logger::log_event_str("{ pexecutePty := ");
single_value.field_pexecutePty->log();
TTCN_Logger::log_event_str(" }");
break;
case ASP__Commands::ALT_pexecuteBinary:
TTCN_Logger::log_event_str("{ pexecuteBinary := ");
single_value.field_pexecuteBinary->log();
TTCN_Logger::log_event_str(" }");
break;
case ASP__Commands::ALT_pexecuteBinaryPty:
TTCN_Logger::log_event_str("{ pexecuteBinaryPty := ");
single_value.field_pexecuteBinaryPty->log();
TTCN_Logger::log_event_str(" }");
break;
case ASP__Commands::ALT_pexecuteBackground:
TTCN_Logger::log_event_str("{ pexecuteBackground := ");
single_value.field_pexecuteBackground->log();
TTCN_Logger::log_event_str(" }");
break;
case ASP__Commands::ALT_pexecuteBackgroundPty:
TTCN_Logger::log_event_str("{ pexecuteBackgroundPty := ");
single_value.field_pexecuteBackgroundPty->log();
TTCN_Logger::log_event_str(" }");
break;
case ASP__Commands::ALT_pStdin:
TTCN_Logger::log_event_str("{ pStdin := ");
single_value.field_pStdin->log();
TTCN_Logger::log_event_str(" }");
break;
case ASP__Commands::ALT_pStdinBinary:
TTCN_Logger::log_event_str("{ pStdinBinary := ");
single_value.field_pStdinBinary->log();
TTCN_Logger::log_event_str(" }");
break;
case ASP__Commands::ALT_pKill:
TTCN_Logger::log_event_str("{ pKill := ");
single_value.field_pKill->log();
TTCN_Logger::log_event_str(" }");
break;
case ASP__Commands::ALT_pEndOfInput:
TTCN_Logger::log_event_str("{ pEndOfInput := ");
single_value.field_pEndOfInput->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case CONJUNCTION_MATCH:
if (template_selection == CONJUNCTION_MATCH) {
TTCN_Logger::log_event_str("conjunct");
}
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
case IMPLICATION_MATCH:
implication_.precondition->log();
TTCN_Logger::log_event_str(" implies ");
implication_.implied_template->log();
break;
case DYNAMIC_MATCH:
TTCN_Logger::log_event_str("@dynamic template");
break;
default:
log_generic();
}
log_ifpresent();
}

void ASP__Commands_template::log_match(const ASP__Commands& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
switch (single_value.union_selection) {
case ASP__Commands::ALT_pexecute:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".pexecute");
single_value.field_pexecute->log_match(match_value.pexecute(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
} else {
TTCN_Logger::log_event_str("{ pexecute := ");
single_value.field_pexecute->log_match(match_value.pexecute(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ASP__Commands::ALT_pexecutePty:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".pexecutePty");
single_value.field_pexecutePty->log_match(match_value.pexecutePty(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
} else {
TTCN_Logger::log_event_str("{ pexecutePty := ");
single_value.field_pexecutePty->log_match(match_value.pexecutePty(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ASP__Commands::ALT_pexecuteBinary:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".pexecuteBinary");
single_value.field_pexecuteBinary->log_match(match_value.pexecuteBinary(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
} else {
TTCN_Logger::log_event_str("{ pexecuteBinary := ");
single_value.field_pexecuteBinary->log_match(match_value.pexecuteBinary(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ASP__Commands::ALT_pexecuteBinaryPty:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".pexecuteBinaryPty");
single_value.field_pexecuteBinaryPty->log_match(match_value.pexecuteBinaryPty(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
} else {
TTCN_Logger::log_event_str("{ pexecuteBinaryPty := ");
single_value.field_pexecuteBinaryPty->log_match(match_value.pexecuteBinaryPty(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ASP__Commands::ALT_pexecuteBackground:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".pexecuteBackground");
single_value.field_pexecuteBackground->log_match(match_value.pexecuteBackground(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
} else {
TTCN_Logger::log_event_str("{ pexecuteBackground := ");
single_value.field_pexecuteBackground->log_match(match_value.pexecuteBackground(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ASP__Commands::ALT_pexecuteBackgroundPty:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".pexecuteBackgroundPty");
single_value.field_pexecuteBackgroundPty->log_match(match_value.pexecuteBackgroundPty(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
} else {
TTCN_Logger::log_event_str("{ pexecuteBackgroundPty := ");
single_value.field_pexecuteBackgroundPty->log_match(match_value.pexecuteBackgroundPty(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ASP__Commands::ALT_pStdin:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".pStdin");
single_value.field_pStdin->log_match(match_value.pStdin(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
} else {
TTCN_Logger::log_event_str("{ pStdin := ");
single_value.field_pStdin->log_match(match_value.pStdin(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ASP__Commands::ALT_pStdinBinary:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".pStdinBinary");
single_value.field_pStdinBinary->log_match(match_value.pStdinBinary(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
} else {
TTCN_Logger::log_event_str("{ pStdinBinary := ");
single_value.field_pStdinBinary->log_match(match_value.pStdinBinary(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ASP__Commands::ALT_pKill:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".pKill");
single_value.field_pKill->log_match(match_value.pKill(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
} else {
TTCN_Logger::log_event_str("{ pKill := ");
single_value.field_pKill->log_match(match_value.pKill(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ASP__Commands::ALT_pEndOfInput:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".pEndOfInput");
single_value.field_pEndOfInput->log_match(match_value.pEndOfInput(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
} else {
TTCN_Logger::log_event_str("{ pEndOfInput := ");
single_value.field_pEndOfInput->log_match(match_value.pEndOfInput(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ASP__Commands_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case ASP__Commands::ALT_pexecute:
single_value.field_pexecute->encode_text(text_buf);
break;
case ASP__Commands::ALT_pexecutePty:
single_value.field_pexecutePty->encode_text(text_buf);
break;
case ASP__Commands::ALT_pexecuteBinary:
single_value.field_pexecuteBinary->encode_text(text_buf);
break;
case ASP__Commands::ALT_pexecuteBinaryPty:
single_value.field_pexecuteBinaryPty->encode_text(text_buf);
break;
case ASP__Commands::ALT_pexecuteBackground:
single_value.field_pexecuteBackground->encode_text(text_buf);
break;
case ASP__Commands::ALT_pexecuteBackgroundPty:
single_value.field_pexecuteBackgroundPty->encode_text(text_buf);
break;
case ASP__Commands::ALT_pStdin:
single_value.field_pStdin->encode_text(text_buf);
break;
case ASP__Commands::ALT_pStdinBinary:
single_value.field_pStdinBinary->encode_text(text_buf);
break;
case ASP__Commands::ALT_pKill:
single_value.field_pKill->encode_text(text_buf);
break;
case ASP__Commands::ALT_pEndOfInput:
single_value.field_pEndOfInput->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @PIPEasp_Types.ASP_Commands.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @PIPEasp_Types.ASP_Commands.");
}
}

void ASP__Commands_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = ASP__Commands::UNBOUND_VALUE;
ASP__Commands::union_selection_type new_selection = (ASP__Commands::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case ASP__Commands::ALT_pexecute:
single_value.field_pexecute = new ASP__PExecute_template;
single_value.field_pexecute->decode_text(text_buf);
break;
case ASP__Commands::ALT_pexecutePty:
single_value.field_pexecutePty = new ASP__PExecutePty_template;
single_value.field_pexecutePty->decode_text(text_buf);
break;
case ASP__Commands::ALT_pexecuteBinary:
single_value.field_pexecuteBinary = new ASP__PExecuteBinary_template;
single_value.field_pexecuteBinary->decode_text(text_buf);
break;
case ASP__Commands::ALT_pexecuteBinaryPty:
single_value.field_pexecuteBinaryPty = new ASP__PExecuteBinaryPty_template;
single_value.field_pexecuteBinaryPty->decode_text(text_buf);
break;
case ASP__Commands::ALT_pexecuteBackground:
single_value.field_pexecuteBackground = new ASP__PExecuteBackground_template;
single_value.field_pexecuteBackground->decode_text(text_buf);
break;
case ASP__Commands::ALT_pexecuteBackgroundPty:
single_value.field_pexecuteBackgroundPty = new ASP__PExecuteBackgroundPty_template;
single_value.field_pexecuteBackgroundPty->decode_text(text_buf);
break;
case ASP__Commands::ALT_pStdin:
single_value.field_pStdin = new ASP__PStdin_template;
single_value.field_pStdin->decode_text(text_buf);
break;
case ASP__Commands::ALT_pStdinBinary:
single_value.field_pStdinBinary = new ASP__PStdinBinary_template;
single_value.field_pStdinBinary->decode_text(text_buf);
break;
case ASP__Commands::ALT_pKill:
single_value.field_pKill = new ASP__PKill_template;
single_value.field_pKill->decode_text(text_buf);
break;
case ASP__Commands::ALT_pEndOfInput:
single_value.field_pEndOfInput = new ASP__PEndOfInput_template;
single_value.field_pEndOfInput->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @PIPEasp_Types.ASP_Commands.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ASP__Commands_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @PIPEasp_Types.ASP_Commands.");
}
}

boolean ASP__Commands_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ASP__Commands_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match_omit() || implication_.implied_template->match_omit();
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void ASP__Commands_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@PIPEasp_Types.ASP_Commands'");
    }
    if (strcmp("pexecute", param_field) == 0) {
      pexecute().set_param(param);
      return;
    } else if (strcmp("pexecutePty", param_field) == 0) {
      pexecutePty().set_param(param);
      return;
    } else if (strcmp("pexecuteBinary", param_field) == 0) {
      pexecuteBinary().set_param(param);
      return;
    } else if (strcmp("pexecuteBinaryPty", param_field) == 0) {
      pexecuteBinaryPty().set_param(param);
      return;
    } else if (strcmp("pexecuteBackground", param_field) == 0) {
      pexecuteBackground().set_param(param);
      return;
    } else if (strcmp("pexecuteBackgroundPty", param_field) == 0) {
      pexecuteBackgroundPty().set_param(param);
      return;
    } else if (strcmp("pStdin", param_field) == 0) {
      pStdin().set_param(param);
      return;
    } else if (strcmp("pStdinBinary", param_field) == 0) {
      pStdinBinary().set_param(param);
      return;
    } else if (strcmp("pKill", param_field) == 0) {
      pKill().set_param(param);
      return;
    } else if (strcmp("pEndOfInput", param_field) == 0) {
      pEndOfInput().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@PIPEasp_Types.ASP_Commands'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
  case Module_Param::MP_ConjunctList_Template: {
    ASP__Commands_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : (m_p->get_type() == Module_Param::MP_ConjunctList_Template ? CONJUNCTION_MATCH : COMPLEMENTED_LIST), m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (m_p->get_size()==0) break;
    param.type_error("union template", "@PIPEasp_Types.ASP_Commands");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = m_p->get_elem(m_p->get_size()-1);
    char* last_name = mp_last->get_id()->get_name();
    if (!strcmp(last_name, "pexecute")) {
      pexecute().set_param(*mp_last);
      break;
    }
    if (!strcmp(last_name, "pexecutePty")) {
      pexecutePty().set_param(*mp_last);
      break;
    }
    if (!strcmp(last_name, "pexecuteBinary")) {
      pexecuteBinary().set_param(*mp_last);
      break;
    }
    if (!strcmp(last_name, "pexecuteBinaryPty")) {
      pexecuteBinaryPty().set_param(*mp_last);
      break;
    }
    if (!strcmp(last_name, "pexecuteBackground")) {
      pexecuteBackground().set_param(*mp_last);
      break;
    }
    if (!strcmp(last_name, "pexecuteBackgroundPty")) {
      pexecuteBackgroundPty().set_param(*mp_last);
      break;
    }
    if (!strcmp(last_name, "pStdin")) {
      pStdin().set_param(*mp_last);
      break;
    }
    if (!strcmp(last_name, "pStdinBinary")) {
      pStdinBinary().set_param(*mp_last);
      break;
    }
    if (!strcmp(last_name, "pKill")) {
      pKill().set_param(*mp_last);
      break;
    }
    if (!strcmp(last_name, "pEndOfInput")) {
      pEndOfInput().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @PIPEasp_Types.ASP_Commands.", last_name);
  } break;
  case Module_Param::MP_Implication_Template: {
    ASP__Commands_template* precondition = new ASP__Commands_template;
    precondition->set_param(*m_p->get_elem(0));
    ASP__Commands_template* implied_template = new ASP__Commands_template;
    implied_template->set_param(*m_p->get_elem(1));
    *this = ASP__Commands_template(precondition, implied_template);
  } break;
  default:
    param.type_error("union template", "@PIPEasp_Types.ASP_Commands");
  }
  is_ifpresent = param.get_ifpresent();
}

void ASP__Commands_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case ASP__Commands::ALT_pexecute:
single_value.field_pexecute->check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_Commands");
return;
case ASP__Commands::ALT_pexecutePty:
single_value.field_pexecutePty->check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_Commands");
return;
case ASP__Commands::ALT_pexecuteBinary:
single_value.field_pexecuteBinary->check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_Commands");
return;
case ASP__Commands::ALT_pexecuteBinaryPty:
single_value.field_pexecuteBinaryPty->check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_Commands");
return;
case ASP__Commands::ALT_pexecuteBackground:
single_value.field_pexecuteBackground->check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_Commands");
return;
case ASP__Commands::ALT_pexecuteBackgroundPty:
single_value.field_pexecuteBackgroundPty->check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_Commands");
return;
case ASP__Commands::ALT_pStdin:
single_value.field_pStdin->check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_Commands");
return;
case ASP__Commands::ALT_pStdinBinary:
single_value.field_pStdinBinary->check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_Commands");
return;
case ASP__Commands::ALT_pKill:
single_value.field_pKill->check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_Commands");
return;
case ASP__Commands::ALT_pEndOfInput:
single_value.field_pEndOfInput->check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_Commands");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @PIPEasp_Types.ASP_Commands.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@PIPEasp_Types.ASP_Commands");
}

ASP__Parallel__Command::ASP__Parallel__Command()
{
}

ASP__Parallel__Command::ASP__Parallel__Command(const INTEGER& par_p__id,
    const ASP__Commands& par_command)
  :   field_p__id(par_p__id),
  field_command(par_command)
{
}

ASP__Parallel__Command::ASP__Parallel__Command(const ASP__Parallel__Command& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @PIPEasp_Types.ASP_Parallel_Command.");
if (other_value.p__id().is_bound()) field_p__id = other_value.p__id();
else field_p__id.clean_up();
if (other_value.command().is_bound()) field_command = other_value.command();
else field_command.clean_up();
}

void ASP__Parallel__Command::clean_up()
{
field_p__id.clean_up();
field_command.clean_up();
}

const TTCN_Typedescriptor_t* ASP__Parallel__Command::get_descriptor() const { return &ASP__Parallel__Command_descr_; }
ASP__Parallel__Command& ASP__Parallel__Command::operator=(const ASP__Parallel__Command& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @PIPEasp_Types.ASP_Parallel_Command.");
  if (other_value.p__id().is_bound()) field_p__id = other_value.p__id();
  else field_p__id.clean_up();
  if (other_value.command().is_bound()) field_command = other_value.command();
  else field_command.clean_up();
}
return *this;
}

boolean ASP__Parallel__Command::operator==(const ASP__Parallel__Command& other_value) const
{
return field_p__id==other_value.field_p__id
  && field_command==other_value.field_command;
}

boolean ASP__Parallel__Command::is_bound() const
{
return (field_p__id.is_bound())
  || (field_command.is_bound());
}
boolean ASP__Parallel__Command::is_value() const
{
return field_p__id.is_value()
  && field_command.is_value();
}
void ASP__Parallel__Command::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ p_id := ");
field_p__id.log();
TTCN_Logger::log_event_str(", command := ");
field_command.log();
TTCN_Logger::log_event_str(" }");
}

void ASP__Parallel__Command::set_implicit_omit()
{
if (p__id().is_bound()) p__id().set_implicit_omit();
if (command().is_bound()) command().set_implicit_omit();
}

void ASP__Parallel__Command::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record value of type @PIPEasp_Types.ASP_Parallel_Command has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) p__id().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) command().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "p_id")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          p__id().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "command")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          command().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PIPEasp_Types.ASP_Parallel_Command: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@PIPEasp_Types.ASP_Parallel_Command");
  }
}

void ASP__Parallel__Command::encode_text(Text_Buf& text_buf) const
{
field_p__id.encode_text(text_buf);
field_command.encode_text(text_buf);
}

void ASP__Parallel__Command::decode_text(Text_Buf& text_buf)
{
field_p__id.decode_text(text_buf);
field_command.decode_text(text_buf);
}

struct ASP__Parallel__Command_template::single_value_struct {
INTEGER_template field_p__id;
ASP__Commands_template field_command;
};

void ASP__Parallel__Command_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_p__id = ANY_VALUE;
single_value->field_command = ANY_VALUE;
}
}
}

void ASP__Parallel__Command_template::copy_value(const ASP__Parallel__Command& other_value)
{
single_value = new single_value_struct;
if (other_value.p__id().is_bound()) {
  single_value->field_p__id = other_value.p__id();
} else {
  single_value->field_p__id.clean_up();
}
if (other_value.command().is_bound()) {
  single_value->field_command = other_value.command();
} else {
  single_value->field_command.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ASP__Parallel__Command_template::copy_template(const ASP__Parallel__Command_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.p__id().get_selection()) {
single_value->field_p__id = other_value.p__id();
} else {
single_value->field_p__id.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.command().get_selection()) {
single_value->field_command = other_value.command();
} else {
single_value->field_command.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ASP__Parallel__Command_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
case IMPLICATION_MATCH:
implication_.precondition = new ASP__Parallel__Command_template(*other_value.implication_.precondition);
implication_.implied_template = new ASP__Parallel__Command_template(*other_value.implication_.implied_template);
break;
case DYNAMIC_MATCH:
dyn_match = other_value.dyn_match;
dyn_match->ref_count++;
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @PIPEasp_Types.ASP_Parallel_Command.");
break;
}
set_selection(other_value);
}

ASP__Parallel__Command_template::ASP__Parallel__Command_template()
{
}

ASP__Parallel__Command_template::ASP__Parallel__Command_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ASP__Parallel__Command_template::ASP__Parallel__Command_template(const ASP__Parallel__Command& other_value)
{
copy_value(other_value);
}

ASP__Parallel__Command_template::ASP__Parallel__Command_template(const OPTIONAL<ASP__Parallel__Command>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__Parallel__Command&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @PIPEasp_Types.ASP_Parallel_Command from an unbound optional field.");
}
}

ASP__Parallel__Command_template::ASP__Parallel__Command_template(ASP__Parallel__Command_template* p_precondition, ASP__Parallel__Command_template* p_implied_template)
 : Base_Template(IMPLICATION_MATCH)
{
implication_.precondition = p_precondition;
implication_.implied_template = p_implied_template;
}

ASP__Parallel__Command_template::ASP__Parallel__Command_template(Dynamic_Match_Interface<ASP__Parallel__Command>* p_dyn_match)
 : Base_Template(DYNAMIC_MATCH)
{
dyn_match = new dynmatch_struct<ASP__Parallel__Command>;
dyn_match->ptr = p_dyn_match;
dyn_match->ref_count = 1;
}

ASP__Parallel__Command_template::ASP__Parallel__Command_template(const ASP__Parallel__Command_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ASP__Parallel__Command_template::~ASP__Parallel__Command_template()
{
clean_up();
}

ASP__Parallel__Command_template& ASP__Parallel__Command_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ASP__Parallel__Command_template& ASP__Parallel__Command_template::operator=(const ASP__Parallel__Command& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ASP__Parallel__Command_template& ASP__Parallel__Command_template::operator=(const OPTIONAL<ASP__Parallel__Command>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__Parallel__Command&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @PIPEasp_Types.ASP_Parallel_Command.");
}
return *this;
}

ASP__Parallel__Command_template& ASP__Parallel__Command_template::operator=(const ASP__Parallel__Command_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ASP__Parallel__Command_template::match(const ASP__Parallel__Command& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.p__id().is_bound()) return FALSE;
if(!single_value->field_p__id.match(other_value.p__id(), legacy))return FALSE;
if(!other_value.command().is_bound()) return FALSE;
if(!single_value->field_command.match(other_value.command(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
case CONJUNCTION_MATCH:
for (unsigned int i = 0; i < value_list.n_values; i++) {
if (!value_list.list_value[i].match(other_value)) {
return FALSE;
}
}
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match(other_value) || implication_.implied_template->match(other_value);
case DYNAMIC_MATCH:
return dyn_match->ptr->match(other_value);
default:
TTCN_error("Matching an uninitialized/unsupported template of type @PIPEasp_Types.ASP_Parallel_Command.");
}
return FALSE;
}

boolean ASP__Parallel__Command_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
return single_value->field_p__id.is_bound()
 || single_value->field_command.is_bound();
}

boolean ASP__Parallel__Command_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value->field_p__id.is_value()
 && single_value->field_command.is_value();
}

void ASP__Parallel__Command_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
delete [] value_list.list_value;
break;
case IMPLICATION_MATCH:
delete implication_.precondition;
delete implication_.implied_template;
break;
case DYNAMIC_MATCH:
dyn_match->ref_count--;
if (dyn_match->ref_count == 0) {
delete dyn_match->ptr;
delete dyn_match;
}
break;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ASP__Parallel__Command ASP__Parallel__Command_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @PIPEasp_Types.ASP_Parallel_Command.");
ASP__Parallel__Command ret_val;
if (single_value->field_p__id.is_bound()) {
ret_val.p__id() = single_value->field_p__id.valueof();
}
if (single_value->field_command.is_bound()) {
ret_val.command() = single_value->field_command.valueof();
}
return ret_val;
}

void ASP__Parallel__Command_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST&& template_type != CONJUNCTION_MATCH)
TTCN_error("Setting an invalid list for a template of type @PIPEasp_Types.ASP_Parallel_Command.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ASP__Parallel__Command_template[list_length];
}

ASP__Parallel__Command_template& ASP__Parallel__Command_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST&& template_selection != CONJUNCTION_MATCH)
TTCN_error("Accessing a list element of a non-list template of type @PIPEasp_Types.ASP_Parallel_Command.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @PIPEasp_Types.ASP_Parallel_Command.");
return value_list.list_value[list_index];
}

INTEGER_template& ASP__Parallel__Command_template::p__id()
{
set_specific();
return single_value->field_p__id;
}

const INTEGER_template& ASP__Parallel__Command_template::p__id() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field p_id of a non-specific template of type @PIPEasp_Types.ASP_Parallel_Command.");
return single_value->field_p__id;
}

ASP__Commands_template& ASP__Parallel__Command_template::command()
{
set_specific();
return single_value->field_command;
}

const ASP__Commands_template& ASP__Parallel__Command_template::command() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field command of a non-specific template of type @PIPEasp_Types.ASP_Parallel_Command.");
return single_value->field_command;
}

int ASP__Parallel__Command_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_Parallel_Command which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_Parallel_Command containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_Parallel_Command containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_Parallel_Command containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_Parallel_Command containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_Parallel_Command containing complemented list.");
  case CONJUNCTION_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_Parallel_Command containing a conjunction list match.");
  case IMPLICATION_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_Parallel_Command containing an implication match.");
  case DYNAMIC_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_Parallel_Command containing a dynamic match.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @PIPEasp_Types.ASP_Parallel_Command.");
  }
  return 0;
}

void ASP__Parallel__Command_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ p_id := ");
single_value->field_p__id.log();
TTCN_Logger::log_event_str(", command := ");
single_value->field_command.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case CONJUNCTION_MATCH:
if (template_selection == CONJUNCTION_MATCH) {
TTCN_Logger::log_event_str("conjunct");
}
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
case IMPLICATION_MATCH:
implication_.precondition->log();
TTCN_Logger::log_event_str(" implies ");
implication_.implied_template->log();
break;
case DYNAMIC_MATCH:
TTCN_Logger::log_event_str("@dynamic template");
break;
default:
log_generic();
}
log_ifpresent();
}

void ASP__Parallel__Command_template::log_match(const ASP__Parallel__Command& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_p__id.match(match_value.p__id(), legacy)){
TTCN_Logger::log_logmatch_info(".p_id");
single_value->field_p__id.log_match(match_value.p__id(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_command.match(match_value.command(), legacy)){
TTCN_Logger::log_logmatch_info(".command");
single_value->field_command.log_match(match_value.command(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ p_id := ");
single_value->field_p__id.log_match(match_value.p__id(), legacy);
TTCN_Logger::log_event_str(", command := ");
single_value->field_command.log_match(match_value.command(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ASP__Parallel__Command_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_p__id.encode_text(text_buf);
single_value->field_command.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @PIPEasp_Types.ASP_Parallel_Command.");
}
}

void ASP__Parallel__Command_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_p__id.decode_text(text_buf);
single_value->field_command.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ASP__Parallel__Command_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @PIPEasp_Types.ASP_Parallel_Command.");
}
}

void ASP__Parallel__Command_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
  case Module_Param::MP_ConjunctList_Template: {
    ASP__Parallel__Command_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : (param.get_type() == Module_Param::MP_ConjunctList_Template ? CONJUNCTION_MATCH : COMPLEMENTED_LIST), param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record template of type @PIPEasp_Types.ASP_Parallel_Command has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) p__id().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) command().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "p_id")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          p__id().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "command")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          command().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PIPEasp_Types.ASP_Parallel_Command: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  case Module_Param::MP_Implication_Template: {
    ASP__Parallel__Command_template* precondition = new ASP__Parallel__Command_template;
    precondition->set_param(*param.get_elem(0));
    ASP__Parallel__Command_template* implied_template = new ASP__Parallel__Command_template;
    implied_template->set_param(*param.get_elem(1));
    *this = ASP__Parallel__Command_template(precondition, implied_template);
  } break;
  default:
    param.type_error("record template", "@PIPEasp_Types.ASP_Parallel_Command");
  }
  is_ifpresent = param.get_ifpresent();
}

void ASP__Parallel__Command_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_p__id.check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_Parallel_Command");
single_value->field_command.check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_Parallel_Command");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@PIPEasp_Types.ASP_Parallel_Command");
}

boolean ASP__Parallel__Command_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ASP__Parallel__Command_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match_omit() || implication_.implied_template->match_omit();
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void ASP__Results::copy_value(const ASP__Results& other_value)
{
switch (other_value.union_selection) {
case ALT_pResult:
field_pResult = new ASP__PResult(*other_value.field_pResult);
break;
case ALT_pResultBinary:
field_pResultBinary = new ASP__PResultBinary(*other_value.field_pResultBinary);
break;
case ALT_pStdout:
field_pStdout = new ASP__PStdout(*other_value.field_pStdout);
break;
case ALT_pStderr:
field_pStderr = new ASP__PStderr(*other_value.field_pStderr);
break;
case ALT_pStdoutBinary:
field_pStdoutBinary = new ASP__PStdoutBinary(*other_value.field_pStdoutBinary);
break;
case ALT_pStedrrBinary:
field_pStedrrBinary = new ASP__PStderrBinary(*other_value.field_pStedrrBinary);
break;
case ALT_pExit:
field_pExit = new ASP__PExit(*other_value.field_pExit);
break;
case ALT_pError:
field_pError = new ASP__PError(*other_value.field_pError);
break;
default:
TTCN_error("Assignment of an unbound union value of type @PIPEasp_Types.ASP_Results.");
}
union_selection = other_value.union_selection;
}

ASP__Results::ASP__Results()
{
union_selection = UNBOUND_VALUE;
}

ASP__Results::ASP__Results(const ASP__Results& other_value)
: Base_Type(){
copy_value(other_value);
}

ASP__Results::~ASP__Results()
{
clean_up();
}

ASP__Results& ASP__Results::operator=(const ASP__Results& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean ASP__Results::operator==(const ASP__Results& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @PIPEasp_Types.ASP_Results.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @PIPEasp_Types.ASP_Results.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_pResult:
return *field_pResult == *other_value.field_pResult;
case ALT_pResultBinary:
return *field_pResultBinary == *other_value.field_pResultBinary;
case ALT_pStdout:
return *field_pStdout == *other_value.field_pStdout;
case ALT_pStderr:
return *field_pStderr == *other_value.field_pStderr;
case ALT_pStdoutBinary:
return *field_pStdoutBinary == *other_value.field_pStdoutBinary;
case ALT_pStedrrBinary:
return *field_pStedrrBinary == *other_value.field_pStedrrBinary;
case ALT_pExit:
return *field_pExit == *other_value.field_pExit;
case ALT_pError:
return *field_pError == *other_value.field_pError;
default:
return FALSE;
}
}

ASP__PResult& ASP__Results::pResult()
{
if (union_selection != ALT_pResult) {
clean_up();
field_pResult = new ASP__PResult;
union_selection = ALT_pResult;
}
return *field_pResult;
}

const ASP__PResult& ASP__Results::pResult() const
{
if (union_selection != ALT_pResult) TTCN_error("Using non-selected field pResult in a value of union type @PIPEasp_Types.ASP_Results.");
return *field_pResult;
}

ASP__PResultBinary& ASP__Results::pResultBinary()
{
if (union_selection != ALT_pResultBinary) {
clean_up();
field_pResultBinary = new ASP__PResultBinary;
union_selection = ALT_pResultBinary;
}
return *field_pResultBinary;
}

const ASP__PResultBinary& ASP__Results::pResultBinary() const
{
if (union_selection != ALT_pResultBinary) TTCN_error("Using non-selected field pResultBinary in a value of union type @PIPEasp_Types.ASP_Results.");
return *field_pResultBinary;
}

ASP__PStdout& ASP__Results::pStdout()
{
if (union_selection != ALT_pStdout) {
clean_up();
field_pStdout = new ASP__PStdout;
union_selection = ALT_pStdout;
}
return *field_pStdout;
}

const ASP__PStdout& ASP__Results::pStdout() const
{
if (union_selection != ALT_pStdout) TTCN_error("Using non-selected field pStdout in a value of union type @PIPEasp_Types.ASP_Results.");
return *field_pStdout;
}

ASP__PStderr& ASP__Results::pStderr()
{
if (union_selection != ALT_pStderr) {
clean_up();
field_pStderr = new ASP__PStderr;
union_selection = ALT_pStderr;
}
return *field_pStderr;
}

const ASP__PStderr& ASP__Results::pStderr() const
{
if (union_selection != ALT_pStderr) TTCN_error("Using non-selected field pStderr in a value of union type @PIPEasp_Types.ASP_Results.");
return *field_pStderr;
}

ASP__PStdoutBinary& ASP__Results::pStdoutBinary()
{
if (union_selection != ALT_pStdoutBinary) {
clean_up();
field_pStdoutBinary = new ASP__PStdoutBinary;
union_selection = ALT_pStdoutBinary;
}
return *field_pStdoutBinary;
}

const ASP__PStdoutBinary& ASP__Results::pStdoutBinary() const
{
if (union_selection != ALT_pStdoutBinary) TTCN_error("Using non-selected field pStdoutBinary in a value of union type @PIPEasp_Types.ASP_Results.");
return *field_pStdoutBinary;
}

ASP__PStderrBinary& ASP__Results::pStedrrBinary()
{
if (union_selection != ALT_pStedrrBinary) {
clean_up();
field_pStedrrBinary = new ASP__PStderrBinary;
union_selection = ALT_pStedrrBinary;
}
return *field_pStedrrBinary;
}

const ASP__PStderrBinary& ASP__Results::pStedrrBinary() const
{
if (union_selection != ALT_pStedrrBinary) TTCN_error("Using non-selected field pStedrrBinary in a value of union type @PIPEasp_Types.ASP_Results.");
return *field_pStedrrBinary;
}

ASP__PExit& ASP__Results::pExit()
{
if (union_selection != ALT_pExit) {
clean_up();
field_pExit = new ASP__PExit;
union_selection = ALT_pExit;
}
return *field_pExit;
}

const ASP__PExit& ASP__Results::pExit() const
{
if (union_selection != ALT_pExit) TTCN_error("Using non-selected field pExit in a value of union type @PIPEasp_Types.ASP_Results.");
return *field_pExit;
}

ASP__PError& ASP__Results::pError()
{
if (union_selection != ALT_pError) {
clean_up();
field_pError = new ASP__PError;
union_selection = ALT_pError;
}
return *field_pError;
}

const ASP__PError& ASP__Results::pError() const
{
if (union_selection != ALT_pError) TTCN_error("Using non-selected field pError in a value of union type @PIPEasp_Types.ASP_Results.");
return *field_pError;
}

boolean ASP__Results::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @PIPEasp_Types.ASP_Results.");
return union_selection == checked_selection;
}

boolean ASP__Results::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean ASP__Results::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_pResult: return field_pResult->is_value();
case ALT_pResultBinary: return field_pResultBinary->is_value();
case ALT_pStdout: return field_pStdout->is_value();
case ALT_pStderr: return field_pStderr->is_value();
case ALT_pStdoutBinary: return field_pStdoutBinary->is_value();
case ALT_pStedrrBinary: return field_pStedrrBinary->is_value();
case ALT_pExit: return field_pExit->is_value();
case ALT_pError: return field_pError->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void ASP__Results::clean_up()
{
switch (union_selection) {
case ALT_pResult:
  delete field_pResult;
  break;
case ALT_pResultBinary:
  delete field_pResultBinary;
  break;
case ALT_pStdout:
  delete field_pStdout;
  break;
case ALT_pStderr:
  delete field_pStderr;
  break;
case ALT_pStdoutBinary:
  delete field_pStdoutBinary;
  break;
case ALT_pStedrrBinary:
  delete field_pStedrrBinary;
  break;
case ALT_pExit:
  delete field_pExit;
  break;
case ALT_pError:
  delete field_pError;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void ASP__Results::log() const
{
switch (union_selection) {
case ALT_pResult:
TTCN_Logger::log_event_str("{ pResult := ");
field_pResult->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_pResultBinary:
TTCN_Logger::log_event_str("{ pResultBinary := ");
field_pResultBinary->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_pStdout:
TTCN_Logger::log_event_str("{ pStdout := ");
field_pStdout->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_pStderr:
TTCN_Logger::log_event_str("{ pStderr := ");
field_pStderr->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_pStdoutBinary:
TTCN_Logger::log_event_str("{ pStdoutBinary := ");
field_pStdoutBinary->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_pStedrrBinary:
TTCN_Logger::log_event_str("{ pStedrrBinary := ");
field_pStedrrBinary->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_pExit:
TTCN_Logger::log_event_str("{ pExit := ");
field_pExit->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_pError:
TTCN_Logger::log_event_str("{ pError := ");
field_pError->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void ASP__Results::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr m_p = &param;
  if (m_p->get_type()==Module_Param::MP_Value_List && m_p->get_size()==0) return;
  if (m_p->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = m_p->get_elem(m_p->get_size()-1);
  char* last_name = mp_last->get_id()->get_name();
  if (!strcmp(last_name, "pResult")) {
    pResult().set_param(*mp_last);
    if (!pResult().is_bound()) clean_up();
    return;
  }
  if (!strcmp(last_name, "pResultBinary")) {
    pResultBinary().set_param(*mp_last);
    if (!pResultBinary().is_bound()) clean_up();
    return;
  }
  if (!strcmp(last_name, "pStdout")) {
    pStdout().set_param(*mp_last);
    if (!pStdout().is_bound()) clean_up();
    return;
  }
  if (!strcmp(last_name, "pStderr")) {
    pStderr().set_param(*mp_last);
    if (!pStderr().is_bound()) clean_up();
    return;
  }
  if (!strcmp(last_name, "pStdoutBinary")) {
    pStdoutBinary().set_param(*mp_last);
    if (!pStdoutBinary().is_bound()) clean_up();
    return;
  }
  if (!strcmp(last_name, "pStedrrBinary")) {
    pStedrrBinary().set_param(*mp_last);
    if (!pStedrrBinary().is_bound()) clean_up();
    return;
  }
  if (!strcmp(last_name, "pExit")) {
    pExit().set_param(*mp_last);
    if (!pExit().is_bound()) clean_up();
    return;
  }
  if (!strcmp(last_name, "pError")) {
    pError().set_param(*mp_last);
    if (!pError().is_bound()) clean_up();
    return;
  }
  mp_last->error("Field %s does not exist in type @PIPEasp_Types.ASP_Results.", last_name);
}

void ASP__Results::set_implicit_omit()
{
switch (union_selection) {
case ALT_pResult:
field_pResult->set_implicit_omit(); break;
case ALT_pResultBinary:
field_pResultBinary->set_implicit_omit(); break;
case ALT_pStdout:
field_pStdout->set_implicit_omit(); break;
case ALT_pStderr:
field_pStderr->set_implicit_omit(); break;
case ALT_pStdoutBinary:
field_pStdoutBinary->set_implicit_omit(); break;
case ALT_pStedrrBinary:
field_pStedrrBinary->set_implicit_omit(); break;
case ALT_pExit:
field_pExit->set_implicit_omit(); break;
case ALT_pError:
field_pError->set_implicit_omit(); break;
default: break;
}
}

void ASP__Results::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_pResult:
field_pResult->encode_text(text_buf);
break;
case ALT_pResultBinary:
field_pResultBinary->encode_text(text_buf);
break;
case ALT_pStdout:
field_pStdout->encode_text(text_buf);
break;
case ALT_pStderr:
field_pStderr->encode_text(text_buf);
break;
case ALT_pStdoutBinary:
field_pStdoutBinary->encode_text(text_buf);
break;
case ALT_pStedrrBinary:
field_pStedrrBinary->encode_text(text_buf);
break;
case ALT_pExit:
field_pExit->encode_text(text_buf);
break;
case ALT_pError:
field_pError->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @PIPEasp_Types.ASP_Results.");
}
}

void ASP__Results::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_pResult:
pResult().decode_text(text_buf);
break;
case ALT_pResultBinary:
pResultBinary().decode_text(text_buf);
break;
case ALT_pStdout:
pStdout().decode_text(text_buf);
break;
case ALT_pStderr:
pStderr().decode_text(text_buf);
break;
case ALT_pStdoutBinary:
pStdoutBinary().decode_text(text_buf);
break;
case ALT_pStedrrBinary:
pStedrrBinary().decode_text(text_buf);
break;
case ALT_pExit:
pExit().decode_text(text_buf);
break;
case ALT_pError:
pError().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @PIPEasp_Types.ASP_Results.");
}
}

void ASP__Results_template::copy_value(const ASP__Results& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case ASP__Results::ALT_pResult:
single_value.field_pResult = new ASP__PResult_template(other_value.pResult());
break;
case ASP__Results::ALT_pResultBinary:
single_value.field_pResultBinary = new ASP__PResultBinary_template(other_value.pResultBinary());
break;
case ASP__Results::ALT_pStdout:
single_value.field_pStdout = new ASP__PStdout_template(other_value.pStdout());
break;
case ASP__Results::ALT_pStderr:
single_value.field_pStderr = new ASP__PStderr_template(other_value.pStderr());
break;
case ASP__Results::ALT_pStdoutBinary:
single_value.field_pStdoutBinary = new ASP__PStdoutBinary_template(other_value.pStdoutBinary());
break;
case ASP__Results::ALT_pStedrrBinary:
single_value.field_pStedrrBinary = new ASP__PStderrBinary_template(other_value.pStedrrBinary());
break;
case ASP__Results::ALT_pExit:
single_value.field_pExit = new ASP__PExit_template(other_value.pExit());
break;
case ASP__Results::ALT_pError:
single_value.field_pError = new ASP__PError_template(other_value.pError());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @PIPEasp_Types.ASP_Results.");
}
set_selection(SPECIFIC_VALUE);
}

void ASP__Results_template::copy_template(const ASP__Results_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case ASP__Results::ALT_pResult:
single_value.field_pResult = new ASP__PResult_template(*other_value.single_value.field_pResult);
break;
case ASP__Results::ALT_pResultBinary:
single_value.field_pResultBinary = new ASP__PResultBinary_template(*other_value.single_value.field_pResultBinary);
break;
case ASP__Results::ALT_pStdout:
single_value.field_pStdout = new ASP__PStdout_template(*other_value.single_value.field_pStdout);
break;
case ASP__Results::ALT_pStderr:
single_value.field_pStderr = new ASP__PStderr_template(*other_value.single_value.field_pStderr);
break;
case ASP__Results::ALT_pStdoutBinary:
single_value.field_pStdoutBinary = new ASP__PStdoutBinary_template(*other_value.single_value.field_pStdoutBinary);
break;
case ASP__Results::ALT_pStedrrBinary:
single_value.field_pStedrrBinary = new ASP__PStderrBinary_template(*other_value.single_value.field_pStedrrBinary);
break;
case ASP__Results::ALT_pExit:
single_value.field_pExit = new ASP__PExit_template(*other_value.single_value.field_pExit);
break;
case ASP__Results::ALT_pError:
single_value.field_pError = new ASP__PError_template(*other_value.single_value.field_pError);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @PIPEasp_Types.ASP_Results.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ASP__Results_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
case IMPLICATION_MATCH:
implication_.precondition = new ASP__Results_template(*other_value.implication_.precondition);
implication_.implied_template = new ASP__Results_template(*other_value.implication_.implied_template);
break;
case DYNAMIC_MATCH:
dyn_match = other_value.dyn_match;
dyn_match->ref_count++;
break;
default:
TTCN_error("Copying an uninitialized template of union type @PIPEasp_Types.ASP_Results.");
}
set_selection(other_value);
}

ASP__Results_template::ASP__Results_template()
{
}

ASP__Results_template::ASP__Results_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ASP__Results_template::ASP__Results_template(const ASP__Results& other_value)
{
copy_value(other_value);
}

ASP__Results_template::ASP__Results_template(const OPTIONAL<ASP__Results>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__Results&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @PIPEasp_Types.ASP_Results from an unbound optional field.");
}
}

ASP__Results_template::ASP__Results_template(ASP__Results_template* p_precondition, ASP__Results_template* p_implied_template)
 : Base_Template(IMPLICATION_MATCH)
{
implication_.precondition = p_precondition;
implication_.implied_template = p_implied_template;
}

ASP__Results_template::ASP__Results_template(Dynamic_Match_Interface<ASP__Results>* p_dyn_match)
 : Base_Template(DYNAMIC_MATCH)
{
dyn_match = new dynmatch_struct<ASP__Results>;
dyn_match->ptr = p_dyn_match;
dyn_match->ref_count = 1;
}

ASP__Results_template::ASP__Results_template(const ASP__Results_template& other_value)
: Base_Template(){
copy_template(other_value);
}

ASP__Results_template::~ASP__Results_template()
{
clean_up();
}

void ASP__Results_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case ASP__Results::ALT_pResult:
delete single_value.field_pResult;
break;
case ASP__Results::ALT_pResultBinary:
delete single_value.field_pResultBinary;
break;
case ASP__Results::ALT_pStdout:
delete single_value.field_pStdout;
break;
case ASP__Results::ALT_pStderr:
delete single_value.field_pStderr;
break;
case ASP__Results::ALT_pStdoutBinary:
delete single_value.field_pStdoutBinary;
break;
case ASP__Results::ALT_pStedrrBinary:
delete single_value.field_pStedrrBinary;
break;
case ASP__Results::ALT_pExit:
delete single_value.field_pExit;
break;
case ASP__Results::ALT_pError:
delete single_value.field_pError;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
delete [] value_list.list_value;
break;
case IMPLICATION_MATCH:
delete implication_.precondition;
delete implication_.implied_template;
break;
case DYNAMIC_MATCH:
dyn_match->ref_count--;
if (dyn_match->ref_count == 0) {
delete dyn_match->ptr;
delete dyn_match;
}
break;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ASP__Results_template& ASP__Results_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ASP__Results_template& ASP__Results_template::operator=(const ASP__Results& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ASP__Results_template& ASP__Results_template::operator=(const OPTIONAL<ASP__Results>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__Results&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @PIPEasp_Types.ASP_Results.");
}
return *this;
}

ASP__Results_template& ASP__Results_template::operator=(const ASP__Results_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ASP__Results_template::match(const ASP__Results& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
ASP__Results::union_selection_type value_selection = other_value.get_selection();
if (value_selection == ASP__Results::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case ASP__Results::ALT_pResult:
return single_value.field_pResult->match(other_value.pResult(), legacy);
case ASP__Results::ALT_pResultBinary:
return single_value.field_pResultBinary->match(other_value.pResultBinary(), legacy);
case ASP__Results::ALT_pStdout:
return single_value.field_pStdout->match(other_value.pStdout(), legacy);
case ASP__Results::ALT_pStderr:
return single_value.field_pStderr->match(other_value.pStderr(), legacy);
case ASP__Results::ALT_pStdoutBinary:
return single_value.field_pStdoutBinary->match(other_value.pStdoutBinary(), legacy);
case ASP__Results::ALT_pStedrrBinary:
return single_value.field_pStedrrBinary->match(other_value.pStedrrBinary(), legacy);
case ASP__Results::ALT_pExit:
return single_value.field_pExit->match(other_value.pExit(), legacy);
case ASP__Results::ALT_pError:
return single_value.field_pError->match(other_value.pError(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @PIPEasp_Types.ASP_Results.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
case CONJUNCTION_MATCH:
for (unsigned int i = 0; i < value_list.n_values; i++) {
if (!value_list.list_value[i].match(other_value)) {
return FALSE;
}
}
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match(other_value) || implication_.implied_template->match(other_value);
case DYNAMIC_MATCH:
return dyn_match->ptr->match(other_value);
default:
TTCN_error ("Matching an uninitialized template of union type @PIPEasp_Types.ASP_Results.");
}
return FALSE;
}

boolean ASP__Results_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
switch (single_value.union_selection) {
case ASP__Results::ALT_pResult:
return single_value.field_pResult->is_value();
case ASP__Results::ALT_pResultBinary:
return single_value.field_pResultBinary->is_value();
case ASP__Results::ALT_pStdout:
return single_value.field_pStdout->is_value();
case ASP__Results::ALT_pStderr:
return single_value.field_pStderr->is_value();
case ASP__Results::ALT_pStdoutBinary:
return single_value.field_pStdoutBinary->is_value();
case ASP__Results::ALT_pStedrrBinary:
return single_value.field_pStedrrBinary->is_value();
case ASP__Results::ALT_pExit:
return single_value.field_pExit->is_value();
case ASP__Results::ALT_pError:
return single_value.field_pError->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @PIPEasp_Types.ASP_Results.");
}
}

ASP__Results ASP__Results_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of union type @PIPEasp_Types.ASP_Results.");
ASP__Results ret_val;
switch (single_value.union_selection) {
case ASP__Results::ALT_pResult:
ret_val.pResult() = single_value.field_pResult->valueof();
break;
case ASP__Results::ALT_pResultBinary:
ret_val.pResultBinary() = single_value.field_pResultBinary->valueof();
break;
case ASP__Results::ALT_pStdout:
ret_val.pStdout() = single_value.field_pStdout->valueof();
break;
case ASP__Results::ALT_pStderr:
ret_val.pStderr() = single_value.field_pStderr->valueof();
break;
case ASP__Results::ALT_pStdoutBinary:
ret_val.pStdoutBinary() = single_value.field_pStdoutBinary->valueof();
break;
case ASP__Results::ALT_pStedrrBinary:
ret_val.pStedrrBinary() = single_value.field_pStedrrBinary->valueof();
break;
case ASP__Results::ALT_pExit:
ret_val.pExit() = single_value.field_pExit->valueof();
break;
case ASP__Results::ALT_pError:
ret_val.pError() = single_value.field_pError->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @PIPEasp_Types.ASP_Results.");
}
return ret_val;
}

ASP__Results_template& ASP__Results_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST && template_selection != CONJUNCTION_MATCH) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @PIPEasp_Types.ASP_Results.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @PIPEasp_Types.ASP_Results.");
return value_list.list_value[list_index];
}
void ASP__Results_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST && template_type != CONJUNCTION_MATCH) TTCN_error ("Internal error: Setting an invalid list for a template of union type @PIPEasp_Types.ASP_Results.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ASP__Results_template[list_length];
}

ASP__PResult_template& ASP__Results_template::pResult()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ASP__Results::ALT_pResult) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_pResult = new ASP__PResult_template(ANY_VALUE);
else single_value.field_pResult = new ASP__PResult_template;
single_value.union_selection = ASP__Results::ALT_pResult;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_pResult;
}

const ASP__PResult_template& ASP__Results_template::pResult() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field pResult in a non-specific template of union type @PIPEasp_Types.ASP_Results.");
if (single_value.union_selection != ASP__Results::ALT_pResult) TTCN_error("Accessing non-selected field pResult in a template of union type @PIPEasp_Types.ASP_Results.");
return *single_value.field_pResult;
}

ASP__PResultBinary_template& ASP__Results_template::pResultBinary()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ASP__Results::ALT_pResultBinary) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_pResultBinary = new ASP__PResultBinary_template(ANY_VALUE);
else single_value.field_pResultBinary = new ASP__PResultBinary_template;
single_value.union_selection = ASP__Results::ALT_pResultBinary;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_pResultBinary;
}

const ASP__PResultBinary_template& ASP__Results_template::pResultBinary() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field pResultBinary in a non-specific template of union type @PIPEasp_Types.ASP_Results.");
if (single_value.union_selection != ASP__Results::ALT_pResultBinary) TTCN_error("Accessing non-selected field pResultBinary in a template of union type @PIPEasp_Types.ASP_Results.");
return *single_value.field_pResultBinary;
}

ASP__PStdout_template& ASP__Results_template::pStdout()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ASP__Results::ALT_pStdout) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_pStdout = new ASP__PStdout_template(ANY_VALUE);
else single_value.field_pStdout = new ASP__PStdout_template;
single_value.union_selection = ASP__Results::ALT_pStdout;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_pStdout;
}

const ASP__PStdout_template& ASP__Results_template::pStdout() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field pStdout in a non-specific template of union type @PIPEasp_Types.ASP_Results.");
if (single_value.union_selection != ASP__Results::ALT_pStdout) TTCN_error("Accessing non-selected field pStdout in a template of union type @PIPEasp_Types.ASP_Results.");
return *single_value.field_pStdout;
}

ASP__PStderr_template& ASP__Results_template::pStderr()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ASP__Results::ALT_pStderr) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_pStderr = new ASP__PStderr_template(ANY_VALUE);
else single_value.field_pStderr = new ASP__PStderr_template;
single_value.union_selection = ASP__Results::ALT_pStderr;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_pStderr;
}

const ASP__PStderr_template& ASP__Results_template::pStderr() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field pStderr in a non-specific template of union type @PIPEasp_Types.ASP_Results.");
if (single_value.union_selection != ASP__Results::ALT_pStderr) TTCN_error("Accessing non-selected field pStderr in a template of union type @PIPEasp_Types.ASP_Results.");
return *single_value.field_pStderr;
}

ASP__PStdoutBinary_template& ASP__Results_template::pStdoutBinary()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ASP__Results::ALT_pStdoutBinary) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_pStdoutBinary = new ASP__PStdoutBinary_template(ANY_VALUE);
else single_value.field_pStdoutBinary = new ASP__PStdoutBinary_template;
single_value.union_selection = ASP__Results::ALT_pStdoutBinary;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_pStdoutBinary;
}

const ASP__PStdoutBinary_template& ASP__Results_template::pStdoutBinary() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field pStdoutBinary in a non-specific template of union type @PIPEasp_Types.ASP_Results.");
if (single_value.union_selection != ASP__Results::ALT_pStdoutBinary) TTCN_error("Accessing non-selected field pStdoutBinary in a template of union type @PIPEasp_Types.ASP_Results.");
return *single_value.field_pStdoutBinary;
}

ASP__PStderrBinary_template& ASP__Results_template::pStedrrBinary()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ASP__Results::ALT_pStedrrBinary) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_pStedrrBinary = new ASP__PStderrBinary_template(ANY_VALUE);
else single_value.field_pStedrrBinary = new ASP__PStderrBinary_template;
single_value.union_selection = ASP__Results::ALT_pStedrrBinary;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_pStedrrBinary;
}

const ASP__PStderrBinary_template& ASP__Results_template::pStedrrBinary() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field pStedrrBinary in a non-specific template of union type @PIPEasp_Types.ASP_Results.");
if (single_value.union_selection != ASP__Results::ALT_pStedrrBinary) TTCN_error("Accessing non-selected field pStedrrBinary in a template of union type @PIPEasp_Types.ASP_Results.");
return *single_value.field_pStedrrBinary;
}

ASP__PExit_template& ASP__Results_template::pExit()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ASP__Results::ALT_pExit) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_pExit = new ASP__PExit_template(ANY_VALUE);
else single_value.field_pExit = new ASP__PExit_template;
single_value.union_selection = ASP__Results::ALT_pExit;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_pExit;
}

const ASP__PExit_template& ASP__Results_template::pExit() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field pExit in a non-specific template of union type @PIPEasp_Types.ASP_Results.");
if (single_value.union_selection != ASP__Results::ALT_pExit) TTCN_error("Accessing non-selected field pExit in a template of union type @PIPEasp_Types.ASP_Results.");
return *single_value.field_pExit;
}

ASP__PError_template& ASP__Results_template::pError()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ASP__Results::ALT_pError) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_pError = new ASP__PError_template(ANY_VALUE);
else single_value.field_pError = new ASP__PError_template;
single_value.union_selection = ASP__Results::ALT_pError;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_pError;
}

const ASP__PError_template& ASP__Results_template::pError() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field pError in a non-specific template of union type @PIPEasp_Types.ASP_Results.");
if (single_value.union_selection != ASP__Results::ALT_pError) TTCN_error("Accessing non-selected field pError in a template of union type @PIPEasp_Types.ASP_Results.");
return *single_value.field_pError;
}

boolean ASP__Results_template::ischosen(ASP__Results::union_selection_type checked_selection) const
{
if (checked_selection == ASP__Results::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @PIPEasp_Types.ASP_Results.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == ASP__Results::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @PIPEasp_Types.ASP_Results.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @PIPEasp_Types.ASP_Results containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
for (unsigned int list_count = 1; ret_val == TRUE && list_count < value_list.n_values; list_count++) {
ret_val = value_list.list_value[list_count].ischosen(checked_selection);
}
return ret_val;
}
default:
return FALSE;
}
return FALSE;
}

void ASP__Results_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case ASP__Results::ALT_pResult:
TTCN_Logger::log_event_str("{ pResult := ");
single_value.field_pResult->log();
TTCN_Logger::log_event_str(" }");
break;
case ASP__Results::ALT_pResultBinary:
TTCN_Logger::log_event_str("{ pResultBinary := ");
single_value.field_pResultBinary->log();
TTCN_Logger::log_event_str(" }");
break;
case ASP__Results::ALT_pStdout:
TTCN_Logger::log_event_str("{ pStdout := ");
single_value.field_pStdout->log();
TTCN_Logger::log_event_str(" }");
break;
case ASP__Results::ALT_pStderr:
TTCN_Logger::log_event_str("{ pStderr := ");
single_value.field_pStderr->log();
TTCN_Logger::log_event_str(" }");
break;
case ASP__Results::ALT_pStdoutBinary:
TTCN_Logger::log_event_str("{ pStdoutBinary := ");
single_value.field_pStdoutBinary->log();
TTCN_Logger::log_event_str(" }");
break;
case ASP__Results::ALT_pStedrrBinary:
TTCN_Logger::log_event_str("{ pStedrrBinary := ");
single_value.field_pStedrrBinary->log();
TTCN_Logger::log_event_str(" }");
break;
case ASP__Results::ALT_pExit:
TTCN_Logger::log_event_str("{ pExit := ");
single_value.field_pExit->log();
TTCN_Logger::log_event_str(" }");
break;
case ASP__Results::ALT_pError:
TTCN_Logger::log_event_str("{ pError := ");
single_value.field_pError->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case CONJUNCTION_MATCH:
if (template_selection == CONJUNCTION_MATCH) {
TTCN_Logger::log_event_str("conjunct");
}
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
case IMPLICATION_MATCH:
implication_.precondition->log();
TTCN_Logger::log_event_str(" implies ");
implication_.implied_template->log();
break;
case DYNAMIC_MATCH:
TTCN_Logger::log_event_str("@dynamic template");
break;
default:
log_generic();
}
log_ifpresent();
}

void ASP__Results_template::log_match(const ASP__Results& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
switch (single_value.union_selection) {
case ASP__Results::ALT_pResult:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".pResult");
single_value.field_pResult->log_match(match_value.pResult(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
} else {
TTCN_Logger::log_event_str("{ pResult := ");
single_value.field_pResult->log_match(match_value.pResult(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ASP__Results::ALT_pResultBinary:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".pResultBinary");
single_value.field_pResultBinary->log_match(match_value.pResultBinary(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
} else {
TTCN_Logger::log_event_str("{ pResultBinary := ");
single_value.field_pResultBinary->log_match(match_value.pResultBinary(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ASP__Results::ALT_pStdout:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".pStdout");
single_value.field_pStdout->log_match(match_value.pStdout(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
} else {
TTCN_Logger::log_event_str("{ pStdout := ");
single_value.field_pStdout->log_match(match_value.pStdout(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ASP__Results::ALT_pStderr:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".pStderr");
single_value.field_pStderr->log_match(match_value.pStderr(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
} else {
TTCN_Logger::log_event_str("{ pStderr := ");
single_value.field_pStderr->log_match(match_value.pStderr(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ASP__Results::ALT_pStdoutBinary:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".pStdoutBinary");
single_value.field_pStdoutBinary->log_match(match_value.pStdoutBinary(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
} else {
TTCN_Logger::log_event_str("{ pStdoutBinary := ");
single_value.field_pStdoutBinary->log_match(match_value.pStdoutBinary(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ASP__Results::ALT_pStedrrBinary:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".pStedrrBinary");
single_value.field_pStedrrBinary->log_match(match_value.pStedrrBinary(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
} else {
TTCN_Logger::log_event_str("{ pStedrrBinary := ");
single_value.field_pStedrrBinary->log_match(match_value.pStedrrBinary(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ASP__Results::ALT_pExit:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".pExit");
single_value.field_pExit->log_match(match_value.pExit(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
} else {
TTCN_Logger::log_event_str("{ pExit := ");
single_value.field_pExit->log_match(match_value.pExit(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ASP__Results::ALT_pError:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".pError");
single_value.field_pError->log_match(match_value.pError(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
} else {
TTCN_Logger::log_event_str("{ pError := ");
single_value.field_pError->log_match(match_value.pError(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ASP__Results_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case ASP__Results::ALT_pResult:
single_value.field_pResult->encode_text(text_buf);
break;
case ASP__Results::ALT_pResultBinary:
single_value.field_pResultBinary->encode_text(text_buf);
break;
case ASP__Results::ALT_pStdout:
single_value.field_pStdout->encode_text(text_buf);
break;
case ASP__Results::ALT_pStderr:
single_value.field_pStderr->encode_text(text_buf);
break;
case ASP__Results::ALT_pStdoutBinary:
single_value.field_pStdoutBinary->encode_text(text_buf);
break;
case ASP__Results::ALT_pStedrrBinary:
single_value.field_pStedrrBinary->encode_text(text_buf);
break;
case ASP__Results::ALT_pExit:
single_value.field_pExit->encode_text(text_buf);
break;
case ASP__Results::ALT_pError:
single_value.field_pError->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @PIPEasp_Types.ASP_Results.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @PIPEasp_Types.ASP_Results.");
}
}

void ASP__Results_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = ASP__Results::UNBOUND_VALUE;
ASP__Results::union_selection_type new_selection = (ASP__Results::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case ASP__Results::ALT_pResult:
single_value.field_pResult = new ASP__PResult_template;
single_value.field_pResult->decode_text(text_buf);
break;
case ASP__Results::ALT_pResultBinary:
single_value.field_pResultBinary = new ASP__PResultBinary_template;
single_value.field_pResultBinary->decode_text(text_buf);
break;
case ASP__Results::ALT_pStdout:
single_value.field_pStdout = new ASP__PStdout_template;
single_value.field_pStdout->decode_text(text_buf);
break;
case ASP__Results::ALT_pStderr:
single_value.field_pStderr = new ASP__PStderr_template;
single_value.field_pStderr->decode_text(text_buf);
break;
case ASP__Results::ALT_pStdoutBinary:
single_value.field_pStdoutBinary = new ASP__PStdoutBinary_template;
single_value.field_pStdoutBinary->decode_text(text_buf);
break;
case ASP__Results::ALT_pStedrrBinary:
single_value.field_pStedrrBinary = new ASP__PStderrBinary_template;
single_value.field_pStedrrBinary->decode_text(text_buf);
break;
case ASP__Results::ALT_pExit:
single_value.field_pExit = new ASP__PExit_template;
single_value.field_pExit->decode_text(text_buf);
break;
case ASP__Results::ALT_pError:
single_value.field_pError = new ASP__PError_template;
single_value.field_pError->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @PIPEasp_Types.ASP_Results.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ASP__Results_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @PIPEasp_Types.ASP_Results.");
}
}

boolean ASP__Results_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ASP__Results_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match_omit() || implication_.implied_template->match_omit();
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void ASP__Results_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@PIPEasp_Types.ASP_Results'");
    }
    if (strcmp("pResult", param_field) == 0) {
      pResult().set_param(param);
      return;
    } else if (strcmp("pResultBinary", param_field) == 0) {
      pResultBinary().set_param(param);
      return;
    } else if (strcmp("pStdout", param_field) == 0) {
      pStdout().set_param(param);
      return;
    } else if (strcmp("pStderr", param_field) == 0) {
      pStderr().set_param(param);
      return;
    } else if (strcmp("pStdoutBinary", param_field) == 0) {
      pStdoutBinary().set_param(param);
      return;
    } else if (strcmp("pStedrrBinary", param_field) == 0) {
      pStedrrBinary().set_param(param);
      return;
    } else if (strcmp("pExit", param_field) == 0) {
      pExit().set_param(param);
      return;
    } else if (strcmp("pError", param_field) == 0) {
      pError().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@PIPEasp_Types.ASP_Results'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
  case Module_Param::MP_ConjunctList_Template: {
    ASP__Results_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : (m_p->get_type() == Module_Param::MP_ConjunctList_Template ? CONJUNCTION_MATCH : COMPLEMENTED_LIST), m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (m_p->get_size()==0) break;
    param.type_error("union template", "@PIPEasp_Types.ASP_Results");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = m_p->get_elem(m_p->get_size()-1);
    char* last_name = mp_last->get_id()->get_name();
    if (!strcmp(last_name, "pResult")) {
      pResult().set_param(*mp_last);
      break;
    }
    if (!strcmp(last_name, "pResultBinary")) {
      pResultBinary().set_param(*mp_last);
      break;
    }
    if (!strcmp(last_name, "pStdout")) {
      pStdout().set_param(*mp_last);
      break;
    }
    if (!strcmp(last_name, "pStderr")) {
      pStderr().set_param(*mp_last);
      break;
    }
    if (!strcmp(last_name, "pStdoutBinary")) {
      pStdoutBinary().set_param(*mp_last);
      break;
    }
    if (!strcmp(last_name, "pStedrrBinary")) {
      pStedrrBinary().set_param(*mp_last);
      break;
    }
    if (!strcmp(last_name, "pExit")) {
      pExit().set_param(*mp_last);
      break;
    }
    if (!strcmp(last_name, "pError")) {
      pError().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @PIPEasp_Types.ASP_Results.", last_name);
  } break;
  case Module_Param::MP_Implication_Template: {
    ASP__Results_template* precondition = new ASP__Results_template;
    precondition->set_param(*m_p->get_elem(0));
    ASP__Results_template* implied_template = new ASP__Results_template;
    implied_template->set_param(*m_p->get_elem(1));
    *this = ASP__Results_template(precondition, implied_template);
  } break;
  default:
    param.type_error("union template", "@PIPEasp_Types.ASP_Results");
  }
  is_ifpresent = param.get_ifpresent();
}

void ASP__Results_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case ASP__Results::ALT_pResult:
single_value.field_pResult->check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_Results");
return;
case ASP__Results::ALT_pResultBinary:
single_value.field_pResultBinary->check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_Results");
return;
case ASP__Results::ALT_pStdout:
single_value.field_pStdout->check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_Results");
return;
case ASP__Results::ALT_pStderr:
single_value.field_pStderr->check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_Results");
return;
case ASP__Results::ALT_pStdoutBinary:
single_value.field_pStdoutBinary->check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_Results");
return;
case ASP__Results::ALT_pStedrrBinary:
single_value.field_pStedrrBinary->check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_Results");
return;
case ASP__Results::ALT_pExit:
single_value.field_pExit->check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_Results");
return;
case ASP__Results::ALT_pError:
single_value.field_pError->check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_Results");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @PIPEasp_Types.ASP_Results.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@PIPEasp_Types.ASP_Results");
}

ASP__Parrallel__Result::ASP__Parrallel__Result()
{
}

ASP__Parrallel__Result::ASP__Parrallel__Result(const INTEGER& par_p__id,
    const ASP__Results& par_result)
  :   field_p__id(par_p__id),
  field_result(par_result)
{
}

ASP__Parrallel__Result::ASP__Parrallel__Result(const ASP__Parrallel__Result& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @PIPEasp_Types.ASP_Parrallel_Result.");
if (other_value.p__id().is_bound()) field_p__id = other_value.p__id();
else field_p__id.clean_up();
if (other_value.result().is_bound()) field_result = other_value.result();
else field_result.clean_up();
}

void ASP__Parrallel__Result::clean_up()
{
field_p__id.clean_up();
field_result.clean_up();
}

const TTCN_Typedescriptor_t* ASP__Parrallel__Result::get_descriptor() const { return &ASP__Parrallel__Result_descr_; }
ASP__Parrallel__Result& ASP__Parrallel__Result::operator=(const ASP__Parrallel__Result& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @PIPEasp_Types.ASP_Parrallel_Result.");
  if (other_value.p__id().is_bound()) field_p__id = other_value.p__id();
  else field_p__id.clean_up();
  if (other_value.result().is_bound()) field_result = other_value.result();
  else field_result.clean_up();
}
return *this;
}

boolean ASP__Parrallel__Result::operator==(const ASP__Parrallel__Result& other_value) const
{
return field_p__id==other_value.field_p__id
  && field_result==other_value.field_result;
}

boolean ASP__Parrallel__Result::is_bound() const
{
return (field_p__id.is_bound())
  || (field_result.is_bound());
}
boolean ASP__Parrallel__Result::is_value() const
{
return field_p__id.is_value()
  && field_result.is_value();
}
void ASP__Parrallel__Result::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ p_id := ");
field_p__id.log();
TTCN_Logger::log_event_str(", result := ");
field_result.log();
TTCN_Logger::log_event_str(" }");
}

void ASP__Parrallel__Result::set_implicit_omit()
{
if (p__id().is_bound()) p__id().set_implicit_omit();
if (result().is_bound()) result().set_implicit_omit();
}

void ASP__Parrallel__Result::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record value of type @PIPEasp_Types.ASP_Parrallel_Result has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) p__id().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) result().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "p_id")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          p__id().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "result")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          result().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PIPEasp_Types.ASP_Parrallel_Result: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@PIPEasp_Types.ASP_Parrallel_Result");
  }
}

void ASP__Parrallel__Result::encode_text(Text_Buf& text_buf) const
{
field_p__id.encode_text(text_buf);
field_result.encode_text(text_buf);
}

void ASP__Parrallel__Result::decode_text(Text_Buf& text_buf)
{
field_p__id.decode_text(text_buf);
field_result.decode_text(text_buf);
}

struct ASP__Parrallel__Result_template::single_value_struct {
INTEGER_template field_p__id;
ASP__Results_template field_result;
};

void ASP__Parrallel__Result_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_p__id = ANY_VALUE;
single_value->field_result = ANY_VALUE;
}
}
}

void ASP__Parrallel__Result_template::copy_value(const ASP__Parrallel__Result& other_value)
{
single_value = new single_value_struct;
if (other_value.p__id().is_bound()) {
  single_value->field_p__id = other_value.p__id();
} else {
  single_value->field_p__id.clean_up();
}
if (other_value.result().is_bound()) {
  single_value->field_result = other_value.result();
} else {
  single_value->field_result.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ASP__Parrallel__Result_template::copy_template(const ASP__Parrallel__Result_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.p__id().get_selection()) {
single_value->field_p__id = other_value.p__id();
} else {
single_value->field_p__id.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.result().get_selection()) {
single_value->field_result = other_value.result();
} else {
single_value->field_result.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ASP__Parrallel__Result_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
case IMPLICATION_MATCH:
implication_.precondition = new ASP__Parrallel__Result_template(*other_value.implication_.precondition);
implication_.implied_template = new ASP__Parrallel__Result_template(*other_value.implication_.implied_template);
break;
case DYNAMIC_MATCH:
dyn_match = other_value.dyn_match;
dyn_match->ref_count++;
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @PIPEasp_Types.ASP_Parrallel_Result.");
break;
}
set_selection(other_value);
}

ASP__Parrallel__Result_template::ASP__Parrallel__Result_template()
{
}

ASP__Parrallel__Result_template::ASP__Parrallel__Result_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ASP__Parrallel__Result_template::ASP__Parrallel__Result_template(const ASP__Parrallel__Result& other_value)
{
copy_value(other_value);
}

ASP__Parrallel__Result_template::ASP__Parrallel__Result_template(const OPTIONAL<ASP__Parrallel__Result>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__Parrallel__Result&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @PIPEasp_Types.ASP_Parrallel_Result from an unbound optional field.");
}
}

ASP__Parrallel__Result_template::ASP__Parrallel__Result_template(ASP__Parrallel__Result_template* p_precondition, ASP__Parrallel__Result_template* p_implied_template)
 : Base_Template(IMPLICATION_MATCH)
{
implication_.precondition = p_precondition;
implication_.implied_template = p_implied_template;
}

ASP__Parrallel__Result_template::ASP__Parrallel__Result_template(Dynamic_Match_Interface<ASP__Parrallel__Result>* p_dyn_match)
 : Base_Template(DYNAMIC_MATCH)
{
dyn_match = new dynmatch_struct<ASP__Parrallel__Result>;
dyn_match->ptr = p_dyn_match;
dyn_match->ref_count = 1;
}

ASP__Parrallel__Result_template::ASP__Parrallel__Result_template(const ASP__Parrallel__Result_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ASP__Parrallel__Result_template::~ASP__Parrallel__Result_template()
{
clean_up();
}

ASP__Parrallel__Result_template& ASP__Parrallel__Result_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ASP__Parrallel__Result_template& ASP__Parrallel__Result_template::operator=(const ASP__Parrallel__Result& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ASP__Parrallel__Result_template& ASP__Parrallel__Result_template::operator=(const OPTIONAL<ASP__Parrallel__Result>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__Parrallel__Result&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @PIPEasp_Types.ASP_Parrallel_Result.");
}
return *this;
}

ASP__Parrallel__Result_template& ASP__Parrallel__Result_template::operator=(const ASP__Parrallel__Result_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ASP__Parrallel__Result_template::match(const ASP__Parrallel__Result& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.p__id().is_bound()) return FALSE;
if(!single_value->field_p__id.match(other_value.p__id(), legacy))return FALSE;
if(!other_value.result().is_bound()) return FALSE;
if(!single_value->field_result.match(other_value.result(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
case CONJUNCTION_MATCH:
for (unsigned int i = 0; i < value_list.n_values; i++) {
if (!value_list.list_value[i].match(other_value)) {
return FALSE;
}
}
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match(other_value) || implication_.implied_template->match(other_value);
case DYNAMIC_MATCH:
return dyn_match->ptr->match(other_value);
default:
TTCN_error("Matching an uninitialized/unsupported template of type @PIPEasp_Types.ASP_Parrallel_Result.");
}
return FALSE;
}

boolean ASP__Parrallel__Result_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
return single_value->field_p__id.is_bound()
 || single_value->field_result.is_bound();
}

boolean ASP__Parrallel__Result_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value->field_p__id.is_value()
 && single_value->field_result.is_value();
}

void ASP__Parrallel__Result_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
case CONJUNCTION_MATCH:
delete [] value_list.list_value;
break;
case IMPLICATION_MATCH:
delete implication_.precondition;
delete implication_.implied_template;
break;
case DYNAMIC_MATCH:
dyn_match->ref_count--;
if (dyn_match->ref_count == 0) {
delete dyn_match->ptr;
delete dyn_match;
}
break;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ASP__Parrallel__Result ASP__Parrallel__Result_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @PIPEasp_Types.ASP_Parrallel_Result.");
ASP__Parrallel__Result ret_val;
if (single_value->field_p__id.is_bound()) {
ret_val.p__id() = single_value->field_p__id.valueof();
}
if (single_value->field_result.is_bound()) {
ret_val.result() = single_value->field_result.valueof();
}
return ret_val;
}

void ASP__Parrallel__Result_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST&& template_type != CONJUNCTION_MATCH)
TTCN_error("Setting an invalid list for a template of type @PIPEasp_Types.ASP_Parrallel_Result.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ASP__Parrallel__Result_template[list_length];
}

ASP__Parrallel__Result_template& ASP__Parrallel__Result_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST&& template_selection != CONJUNCTION_MATCH)
TTCN_error("Accessing a list element of a non-list template of type @PIPEasp_Types.ASP_Parrallel_Result.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @PIPEasp_Types.ASP_Parrallel_Result.");
return value_list.list_value[list_index];
}

INTEGER_template& ASP__Parrallel__Result_template::p__id()
{
set_specific();
return single_value->field_p__id;
}

const INTEGER_template& ASP__Parrallel__Result_template::p__id() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field p_id of a non-specific template of type @PIPEasp_Types.ASP_Parrallel_Result.");
return single_value->field_p__id;
}

ASP__Results_template& ASP__Parrallel__Result_template::result()
{
set_specific();
return single_value->field_result;
}

const ASP__Results_template& ASP__Parrallel__Result_template::result() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field result of a non-specific template of type @PIPEasp_Types.ASP_Parrallel_Result.");
return single_value->field_result;
}

int ASP__Parrallel__Result_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_Parrallel_Result which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_Parrallel_Result containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_Parrallel_Result containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_Parrallel_Result containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_Parrallel_Result containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_Parrallel_Result containing complemented list.");
  case CONJUNCTION_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_Parrallel_Result containing a conjunction list match.");
  case IMPLICATION_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_Parrallel_Result containing an implication match.");
  case DYNAMIC_MATCH:
    TTCN_error("Performing sizeof() operation on a template of type @PIPEasp_Types.ASP_Parrallel_Result containing a dynamic match.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @PIPEasp_Types.ASP_Parrallel_Result.");
  }
  return 0;
}

void ASP__Parrallel__Result_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ p_id := ");
single_value->field_p__id.log();
TTCN_Logger::log_event_str(", result := ");
single_value->field_result.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case CONJUNCTION_MATCH:
if (template_selection == CONJUNCTION_MATCH) {
TTCN_Logger::log_event_str("conjunct");
}
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
case IMPLICATION_MATCH:
implication_.precondition->log();
TTCN_Logger::log_event_str(" implies ");
implication_.implied_template->log();
break;
case DYNAMIC_MATCH:
TTCN_Logger::log_event_str("@dynamic template");
break;
default:
log_generic();
}
log_ifpresent();
}

void ASP__Parrallel__Result_template::log_match(const ASP__Parrallel__Result& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_p__id.match(match_value.p__id(), legacy)){
TTCN_Logger::log_logmatch_info(".p_id");
single_value->field_p__id.log_match(match_value.p__id(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_result.match(match_value.result(), legacy)){
TTCN_Logger::log_logmatch_info(".result");
single_value->field_result.log_match(match_value.result(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ p_id := ");
single_value->field_p__id.log_match(match_value.p__id(), legacy);
TTCN_Logger::log_event_str(", result := ");
single_value->field_result.log_match(match_value.result(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ASP__Parrallel__Result_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_p__id.encode_text(text_buf);
single_value->field_result.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @PIPEasp_Types.ASP_Parrallel_Result.");
}
}

void ASP__Parrallel__Result_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_p__id.decode_text(text_buf);
single_value->field_result.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ASP__Parrallel__Result_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @PIPEasp_Types.ASP_Parrallel_Result.");
}
}

void ASP__Parrallel__Result_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template:
  case Module_Param::MP_ConjunctList_Template: {
    ASP__Parrallel__Result_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : (param.get_type() == Module_Param::MP_ConjunctList_Template ? CONJUNCTION_MATCH : COMPLEMENTED_LIST), param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record template of type @PIPEasp_Types.ASP_Parrallel_Result has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) p__id().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) result().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "p_id")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          p__id().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "result")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          result().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      curr_param->error("Non existent field name in type @PIPEasp_Types.ASP_Parrallel_Result: %s", curr_param->get_id()->get_name());
      break;
    }
  } break;
  case Module_Param::MP_Implication_Template: {
    ASP__Parrallel__Result_template* precondition = new ASP__Parrallel__Result_template;
    precondition->set_param(*param.get_elem(0));
    ASP__Parrallel__Result_template* implied_template = new ASP__Parrallel__Result_template;
    implied_template->set_param(*param.get_elem(1));
    *this = ASP__Parrallel__Result_template(precondition, implied_template);
  } break;
  default:
    param.type_error("record template", "@PIPEasp_Types.ASP_Parrallel_Result");
  }
  is_ifpresent = param.get_ifpresent();
}

void ASP__Parrallel__Result_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_p__id.check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_Parrallel_Result");
single_value->field_result.check_restriction(t_res, t_name ? t_name : "@PIPEasp_Types.ASP_Parrallel_Result");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@PIPEasp_Types.ASP_Parrallel_Result");
}

boolean ASP__Parrallel__Result_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ASP__Parrallel__Result_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case IMPLICATION_MATCH:
return !implication_.precondition->match_omit() || implication_.implied_template->match_omit();
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


/* Bodies of functions, altsteps and testcases */

boolean operator==(null_type, const ASP__PEndOfInput& other_value)
{
other_value.must_bound("Comparison of an unbound value of type @PIPEasp_Types.ASP_PEndOfInput.");
return TRUE;
}


/* Bodies of static functions */

static void pre_init_module()
{
TTCN_Location current_location("PIPEasp_Types.ttcn", 0, TTCN_Location::LOCATION_UNKNOWN, "PIPEasp_Types");
module_object.add_function("f_PIPE_WIFEXITED", (genericfunc_t)&f__PIPE__WIFEXITED, NULL);
module_object.add_function("f_PIPE_WEXITSTATUS", (genericfunc_t)&f__PIPE__WEXITSTATUS, NULL);
module_object.add_function("f_PIPE_WIFSIGNALED", (genericfunc_t)&f__PIPE__WIFSIGNALED, NULL);
module_object.add_function("f_PIPE_WTERMSIG", (genericfunc_t)&f__PIPE__WTERMSIG, NULL);
}


} /* end of namespace */
