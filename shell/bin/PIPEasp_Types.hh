// This C++ header file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version 11.0.0
// for hyconsoft_rnd (hyconsoft_rnd@hyconsoft) on Wed Dec 11 13:55:00 2024

// Copyright (c) 2000-2024 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

#ifndef PIPEasp__Types_HH
#define PIPEasp__Types_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include <TTCN3.hh>

#if TTCN3_VERSION != 110000
#error Version mismatch detected.\
 Please check the version of the TTCN-3 compiler and the base library.\
 Run make clean and rebuild the project if the version of the compiler changed recently.
#endif

#ifndef LINUX
#error This file should be compiled on LINUX
#endif

#undef PIPEasp__Types_HH
#endif

namespace PIPEasp__Types {

/* Forward declarations of classes */

class ASP__PExecute;
class ASP__PExecute_template;
class ASP__PExecutePty;
class ASP__PExecutePty_template;
class ASP__PResult;
class ASP__PResult_template;
class ASP__PExecuteBinary;
class ASP__PExecuteBinary_template;
class ASP__PExecuteBinaryPty;
class ASP__PExecuteBinaryPty_template;
class ASP__PResultBinary;
class ASP__PResultBinary_template;
class ASP__PExecuteBackground;
class ASP__PExecuteBackground_template;
class ASP__PExecuteBackgroundPty;
class ASP__PExecuteBackgroundPty_template;
class ASP__PStdin;
class ASP__PStdin_template;
class ASP__PStdout;
class ASP__PStdout_template;
class ASP__PStderr;
class ASP__PStderr_template;
class ASP__PStdinBinary;
class ASP__PStdinBinary_template;
class ASP__PStdoutBinary;
class ASP__PStdoutBinary_template;
class ASP__PStderrBinary;
class ASP__PStderrBinary_template;
class ASP__PKill;
class ASP__PKill_template;
class ASP__PExit;
class ASP__PExit_template;
class ASP__PLineMode;
class ASP__PLineMode_template;
class ASP__PError;
class ASP__PError_template;
class ASP__PEndOfInput;
class ASP__PEndOfInput_template;
class ASP__Commands;
class ASP__Commands_template;
class ASP__Parallel__Command;
class ASP__Parallel__Command_template;
class ASP__Results;
class ASP__Results_template;
class ASP__Parrallel__Result;
class ASP__Parrallel__Result_template;

} /* end of namespace */

#ifndef PIPEasp__Types_HH
#define PIPEasp__Types_HH

namespace PIPEasp__Types {

/* Class definitions */

class ASP__PExecute {
  CHARSTRING field_command;
  CHARSTRING field_stdin_;
public:
  ASP__PExecute();
  ASP__PExecute(const CHARSTRING& par_command,
    const CHARSTRING& par_stdin_);
  ASP__PExecute(const ASP__PExecute& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
const TTCN_Typedescriptor_t* get_descriptor() const;
  ASP__PExecute& operator=(const ASP__PExecute& other_value);
  boolean operator==(const ASP__PExecute& other_value) const;
  inline boolean operator!=(const ASP__PExecute& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline CHARSTRING& command()
    {return field_command;}
  inline const CHARSTRING& command() const
    {return field_command;}
  inline CHARSTRING& stdin_()
    {return field_stdin_;}
  inline const CHARSTRING& stdin_() const
    {return field_stdin_;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_implicit_omit();
  void set_param(Module_Param& param);
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class ASP__PExecute_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ASP__PExecute_template *list_value;
} value_list;
struct {
ASP__PExecute_template* precondition;
ASP__PExecute_template* implied_template;
} implication_;
dynmatch_struct<ASP__PExecute>* dyn_match;
};

void set_specific();
void copy_value(const ASP__PExecute& other_value);
void copy_template(const ASP__PExecute_template& other_value);

public:
ASP__PExecute_template();
ASP__PExecute_template(template_sel other_value);
ASP__PExecute_template(const ASP__PExecute& other_value);
ASP__PExecute_template(const OPTIONAL<ASP__PExecute>& other_value);
ASP__PExecute_template(ASP__PExecute_template* p_precondition, ASP__PExecute_template* p_implied_template);
ASP__PExecute_template(Dynamic_Match_Interface<ASP__PExecute>* p_dyn_match);
ASP__PExecute_template(const ASP__PExecute_template& other_value);
~ASP__PExecute_template();
ASP__PExecute_template& operator=(template_sel other_value);
ASP__PExecute_template& operator=(const ASP__PExecute& other_value);
ASP__PExecute_template& operator=(const OPTIONAL<ASP__PExecute>& other_value);
ASP__PExecute_template& operator=(const ASP__PExecute_template& other_value);
boolean match(const ASP__PExecute& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ASP__PExecute valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ASP__PExecute_template& list_item(unsigned int list_index) const;
CHARSTRING_template& command();
const CHARSTRING_template& command() const;
CHARSTRING_template& stdin_();
const CHARSTRING_template& stdin_() const;
int size_of() const;
void log() const;
void log_match(const ASP__PExecute& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ASP__PExecutePty {
  CHARSTRING field_command;
  CHARSTRING field_stdin_;
public:
  ASP__PExecutePty();
  ASP__PExecutePty(const CHARSTRING& par_command,
    const CHARSTRING& par_stdin_);
  ASP__PExecutePty(const ASP__PExecutePty& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
const TTCN_Typedescriptor_t* get_descriptor() const;
  ASP__PExecutePty& operator=(const ASP__PExecutePty& other_value);
  boolean operator==(const ASP__PExecutePty& other_value) const;
  inline boolean operator!=(const ASP__PExecutePty& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline CHARSTRING& command()
    {return field_command;}
  inline const CHARSTRING& command() const
    {return field_command;}
  inline CHARSTRING& stdin_()
    {return field_stdin_;}
  inline const CHARSTRING& stdin_() const
    {return field_stdin_;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_implicit_omit();
  void set_param(Module_Param& param);
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class ASP__PExecutePty_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ASP__PExecutePty_template *list_value;
} value_list;
struct {
ASP__PExecutePty_template* precondition;
ASP__PExecutePty_template* implied_template;
} implication_;
dynmatch_struct<ASP__PExecutePty>* dyn_match;
};

void set_specific();
void copy_value(const ASP__PExecutePty& other_value);
void copy_template(const ASP__PExecutePty_template& other_value);

public:
ASP__PExecutePty_template();
ASP__PExecutePty_template(template_sel other_value);
ASP__PExecutePty_template(const ASP__PExecutePty& other_value);
ASP__PExecutePty_template(const OPTIONAL<ASP__PExecutePty>& other_value);
ASP__PExecutePty_template(ASP__PExecutePty_template* p_precondition, ASP__PExecutePty_template* p_implied_template);
ASP__PExecutePty_template(Dynamic_Match_Interface<ASP__PExecutePty>* p_dyn_match);
ASP__PExecutePty_template(const ASP__PExecutePty_template& other_value);
~ASP__PExecutePty_template();
ASP__PExecutePty_template& operator=(template_sel other_value);
ASP__PExecutePty_template& operator=(const ASP__PExecutePty& other_value);
ASP__PExecutePty_template& operator=(const OPTIONAL<ASP__PExecutePty>& other_value);
ASP__PExecutePty_template& operator=(const ASP__PExecutePty_template& other_value);
boolean match(const ASP__PExecutePty& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ASP__PExecutePty valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ASP__PExecutePty_template& list_item(unsigned int list_index) const;
CHARSTRING_template& command();
const CHARSTRING_template& command() const;
CHARSTRING_template& stdin_();
const CHARSTRING_template& stdin_() const;
int size_of() const;
void log() const;
void log_match(const ASP__PExecutePty& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ASP__PResult {
  CHARSTRING field_stdout_;
  CHARSTRING field_stderr_;
  INTEGER field_code;
public:
  ASP__PResult();
  ASP__PResult(const CHARSTRING& par_stdout_,
    const CHARSTRING& par_stderr_,
    const INTEGER& par_code);
  ASP__PResult(const ASP__PResult& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
const TTCN_Typedescriptor_t* get_descriptor() const;
  ASP__PResult& operator=(const ASP__PResult& other_value);
  boolean operator==(const ASP__PResult& other_value) const;
  inline boolean operator!=(const ASP__PResult& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline CHARSTRING& stdout_()
    {return field_stdout_;}
  inline const CHARSTRING& stdout_() const
    {return field_stdout_;}
  inline CHARSTRING& stderr_()
    {return field_stderr_;}
  inline const CHARSTRING& stderr_() const
    {return field_stderr_;}
  inline INTEGER& code()
    {return field_code;}
  inline const INTEGER& code() const
    {return field_code;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_implicit_omit();
  void set_param(Module_Param& param);
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class ASP__PResult_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ASP__PResult_template *list_value;
} value_list;
struct {
ASP__PResult_template* precondition;
ASP__PResult_template* implied_template;
} implication_;
dynmatch_struct<ASP__PResult>* dyn_match;
};

void set_specific();
void copy_value(const ASP__PResult& other_value);
void copy_template(const ASP__PResult_template& other_value);

public:
ASP__PResult_template();
ASP__PResult_template(template_sel other_value);
ASP__PResult_template(const ASP__PResult& other_value);
ASP__PResult_template(const OPTIONAL<ASP__PResult>& other_value);
ASP__PResult_template(ASP__PResult_template* p_precondition, ASP__PResult_template* p_implied_template);
ASP__PResult_template(Dynamic_Match_Interface<ASP__PResult>* p_dyn_match);
ASP__PResult_template(const ASP__PResult_template& other_value);
~ASP__PResult_template();
ASP__PResult_template& operator=(template_sel other_value);
ASP__PResult_template& operator=(const ASP__PResult& other_value);
ASP__PResult_template& operator=(const OPTIONAL<ASP__PResult>& other_value);
ASP__PResult_template& operator=(const ASP__PResult_template& other_value);
boolean match(const ASP__PResult& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ASP__PResult valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ASP__PResult_template& list_item(unsigned int list_index) const;
CHARSTRING_template& stdout_();
const CHARSTRING_template& stdout_() const;
CHARSTRING_template& stderr_();
const CHARSTRING_template& stderr_() const;
INTEGER_template& code();
const INTEGER_template& code() const;
int size_of() const;
void log() const;
void log_match(const ASP__PResult& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ASP__PExecuteBinary {
  CHARSTRING field_command;
  OCTETSTRING field_stdin_;
public:
  ASP__PExecuteBinary();
  ASP__PExecuteBinary(const CHARSTRING& par_command,
    const OCTETSTRING& par_stdin_);
  ASP__PExecuteBinary(const ASP__PExecuteBinary& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
const TTCN_Typedescriptor_t* get_descriptor() const;
  ASP__PExecuteBinary& operator=(const ASP__PExecuteBinary& other_value);
  boolean operator==(const ASP__PExecuteBinary& other_value) const;
  inline boolean operator!=(const ASP__PExecuteBinary& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline CHARSTRING& command()
    {return field_command;}
  inline const CHARSTRING& command() const
    {return field_command;}
  inline OCTETSTRING& stdin_()
    {return field_stdin_;}
  inline const OCTETSTRING& stdin_() const
    {return field_stdin_;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_implicit_omit();
  void set_param(Module_Param& param);
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class ASP__PExecuteBinary_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ASP__PExecuteBinary_template *list_value;
} value_list;
struct {
ASP__PExecuteBinary_template* precondition;
ASP__PExecuteBinary_template* implied_template;
} implication_;
dynmatch_struct<ASP__PExecuteBinary>* dyn_match;
};

void set_specific();
void copy_value(const ASP__PExecuteBinary& other_value);
void copy_template(const ASP__PExecuteBinary_template& other_value);

public:
ASP__PExecuteBinary_template();
ASP__PExecuteBinary_template(template_sel other_value);
ASP__PExecuteBinary_template(const ASP__PExecuteBinary& other_value);
ASP__PExecuteBinary_template(const OPTIONAL<ASP__PExecuteBinary>& other_value);
ASP__PExecuteBinary_template(ASP__PExecuteBinary_template* p_precondition, ASP__PExecuteBinary_template* p_implied_template);
ASP__PExecuteBinary_template(Dynamic_Match_Interface<ASP__PExecuteBinary>* p_dyn_match);
ASP__PExecuteBinary_template(const ASP__PExecuteBinary_template& other_value);
~ASP__PExecuteBinary_template();
ASP__PExecuteBinary_template& operator=(template_sel other_value);
ASP__PExecuteBinary_template& operator=(const ASP__PExecuteBinary& other_value);
ASP__PExecuteBinary_template& operator=(const OPTIONAL<ASP__PExecuteBinary>& other_value);
ASP__PExecuteBinary_template& operator=(const ASP__PExecuteBinary_template& other_value);
boolean match(const ASP__PExecuteBinary& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ASP__PExecuteBinary valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ASP__PExecuteBinary_template& list_item(unsigned int list_index) const;
CHARSTRING_template& command();
const CHARSTRING_template& command() const;
OCTETSTRING_template& stdin_();
const OCTETSTRING_template& stdin_() const;
int size_of() const;
void log() const;
void log_match(const ASP__PExecuteBinary& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ASP__PExecuteBinaryPty {
  CHARSTRING field_command;
  OCTETSTRING field_stdin_;
public:
  ASP__PExecuteBinaryPty();
  ASP__PExecuteBinaryPty(const CHARSTRING& par_command,
    const OCTETSTRING& par_stdin_);
  ASP__PExecuteBinaryPty(const ASP__PExecuteBinaryPty& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
const TTCN_Typedescriptor_t* get_descriptor() const;
  ASP__PExecuteBinaryPty& operator=(const ASP__PExecuteBinaryPty& other_value);
  boolean operator==(const ASP__PExecuteBinaryPty& other_value) const;
  inline boolean operator!=(const ASP__PExecuteBinaryPty& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline CHARSTRING& command()
    {return field_command;}
  inline const CHARSTRING& command() const
    {return field_command;}
  inline OCTETSTRING& stdin_()
    {return field_stdin_;}
  inline const OCTETSTRING& stdin_() const
    {return field_stdin_;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_implicit_omit();
  void set_param(Module_Param& param);
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class ASP__PExecuteBinaryPty_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ASP__PExecuteBinaryPty_template *list_value;
} value_list;
struct {
ASP__PExecuteBinaryPty_template* precondition;
ASP__PExecuteBinaryPty_template* implied_template;
} implication_;
dynmatch_struct<ASP__PExecuteBinaryPty>* dyn_match;
};

void set_specific();
void copy_value(const ASP__PExecuteBinaryPty& other_value);
void copy_template(const ASP__PExecuteBinaryPty_template& other_value);

public:
ASP__PExecuteBinaryPty_template();
ASP__PExecuteBinaryPty_template(template_sel other_value);
ASP__PExecuteBinaryPty_template(const ASP__PExecuteBinaryPty& other_value);
ASP__PExecuteBinaryPty_template(const OPTIONAL<ASP__PExecuteBinaryPty>& other_value);
ASP__PExecuteBinaryPty_template(ASP__PExecuteBinaryPty_template* p_precondition, ASP__PExecuteBinaryPty_template* p_implied_template);
ASP__PExecuteBinaryPty_template(Dynamic_Match_Interface<ASP__PExecuteBinaryPty>* p_dyn_match);
ASP__PExecuteBinaryPty_template(const ASP__PExecuteBinaryPty_template& other_value);
~ASP__PExecuteBinaryPty_template();
ASP__PExecuteBinaryPty_template& operator=(template_sel other_value);
ASP__PExecuteBinaryPty_template& operator=(const ASP__PExecuteBinaryPty& other_value);
ASP__PExecuteBinaryPty_template& operator=(const OPTIONAL<ASP__PExecuteBinaryPty>& other_value);
ASP__PExecuteBinaryPty_template& operator=(const ASP__PExecuteBinaryPty_template& other_value);
boolean match(const ASP__PExecuteBinaryPty& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ASP__PExecuteBinaryPty valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ASP__PExecuteBinaryPty_template& list_item(unsigned int list_index) const;
CHARSTRING_template& command();
const CHARSTRING_template& command() const;
OCTETSTRING_template& stdin_();
const OCTETSTRING_template& stdin_() const;
int size_of() const;
void log() const;
void log_match(const ASP__PExecuteBinaryPty& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ASP__PResultBinary {
  OCTETSTRING field_stdout_;
  OCTETSTRING field_stderr_;
  INTEGER field_code;
public:
  ASP__PResultBinary();
  ASP__PResultBinary(const OCTETSTRING& par_stdout_,
    const OCTETSTRING& par_stderr_,
    const INTEGER& par_code);
  ASP__PResultBinary(const ASP__PResultBinary& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
const TTCN_Typedescriptor_t* get_descriptor() const;
  ASP__PResultBinary& operator=(const ASP__PResultBinary& other_value);
  boolean operator==(const ASP__PResultBinary& other_value) const;
  inline boolean operator!=(const ASP__PResultBinary& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OCTETSTRING& stdout_()
    {return field_stdout_;}
  inline const OCTETSTRING& stdout_() const
    {return field_stdout_;}
  inline OCTETSTRING& stderr_()
    {return field_stderr_;}
  inline const OCTETSTRING& stderr_() const
    {return field_stderr_;}
  inline INTEGER& code()
    {return field_code;}
  inline const INTEGER& code() const
    {return field_code;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_implicit_omit();
  void set_param(Module_Param& param);
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class ASP__PResultBinary_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ASP__PResultBinary_template *list_value;
} value_list;
struct {
ASP__PResultBinary_template* precondition;
ASP__PResultBinary_template* implied_template;
} implication_;
dynmatch_struct<ASP__PResultBinary>* dyn_match;
};

void set_specific();
void copy_value(const ASP__PResultBinary& other_value);
void copy_template(const ASP__PResultBinary_template& other_value);

public:
ASP__PResultBinary_template();
ASP__PResultBinary_template(template_sel other_value);
ASP__PResultBinary_template(const ASP__PResultBinary& other_value);
ASP__PResultBinary_template(const OPTIONAL<ASP__PResultBinary>& other_value);
ASP__PResultBinary_template(ASP__PResultBinary_template* p_precondition, ASP__PResultBinary_template* p_implied_template);
ASP__PResultBinary_template(Dynamic_Match_Interface<ASP__PResultBinary>* p_dyn_match);
ASP__PResultBinary_template(const ASP__PResultBinary_template& other_value);
~ASP__PResultBinary_template();
ASP__PResultBinary_template& operator=(template_sel other_value);
ASP__PResultBinary_template& operator=(const ASP__PResultBinary& other_value);
ASP__PResultBinary_template& operator=(const OPTIONAL<ASP__PResultBinary>& other_value);
ASP__PResultBinary_template& operator=(const ASP__PResultBinary_template& other_value);
boolean match(const ASP__PResultBinary& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ASP__PResultBinary valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ASP__PResultBinary_template& list_item(unsigned int list_index) const;
OCTETSTRING_template& stdout_();
const OCTETSTRING_template& stdout_() const;
OCTETSTRING_template& stderr_();
const OCTETSTRING_template& stderr_() const;
INTEGER_template& code();
const INTEGER_template& code() const;
int size_of() const;
void log() const;
void log_match(const ASP__PResultBinary& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ASP__PExecuteBackground {
  CHARSTRING field_command;
public:
  ASP__PExecuteBackground();
  ASP__PExecuteBackground(const CHARSTRING& par_command);
  ASP__PExecuteBackground(const ASP__PExecuteBackground& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
const TTCN_Typedescriptor_t* get_descriptor() const;
  ASP__PExecuteBackground& operator=(const ASP__PExecuteBackground& other_value);
  boolean operator==(const ASP__PExecuteBackground& other_value) const;
  inline boolean operator!=(const ASP__PExecuteBackground& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline CHARSTRING& command()
    {return field_command;}
  inline const CHARSTRING& command() const
    {return field_command;}
  inline int size_of() const
    {return 1;}
  void log() const;
  void set_implicit_omit();
  void set_param(Module_Param& param);
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class ASP__PExecuteBackground_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ASP__PExecuteBackground_template *list_value;
} value_list;
struct {
ASP__PExecuteBackground_template* precondition;
ASP__PExecuteBackground_template* implied_template;
} implication_;
dynmatch_struct<ASP__PExecuteBackground>* dyn_match;
};

void set_specific();
void copy_value(const ASP__PExecuteBackground& other_value);
void copy_template(const ASP__PExecuteBackground_template& other_value);

public:
ASP__PExecuteBackground_template();
ASP__PExecuteBackground_template(template_sel other_value);
ASP__PExecuteBackground_template(const ASP__PExecuteBackground& other_value);
ASP__PExecuteBackground_template(const OPTIONAL<ASP__PExecuteBackground>& other_value);
ASP__PExecuteBackground_template(ASP__PExecuteBackground_template* p_precondition, ASP__PExecuteBackground_template* p_implied_template);
ASP__PExecuteBackground_template(Dynamic_Match_Interface<ASP__PExecuteBackground>* p_dyn_match);
ASP__PExecuteBackground_template(const ASP__PExecuteBackground_template& other_value);
~ASP__PExecuteBackground_template();
ASP__PExecuteBackground_template& operator=(template_sel other_value);
ASP__PExecuteBackground_template& operator=(const ASP__PExecuteBackground& other_value);
ASP__PExecuteBackground_template& operator=(const OPTIONAL<ASP__PExecuteBackground>& other_value);
ASP__PExecuteBackground_template& operator=(const ASP__PExecuteBackground_template& other_value);
boolean match(const ASP__PExecuteBackground& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ASP__PExecuteBackground valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ASP__PExecuteBackground_template& list_item(unsigned int list_index) const;
CHARSTRING_template& command();
const CHARSTRING_template& command() const;
int size_of() const;
void log() const;
void log_match(const ASP__PExecuteBackground& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ASP__PExecuteBackgroundPty {
  CHARSTRING field_command;
public:
  ASP__PExecuteBackgroundPty();
  ASP__PExecuteBackgroundPty(const CHARSTRING& par_command);
  ASP__PExecuteBackgroundPty(const ASP__PExecuteBackgroundPty& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
const TTCN_Typedescriptor_t* get_descriptor() const;
  ASP__PExecuteBackgroundPty& operator=(const ASP__PExecuteBackgroundPty& other_value);
  boolean operator==(const ASP__PExecuteBackgroundPty& other_value) const;
  inline boolean operator!=(const ASP__PExecuteBackgroundPty& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline CHARSTRING& command()
    {return field_command;}
  inline const CHARSTRING& command() const
    {return field_command;}
  inline int size_of() const
    {return 1;}
  void log() const;
  void set_implicit_omit();
  void set_param(Module_Param& param);
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class ASP__PExecuteBackgroundPty_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ASP__PExecuteBackgroundPty_template *list_value;
} value_list;
struct {
ASP__PExecuteBackgroundPty_template* precondition;
ASP__PExecuteBackgroundPty_template* implied_template;
} implication_;
dynmatch_struct<ASP__PExecuteBackgroundPty>* dyn_match;
};

void set_specific();
void copy_value(const ASP__PExecuteBackgroundPty& other_value);
void copy_template(const ASP__PExecuteBackgroundPty_template& other_value);

public:
ASP__PExecuteBackgroundPty_template();
ASP__PExecuteBackgroundPty_template(template_sel other_value);
ASP__PExecuteBackgroundPty_template(const ASP__PExecuteBackgroundPty& other_value);
ASP__PExecuteBackgroundPty_template(const OPTIONAL<ASP__PExecuteBackgroundPty>& other_value);
ASP__PExecuteBackgroundPty_template(ASP__PExecuteBackgroundPty_template* p_precondition, ASP__PExecuteBackgroundPty_template* p_implied_template);
ASP__PExecuteBackgroundPty_template(Dynamic_Match_Interface<ASP__PExecuteBackgroundPty>* p_dyn_match);
ASP__PExecuteBackgroundPty_template(const ASP__PExecuteBackgroundPty_template& other_value);
~ASP__PExecuteBackgroundPty_template();
ASP__PExecuteBackgroundPty_template& operator=(template_sel other_value);
ASP__PExecuteBackgroundPty_template& operator=(const ASP__PExecuteBackgroundPty& other_value);
ASP__PExecuteBackgroundPty_template& operator=(const OPTIONAL<ASP__PExecuteBackgroundPty>& other_value);
ASP__PExecuteBackgroundPty_template& operator=(const ASP__PExecuteBackgroundPty_template& other_value);
boolean match(const ASP__PExecuteBackgroundPty& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ASP__PExecuteBackgroundPty valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ASP__PExecuteBackgroundPty_template& list_item(unsigned int list_index) const;
CHARSTRING_template& command();
const CHARSTRING_template& command() const;
int size_of() const;
void log() const;
void log_match(const ASP__PExecuteBackgroundPty& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ASP__PStdin {
  CHARSTRING field_stdin_;
public:
  ASP__PStdin();
  ASP__PStdin(const CHARSTRING& par_stdin_);
  ASP__PStdin(const ASP__PStdin& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
const TTCN_Typedescriptor_t* get_descriptor() const;
  ASP__PStdin& operator=(const ASP__PStdin& other_value);
  boolean operator==(const ASP__PStdin& other_value) const;
  inline boolean operator!=(const ASP__PStdin& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline CHARSTRING& stdin_()
    {return field_stdin_;}
  inline const CHARSTRING& stdin_() const
    {return field_stdin_;}
  inline int size_of() const
    {return 1;}
  void log() const;
  void set_implicit_omit();
  void set_param(Module_Param& param);
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class ASP__PStdin_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ASP__PStdin_template *list_value;
} value_list;
struct {
ASP__PStdin_template* precondition;
ASP__PStdin_template* implied_template;
} implication_;
dynmatch_struct<ASP__PStdin>* dyn_match;
};

void set_specific();
void copy_value(const ASP__PStdin& other_value);
void copy_template(const ASP__PStdin_template& other_value);

public:
ASP__PStdin_template();
ASP__PStdin_template(template_sel other_value);
ASP__PStdin_template(const ASP__PStdin& other_value);
ASP__PStdin_template(const OPTIONAL<ASP__PStdin>& other_value);
ASP__PStdin_template(ASP__PStdin_template* p_precondition, ASP__PStdin_template* p_implied_template);
ASP__PStdin_template(Dynamic_Match_Interface<ASP__PStdin>* p_dyn_match);
ASP__PStdin_template(const ASP__PStdin_template& other_value);
~ASP__PStdin_template();
ASP__PStdin_template& operator=(template_sel other_value);
ASP__PStdin_template& operator=(const ASP__PStdin& other_value);
ASP__PStdin_template& operator=(const OPTIONAL<ASP__PStdin>& other_value);
ASP__PStdin_template& operator=(const ASP__PStdin_template& other_value);
boolean match(const ASP__PStdin& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ASP__PStdin valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ASP__PStdin_template& list_item(unsigned int list_index) const;
CHARSTRING_template& stdin_();
const CHARSTRING_template& stdin_() const;
int size_of() const;
void log() const;
void log_match(const ASP__PStdin& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ASP__PStdout {
  CHARSTRING field_stdout_;
public:
  ASP__PStdout();
  ASP__PStdout(const CHARSTRING& par_stdout_);
  ASP__PStdout(const ASP__PStdout& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
const TTCN_Typedescriptor_t* get_descriptor() const;
  ASP__PStdout& operator=(const ASP__PStdout& other_value);
  boolean operator==(const ASP__PStdout& other_value) const;
  inline boolean operator!=(const ASP__PStdout& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline CHARSTRING& stdout_()
    {return field_stdout_;}
  inline const CHARSTRING& stdout_() const
    {return field_stdout_;}
  inline int size_of() const
    {return 1;}
  void log() const;
  void set_implicit_omit();
  void set_param(Module_Param& param);
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class ASP__PStdout_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ASP__PStdout_template *list_value;
} value_list;
struct {
ASP__PStdout_template* precondition;
ASP__PStdout_template* implied_template;
} implication_;
dynmatch_struct<ASP__PStdout>* dyn_match;
};

void set_specific();
void copy_value(const ASP__PStdout& other_value);
void copy_template(const ASP__PStdout_template& other_value);

public:
ASP__PStdout_template();
ASP__PStdout_template(template_sel other_value);
ASP__PStdout_template(const ASP__PStdout& other_value);
ASP__PStdout_template(const OPTIONAL<ASP__PStdout>& other_value);
ASP__PStdout_template(ASP__PStdout_template* p_precondition, ASP__PStdout_template* p_implied_template);
ASP__PStdout_template(Dynamic_Match_Interface<ASP__PStdout>* p_dyn_match);
ASP__PStdout_template(const ASP__PStdout_template& other_value);
~ASP__PStdout_template();
ASP__PStdout_template& operator=(template_sel other_value);
ASP__PStdout_template& operator=(const ASP__PStdout& other_value);
ASP__PStdout_template& operator=(const OPTIONAL<ASP__PStdout>& other_value);
ASP__PStdout_template& operator=(const ASP__PStdout_template& other_value);
boolean match(const ASP__PStdout& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ASP__PStdout valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ASP__PStdout_template& list_item(unsigned int list_index) const;
CHARSTRING_template& stdout_();
const CHARSTRING_template& stdout_() const;
int size_of() const;
void log() const;
void log_match(const ASP__PStdout& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ASP__PStderr {
  CHARSTRING field_stderr_;
public:
  ASP__PStderr();
  ASP__PStderr(const CHARSTRING& par_stderr_);
  ASP__PStderr(const ASP__PStderr& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
const TTCN_Typedescriptor_t* get_descriptor() const;
  ASP__PStderr& operator=(const ASP__PStderr& other_value);
  boolean operator==(const ASP__PStderr& other_value) const;
  inline boolean operator!=(const ASP__PStderr& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline CHARSTRING& stderr_()
    {return field_stderr_;}
  inline const CHARSTRING& stderr_() const
    {return field_stderr_;}
  inline int size_of() const
    {return 1;}
  void log() const;
  void set_implicit_omit();
  void set_param(Module_Param& param);
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class ASP__PStderr_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ASP__PStderr_template *list_value;
} value_list;
struct {
ASP__PStderr_template* precondition;
ASP__PStderr_template* implied_template;
} implication_;
dynmatch_struct<ASP__PStderr>* dyn_match;
};

void set_specific();
void copy_value(const ASP__PStderr& other_value);
void copy_template(const ASP__PStderr_template& other_value);

public:
ASP__PStderr_template();
ASP__PStderr_template(template_sel other_value);
ASP__PStderr_template(const ASP__PStderr& other_value);
ASP__PStderr_template(const OPTIONAL<ASP__PStderr>& other_value);
ASP__PStderr_template(ASP__PStderr_template* p_precondition, ASP__PStderr_template* p_implied_template);
ASP__PStderr_template(Dynamic_Match_Interface<ASP__PStderr>* p_dyn_match);
ASP__PStderr_template(const ASP__PStderr_template& other_value);
~ASP__PStderr_template();
ASP__PStderr_template& operator=(template_sel other_value);
ASP__PStderr_template& operator=(const ASP__PStderr& other_value);
ASP__PStderr_template& operator=(const OPTIONAL<ASP__PStderr>& other_value);
ASP__PStderr_template& operator=(const ASP__PStderr_template& other_value);
boolean match(const ASP__PStderr& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ASP__PStderr valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ASP__PStderr_template& list_item(unsigned int list_index) const;
CHARSTRING_template& stderr_();
const CHARSTRING_template& stderr_() const;
int size_of() const;
void log() const;
void log_match(const ASP__PStderr& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ASP__PStdinBinary {
  OCTETSTRING field_stdin_;
public:
  ASP__PStdinBinary();
  ASP__PStdinBinary(const OCTETSTRING& par_stdin_);
  ASP__PStdinBinary(const ASP__PStdinBinary& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
const TTCN_Typedescriptor_t* get_descriptor() const;
  ASP__PStdinBinary& operator=(const ASP__PStdinBinary& other_value);
  boolean operator==(const ASP__PStdinBinary& other_value) const;
  inline boolean operator!=(const ASP__PStdinBinary& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OCTETSTRING& stdin_()
    {return field_stdin_;}
  inline const OCTETSTRING& stdin_() const
    {return field_stdin_;}
  inline int size_of() const
    {return 1;}
  void log() const;
  void set_implicit_omit();
  void set_param(Module_Param& param);
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class ASP__PStdinBinary_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ASP__PStdinBinary_template *list_value;
} value_list;
struct {
ASP__PStdinBinary_template* precondition;
ASP__PStdinBinary_template* implied_template;
} implication_;
dynmatch_struct<ASP__PStdinBinary>* dyn_match;
};

void set_specific();
void copy_value(const ASP__PStdinBinary& other_value);
void copy_template(const ASP__PStdinBinary_template& other_value);

public:
ASP__PStdinBinary_template();
ASP__PStdinBinary_template(template_sel other_value);
ASP__PStdinBinary_template(const ASP__PStdinBinary& other_value);
ASP__PStdinBinary_template(const OPTIONAL<ASP__PStdinBinary>& other_value);
ASP__PStdinBinary_template(ASP__PStdinBinary_template* p_precondition, ASP__PStdinBinary_template* p_implied_template);
ASP__PStdinBinary_template(Dynamic_Match_Interface<ASP__PStdinBinary>* p_dyn_match);
ASP__PStdinBinary_template(const ASP__PStdinBinary_template& other_value);
~ASP__PStdinBinary_template();
ASP__PStdinBinary_template& operator=(template_sel other_value);
ASP__PStdinBinary_template& operator=(const ASP__PStdinBinary& other_value);
ASP__PStdinBinary_template& operator=(const OPTIONAL<ASP__PStdinBinary>& other_value);
ASP__PStdinBinary_template& operator=(const ASP__PStdinBinary_template& other_value);
boolean match(const ASP__PStdinBinary& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ASP__PStdinBinary valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ASP__PStdinBinary_template& list_item(unsigned int list_index) const;
OCTETSTRING_template& stdin_();
const OCTETSTRING_template& stdin_() const;
int size_of() const;
void log() const;
void log_match(const ASP__PStdinBinary& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ASP__PStdoutBinary {
  OCTETSTRING field_stdout_;
public:
  ASP__PStdoutBinary();
  ASP__PStdoutBinary(const OCTETSTRING& par_stdout_);
  ASP__PStdoutBinary(const ASP__PStdoutBinary& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
const TTCN_Typedescriptor_t* get_descriptor() const;
  ASP__PStdoutBinary& operator=(const ASP__PStdoutBinary& other_value);
  boolean operator==(const ASP__PStdoutBinary& other_value) const;
  inline boolean operator!=(const ASP__PStdoutBinary& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OCTETSTRING& stdout_()
    {return field_stdout_;}
  inline const OCTETSTRING& stdout_() const
    {return field_stdout_;}
  inline int size_of() const
    {return 1;}
  void log() const;
  void set_implicit_omit();
  void set_param(Module_Param& param);
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class ASP__PStdoutBinary_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ASP__PStdoutBinary_template *list_value;
} value_list;
struct {
ASP__PStdoutBinary_template* precondition;
ASP__PStdoutBinary_template* implied_template;
} implication_;
dynmatch_struct<ASP__PStdoutBinary>* dyn_match;
};

void set_specific();
void copy_value(const ASP__PStdoutBinary& other_value);
void copy_template(const ASP__PStdoutBinary_template& other_value);

public:
ASP__PStdoutBinary_template();
ASP__PStdoutBinary_template(template_sel other_value);
ASP__PStdoutBinary_template(const ASP__PStdoutBinary& other_value);
ASP__PStdoutBinary_template(const OPTIONAL<ASP__PStdoutBinary>& other_value);
ASP__PStdoutBinary_template(ASP__PStdoutBinary_template* p_precondition, ASP__PStdoutBinary_template* p_implied_template);
ASP__PStdoutBinary_template(Dynamic_Match_Interface<ASP__PStdoutBinary>* p_dyn_match);
ASP__PStdoutBinary_template(const ASP__PStdoutBinary_template& other_value);
~ASP__PStdoutBinary_template();
ASP__PStdoutBinary_template& operator=(template_sel other_value);
ASP__PStdoutBinary_template& operator=(const ASP__PStdoutBinary& other_value);
ASP__PStdoutBinary_template& operator=(const OPTIONAL<ASP__PStdoutBinary>& other_value);
ASP__PStdoutBinary_template& operator=(const ASP__PStdoutBinary_template& other_value);
boolean match(const ASP__PStdoutBinary& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ASP__PStdoutBinary valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ASP__PStdoutBinary_template& list_item(unsigned int list_index) const;
OCTETSTRING_template& stdout_();
const OCTETSTRING_template& stdout_() const;
int size_of() const;
void log() const;
void log_match(const ASP__PStdoutBinary& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ASP__PStderrBinary {
  OCTETSTRING field_stderr_;
public:
  ASP__PStderrBinary();
  ASP__PStderrBinary(const OCTETSTRING& par_stderr_);
  ASP__PStderrBinary(const ASP__PStderrBinary& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
const TTCN_Typedescriptor_t* get_descriptor() const;
  ASP__PStderrBinary& operator=(const ASP__PStderrBinary& other_value);
  boolean operator==(const ASP__PStderrBinary& other_value) const;
  inline boolean operator!=(const ASP__PStderrBinary& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OCTETSTRING& stderr_()
    {return field_stderr_;}
  inline const OCTETSTRING& stderr_() const
    {return field_stderr_;}
  inline int size_of() const
    {return 1;}
  void log() const;
  void set_implicit_omit();
  void set_param(Module_Param& param);
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class ASP__PStderrBinary_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ASP__PStderrBinary_template *list_value;
} value_list;
struct {
ASP__PStderrBinary_template* precondition;
ASP__PStderrBinary_template* implied_template;
} implication_;
dynmatch_struct<ASP__PStderrBinary>* dyn_match;
};

void set_specific();
void copy_value(const ASP__PStderrBinary& other_value);
void copy_template(const ASP__PStderrBinary_template& other_value);

public:
ASP__PStderrBinary_template();
ASP__PStderrBinary_template(template_sel other_value);
ASP__PStderrBinary_template(const ASP__PStderrBinary& other_value);
ASP__PStderrBinary_template(const OPTIONAL<ASP__PStderrBinary>& other_value);
ASP__PStderrBinary_template(ASP__PStderrBinary_template* p_precondition, ASP__PStderrBinary_template* p_implied_template);
ASP__PStderrBinary_template(Dynamic_Match_Interface<ASP__PStderrBinary>* p_dyn_match);
ASP__PStderrBinary_template(const ASP__PStderrBinary_template& other_value);
~ASP__PStderrBinary_template();
ASP__PStderrBinary_template& operator=(template_sel other_value);
ASP__PStderrBinary_template& operator=(const ASP__PStderrBinary& other_value);
ASP__PStderrBinary_template& operator=(const OPTIONAL<ASP__PStderrBinary>& other_value);
ASP__PStderrBinary_template& operator=(const ASP__PStderrBinary_template& other_value);
boolean match(const ASP__PStderrBinary& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ASP__PStderrBinary valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ASP__PStderrBinary_template& list_item(unsigned int list_index) const;
OCTETSTRING_template& stderr_();
const OCTETSTRING_template& stderr_() const;
int size_of() const;
void log() const;
void log_match(const ASP__PStderrBinary& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ASP__PKill {
  INTEGER field_signal;
public:
  ASP__PKill();
  ASP__PKill(const INTEGER& par_signal);
  ASP__PKill(const ASP__PKill& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
const TTCN_Typedescriptor_t* get_descriptor() const;
  ASP__PKill& operator=(const ASP__PKill& other_value);
  boolean operator==(const ASP__PKill& other_value) const;
  inline boolean operator!=(const ASP__PKill& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& signal()
    {return field_signal;}
  inline const INTEGER& signal() const
    {return field_signal;}
  inline int size_of() const
    {return 1;}
  void log() const;
  void set_implicit_omit();
  void set_param(Module_Param& param);
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class ASP__PKill_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ASP__PKill_template *list_value;
} value_list;
struct {
ASP__PKill_template* precondition;
ASP__PKill_template* implied_template;
} implication_;
dynmatch_struct<ASP__PKill>* dyn_match;
};

void set_specific();
void copy_value(const ASP__PKill& other_value);
void copy_template(const ASP__PKill_template& other_value);

public:
ASP__PKill_template();
ASP__PKill_template(template_sel other_value);
ASP__PKill_template(const ASP__PKill& other_value);
ASP__PKill_template(const OPTIONAL<ASP__PKill>& other_value);
ASP__PKill_template(ASP__PKill_template* p_precondition, ASP__PKill_template* p_implied_template);
ASP__PKill_template(Dynamic_Match_Interface<ASP__PKill>* p_dyn_match);
ASP__PKill_template(const ASP__PKill_template& other_value);
~ASP__PKill_template();
ASP__PKill_template& operator=(template_sel other_value);
ASP__PKill_template& operator=(const ASP__PKill& other_value);
ASP__PKill_template& operator=(const OPTIONAL<ASP__PKill>& other_value);
ASP__PKill_template& operator=(const ASP__PKill_template& other_value);
boolean match(const ASP__PKill& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ASP__PKill valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ASP__PKill_template& list_item(unsigned int list_index) const;
INTEGER_template& signal();
const INTEGER_template& signal() const;
int size_of() const;
void log() const;
void log_match(const ASP__PKill& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ASP__PExit {
  INTEGER field_code;
public:
  ASP__PExit();
  ASP__PExit(const INTEGER& par_code);
  ASP__PExit(const ASP__PExit& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
const TTCN_Typedescriptor_t* get_descriptor() const;
  ASP__PExit& operator=(const ASP__PExit& other_value);
  boolean operator==(const ASP__PExit& other_value) const;
  inline boolean operator!=(const ASP__PExit& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& code()
    {return field_code;}
  inline const INTEGER& code() const
    {return field_code;}
  inline int size_of() const
    {return 1;}
  void log() const;
  void set_implicit_omit();
  void set_param(Module_Param& param);
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class ASP__PExit_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ASP__PExit_template *list_value;
} value_list;
struct {
ASP__PExit_template* precondition;
ASP__PExit_template* implied_template;
} implication_;
dynmatch_struct<ASP__PExit>* dyn_match;
};

void set_specific();
void copy_value(const ASP__PExit& other_value);
void copy_template(const ASP__PExit_template& other_value);

public:
ASP__PExit_template();
ASP__PExit_template(template_sel other_value);
ASP__PExit_template(const ASP__PExit& other_value);
ASP__PExit_template(const OPTIONAL<ASP__PExit>& other_value);
ASP__PExit_template(ASP__PExit_template* p_precondition, ASP__PExit_template* p_implied_template);
ASP__PExit_template(Dynamic_Match_Interface<ASP__PExit>* p_dyn_match);
ASP__PExit_template(const ASP__PExit_template& other_value);
~ASP__PExit_template();
ASP__PExit_template& operator=(template_sel other_value);
ASP__PExit_template& operator=(const ASP__PExit& other_value);
ASP__PExit_template& operator=(const OPTIONAL<ASP__PExit>& other_value);
ASP__PExit_template& operator=(const ASP__PExit_template& other_value);
boolean match(const ASP__PExit& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ASP__PExit valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ASP__PExit_template& list_item(unsigned int list_index) const;
INTEGER_template& code();
const INTEGER_template& code() const;
int size_of() const;
void log() const;
void log_match(const ASP__PExit& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ASP__PLineMode {
  BOOLEAN field_lineMode;
public:
  ASP__PLineMode();
  ASP__PLineMode(const BOOLEAN& par_lineMode);
  ASP__PLineMode(const ASP__PLineMode& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
const TTCN_Typedescriptor_t* get_descriptor() const;
  ASP__PLineMode& operator=(const ASP__PLineMode& other_value);
  boolean operator==(const ASP__PLineMode& other_value) const;
  inline boolean operator!=(const ASP__PLineMode& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline BOOLEAN& lineMode()
    {return field_lineMode;}
  inline const BOOLEAN& lineMode() const
    {return field_lineMode;}
  inline int size_of() const
    {return 1;}
  void log() const;
  void set_implicit_omit();
  void set_param(Module_Param& param);
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class ASP__PLineMode_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ASP__PLineMode_template *list_value;
} value_list;
struct {
ASP__PLineMode_template* precondition;
ASP__PLineMode_template* implied_template;
} implication_;
dynmatch_struct<ASP__PLineMode>* dyn_match;
};

void set_specific();
void copy_value(const ASP__PLineMode& other_value);
void copy_template(const ASP__PLineMode_template& other_value);

public:
ASP__PLineMode_template();
ASP__PLineMode_template(template_sel other_value);
ASP__PLineMode_template(const ASP__PLineMode& other_value);
ASP__PLineMode_template(const OPTIONAL<ASP__PLineMode>& other_value);
ASP__PLineMode_template(ASP__PLineMode_template* p_precondition, ASP__PLineMode_template* p_implied_template);
ASP__PLineMode_template(Dynamic_Match_Interface<ASP__PLineMode>* p_dyn_match);
ASP__PLineMode_template(const ASP__PLineMode_template& other_value);
~ASP__PLineMode_template();
ASP__PLineMode_template& operator=(template_sel other_value);
ASP__PLineMode_template& operator=(const ASP__PLineMode& other_value);
ASP__PLineMode_template& operator=(const OPTIONAL<ASP__PLineMode>& other_value);
ASP__PLineMode_template& operator=(const ASP__PLineMode_template& other_value);
boolean match(const ASP__PLineMode& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ASP__PLineMode valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ASP__PLineMode_template& list_item(unsigned int list_index) const;
BOOLEAN_template& lineMode();
const BOOLEAN_template& lineMode() const;
int size_of() const;
void log() const;
void log_match(const ASP__PLineMode& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ASP__PError {
  CHARSTRING field_errorMessage;
public:
  ASP__PError();
  ASP__PError(const CHARSTRING& par_errorMessage);
  ASP__PError(const ASP__PError& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
const TTCN_Typedescriptor_t* get_descriptor() const;
  ASP__PError& operator=(const ASP__PError& other_value);
  boolean operator==(const ASP__PError& other_value) const;
  inline boolean operator!=(const ASP__PError& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline CHARSTRING& errorMessage()
    {return field_errorMessage;}
  inline const CHARSTRING& errorMessage() const
    {return field_errorMessage;}
  inline int size_of() const
    {return 1;}
  void log() const;
  void set_implicit_omit();
  void set_param(Module_Param& param);
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class ASP__PError_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ASP__PError_template *list_value;
} value_list;
struct {
ASP__PError_template* precondition;
ASP__PError_template* implied_template;
} implication_;
dynmatch_struct<ASP__PError>* dyn_match;
};

void set_specific();
void copy_value(const ASP__PError& other_value);
void copy_template(const ASP__PError_template& other_value);

public:
ASP__PError_template();
ASP__PError_template(template_sel other_value);
ASP__PError_template(const ASP__PError& other_value);
ASP__PError_template(const OPTIONAL<ASP__PError>& other_value);
ASP__PError_template(ASP__PError_template* p_precondition, ASP__PError_template* p_implied_template);
ASP__PError_template(Dynamic_Match_Interface<ASP__PError>* p_dyn_match);
ASP__PError_template(const ASP__PError_template& other_value);
~ASP__PError_template();
ASP__PError_template& operator=(template_sel other_value);
ASP__PError_template& operator=(const ASP__PError& other_value);
ASP__PError_template& operator=(const OPTIONAL<ASP__PError>& other_value);
ASP__PError_template& operator=(const ASP__PError_template& other_value);
boolean match(const ASP__PError& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ASP__PError valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ASP__PError_template& list_item(unsigned int list_index) const;
CHARSTRING_template& errorMessage();
const CHARSTRING_template& errorMessage() const;
int size_of() const;
void log() const;
void log_match(const ASP__PError& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ASP__PEndOfInput : public Base_Type {
boolean bound_flag;
public:
ASP__PEndOfInput();
ASP__PEndOfInput(null_type other_value);
ASP__PEndOfInput(const ASP__PEndOfInput& other_value);
ASP__PEndOfInput& operator=(null_type other_value);
ASP__PEndOfInput& operator=(const ASP__PEndOfInput& other_value);
boolean operator==(null_type other_value) const;
boolean operator==(const ASP__PEndOfInput& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const ASP__PEndOfInput& other_value) const { return !(*this == other_value); }
inline boolean is_bound() const { return bound_flag; }
inline boolean is_present() const { return is_bound(); }
inline boolean is_value() const { return bound_flag; }
inline void clean_up() { bound_flag = FALSE; }
inline void must_bound(const char *err_msg) const { if (!bound_flag) TTCN_error("%s", err_msg); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class ASP__PEndOfInput_template : public Base_Template {
union {
struct {
unsigned int n_values;
ASP__PEndOfInput_template *list_value;
} value_list;
struct {
ASP__PEndOfInput_template* precondition;
ASP__PEndOfInput_template* implied_template;
} implication_;
dynmatch_struct<ASP__PEndOfInput>* dyn_match;
};
void copy_template(const ASP__PEndOfInput_template& other_value);

public:
ASP__PEndOfInput_template();
ASP__PEndOfInput_template(template_sel other_value);
ASP__PEndOfInput_template(null_type other_value);
ASP__PEndOfInput_template(const ASP__PEndOfInput& other_value);
ASP__PEndOfInput_template(const OPTIONAL<ASP__PEndOfInput>& other_value);
ASP__PEndOfInput_template(ASP__PEndOfInput_template* p_precondition, ASP__PEndOfInput_template* p_implied_template);
ASP__PEndOfInput_template(Dynamic_Match_Interface<ASP__PEndOfInput>* p_dyn_match);
ASP__PEndOfInput_template(const ASP__PEndOfInput_template& other_value);
~ASP__PEndOfInput_template();
void clean_up();
ASP__PEndOfInput_template& operator=(template_sel other_value);
ASP__PEndOfInput_template& operator=(null_type other_value);
ASP__PEndOfInput_template& operator=(const ASP__PEndOfInput& other_value);
ASP__PEndOfInput_template& operator=(const OPTIONAL<ASP__PEndOfInput>& other_value);
ASP__PEndOfInput_template& operator=(const ASP__PEndOfInput_template& other_value);
boolean match(null_type other_value, boolean legacy = FALSE) const;
boolean match(const ASP__PEndOfInput& other_value, boolean legacy = FALSE) const;
ASP__PEndOfInput valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ASP__PEndOfInput_template& list_item(unsigned int list_index) const;
void log() const;
void log_match(const ASP__PEndOfInput& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ASP__Commands : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_pexecute = 1, ALT_pexecutePty = 2, ALT_pexecuteBinary = 3, ALT_pexecuteBinaryPty = 4, ALT_pexecuteBackground = 5, ALT_pexecuteBackgroundPty = 6, ALT_pStdin = 7, ALT_pStdinBinary = 8, ALT_pKill = 9, ALT_pEndOfInput = 10 };
private:
union_selection_type union_selection;
union {
ASP__PExecute *field_pexecute;
ASP__PExecutePty *field_pexecutePty;
ASP__PExecuteBinary *field_pexecuteBinary;
ASP__PExecuteBinaryPty *field_pexecuteBinaryPty;
ASP__PExecuteBackground *field_pexecuteBackground;
ASP__PExecuteBackgroundPty *field_pexecuteBackgroundPty;
ASP__PStdin *field_pStdin;
ASP__PStdinBinary *field_pStdinBinary;
ASP__PKill *field_pKill;
ASP__PEndOfInput *field_pEndOfInput;
};
void copy_value(const ASP__Commands& other_value);

public:
ASP__Commands();
ASP__Commands(const ASP__Commands& other_value);
~ASP__Commands();
ASP__Commands& operator=(const ASP__Commands& other_value);
boolean operator==(const ASP__Commands& other_value) const;
inline boolean operator!=(const ASP__Commands& other_value) const { return !(*this == other_value); }
ASP__PExecute& pexecute();
const ASP__PExecute& pexecute() const;
ASP__PExecutePty& pexecutePty();
const ASP__PExecutePty& pexecutePty() const;
ASP__PExecuteBinary& pexecuteBinary();
const ASP__PExecuteBinary& pexecuteBinary() const;
ASP__PExecuteBinaryPty& pexecuteBinaryPty();
const ASP__PExecuteBinaryPty& pexecuteBinaryPty() const;
ASP__PExecuteBackground& pexecuteBackground();
const ASP__PExecuteBackground& pexecuteBackground() const;
ASP__PExecuteBackgroundPty& pexecuteBackgroundPty();
const ASP__PExecuteBackgroundPty& pexecuteBackgroundPty() const;
ASP__PStdin& pStdin();
const ASP__PStdin& pStdin() const;
ASP__PStdinBinary& pStdinBinary();
const ASP__PStdinBinary& pStdinBinary() const;
ASP__PKill& pKill();
const ASP__PKill& pKill() const;
ASP__PEndOfInput& pEndOfInput();
const ASP__PEndOfInput& pEndOfInput() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class ASP__Commands_template : public Base_Template {
union {
struct {
ASP__Commands::union_selection_type union_selection;
union {
ASP__PExecute_template *field_pexecute;
ASP__PExecutePty_template *field_pexecutePty;
ASP__PExecuteBinary_template *field_pexecuteBinary;
ASP__PExecuteBinaryPty_template *field_pexecuteBinaryPty;
ASP__PExecuteBackground_template *field_pexecuteBackground;
ASP__PExecuteBackgroundPty_template *field_pexecuteBackgroundPty;
ASP__PStdin_template *field_pStdin;
ASP__PStdinBinary_template *field_pStdinBinary;
ASP__PKill_template *field_pKill;
ASP__PEndOfInput_template *field_pEndOfInput;
};
} single_value;
struct {
unsigned int n_values;
ASP__Commands_template *list_value;
} value_list;
struct {
ASP__Commands_template* precondition;
ASP__Commands_template* implied_template;
} implication_;
dynmatch_struct<ASP__Commands>* dyn_match;
};
void copy_value(const ASP__Commands& other_value);

void copy_template(const ASP__Commands_template& other_value);

public:
ASP__Commands_template();
ASP__Commands_template(template_sel other_value);
ASP__Commands_template(const ASP__Commands& other_value);
ASP__Commands_template(const OPTIONAL<ASP__Commands>& other_value);
ASP__Commands_template(ASP__Commands_template* p_precondition, ASP__Commands_template* p_implied_template);
ASP__Commands_template(Dynamic_Match_Interface<ASP__Commands>* p_dyn_match);
ASP__Commands_template(const ASP__Commands_template& other_value);
~ASP__Commands_template();
void clean_up();
ASP__Commands_template& operator=(template_sel other_value);
ASP__Commands_template& operator=(const ASP__Commands& other_value);
ASP__Commands_template& operator=(const OPTIONAL<ASP__Commands>& other_value);
ASP__Commands_template& operator=(const ASP__Commands_template& other_value);
boolean match(const ASP__Commands& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ASP__Commands valueof() const;
ASP__Commands_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
ASP__PExecute_template& pexecute();
const ASP__PExecute_template& pexecute() const;
ASP__PExecutePty_template& pexecutePty();
const ASP__PExecutePty_template& pexecutePty() const;
ASP__PExecuteBinary_template& pexecuteBinary();
const ASP__PExecuteBinary_template& pexecuteBinary() const;
ASP__PExecuteBinaryPty_template& pexecuteBinaryPty();
const ASP__PExecuteBinaryPty_template& pexecuteBinaryPty() const;
ASP__PExecuteBackground_template& pexecuteBackground();
const ASP__PExecuteBackground_template& pexecuteBackground() const;
ASP__PExecuteBackgroundPty_template& pexecuteBackgroundPty();
const ASP__PExecuteBackgroundPty_template& pexecuteBackgroundPty() const;
ASP__PStdin_template& pStdin();
const ASP__PStdin_template& pStdin() const;
ASP__PStdinBinary_template& pStdinBinary();
const ASP__PStdinBinary_template& pStdinBinary() const;
ASP__PKill_template& pKill();
const ASP__PKill_template& pKill() const;
ASP__PEndOfInput_template& pEndOfInput();
const ASP__PEndOfInput_template& pEndOfInput() const;
boolean ischosen(ASP__Commands::union_selection_type checked_selection) const;
void log() const;
void log_match(const ASP__Commands& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ASP__Parallel__Command {
  INTEGER field_p__id;
  ASP__Commands field_command;
public:
  ASP__Parallel__Command();
  ASP__Parallel__Command(const INTEGER& par_p__id,
    const ASP__Commands& par_command);
  ASP__Parallel__Command(const ASP__Parallel__Command& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
const TTCN_Typedescriptor_t* get_descriptor() const;
  ASP__Parallel__Command& operator=(const ASP__Parallel__Command& other_value);
  boolean operator==(const ASP__Parallel__Command& other_value) const;
  inline boolean operator!=(const ASP__Parallel__Command& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& p__id()
    {return field_p__id;}
  inline const INTEGER& p__id() const
    {return field_p__id;}
  inline ASP__Commands& command()
    {return field_command;}
  inline const ASP__Commands& command() const
    {return field_command;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_implicit_omit();
  void set_param(Module_Param& param);
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class ASP__Parallel__Command_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ASP__Parallel__Command_template *list_value;
} value_list;
struct {
ASP__Parallel__Command_template* precondition;
ASP__Parallel__Command_template* implied_template;
} implication_;
dynmatch_struct<ASP__Parallel__Command>* dyn_match;
};

void set_specific();
void copy_value(const ASP__Parallel__Command& other_value);
void copy_template(const ASP__Parallel__Command_template& other_value);

public:
ASP__Parallel__Command_template();
ASP__Parallel__Command_template(template_sel other_value);
ASP__Parallel__Command_template(const ASP__Parallel__Command& other_value);
ASP__Parallel__Command_template(const OPTIONAL<ASP__Parallel__Command>& other_value);
ASP__Parallel__Command_template(ASP__Parallel__Command_template* p_precondition, ASP__Parallel__Command_template* p_implied_template);
ASP__Parallel__Command_template(Dynamic_Match_Interface<ASP__Parallel__Command>* p_dyn_match);
ASP__Parallel__Command_template(const ASP__Parallel__Command_template& other_value);
~ASP__Parallel__Command_template();
ASP__Parallel__Command_template& operator=(template_sel other_value);
ASP__Parallel__Command_template& operator=(const ASP__Parallel__Command& other_value);
ASP__Parallel__Command_template& operator=(const OPTIONAL<ASP__Parallel__Command>& other_value);
ASP__Parallel__Command_template& operator=(const ASP__Parallel__Command_template& other_value);
boolean match(const ASP__Parallel__Command& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ASP__Parallel__Command valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ASP__Parallel__Command_template& list_item(unsigned int list_index) const;
INTEGER_template& p__id();
const INTEGER_template& p__id() const;
ASP__Commands_template& command();
const ASP__Commands_template& command() const;
int size_of() const;
void log() const;
void log_match(const ASP__Parallel__Command& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ASP__Results : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_pResult = 1, ALT_pResultBinary = 2, ALT_pStdout = 3, ALT_pStderr = 4, ALT_pStdoutBinary = 5, ALT_pStedrrBinary = 6, ALT_pExit = 7, ALT_pError = 8 };
private:
union_selection_type union_selection;
union {
ASP__PResult *field_pResult;
ASP__PResultBinary *field_pResultBinary;
ASP__PStdout *field_pStdout;
ASP__PStderr *field_pStderr;
ASP__PStdoutBinary *field_pStdoutBinary;
ASP__PStderrBinary *field_pStedrrBinary;
ASP__PExit *field_pExit;
ASP__PError *field_pError;
};
void copy_value(const ASP__Results& other_value);

public:
ASP__Results();
ASP__Results(const ASP__Results& other_value);
~ASP__Results();
ASP__Results& operator=(const ASP__Results& other_value);
boolean operator==(const ASP__Results& other_value) const;
inline boolean operator!=(const ASP__Results& other_value) const { return !(*this == other_value); }
ASP__PResult& pResult();
const ASP__PResult& pResult() const;
ASP__PResultBinary& pResultBinary();
const ASP__PResultBinary& pResultBinary() const;
ASP__PStdout& pStdout();
const ASP__PStdout& pStdout() const;
ASP__PStderr& pStderr();
const ASP__PStderr& pStderr() const;
ASP__PStdoutBinary& pStdoutBinary();
const ASP__PStdoutBinary& pStdoutBinary() const;
ASP__PStderrBinary& pStedrrBinary();
const ASP__PStderrBinary& pStedrrBinary() const;
ASP__PExit& pExit();
const ASP__PExit& pExit() const;
ASP__PError& pError();
const ASP__PError& pError() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class ASP__Results_template : public Base_Template {
union {
struct {
ASP__Results::union_selection_type union_selection;
union {
ASP__PResult_template *field_pResult;
ASP__PResultBinary_template *field_pResultBinary;
ASP__PStdout_template *field_pStdout;
ASP__PStderr_template *field_pStderr;
ASP__PStdoutBinary_template *field_pStdoutBinary;
ASP__PStderrBinary_template *field_pStedrrBinary;
ASP__PExit_template *field_pExit;
ASP__PError_template *field_pError;
};
} single_value;
struct {
unsigned int n_values;
ASP__Results_template *list_value;
} value_list;
struct {
ASP__Results_template* precondition;
ASP__Results_template* implied_template;
} implication_;
dynmatch_struct<ASP__Results>* dyn_match;
};
void copy_value(const ASP__Results& other_value);

void copy_template(const ASP__Results_template& other_value);

public:
ASP__Results_template();
ASP__Results_template(template_sel other_value);
ASP__Results_template(const ASP__Results& other_value);
ASP__Results_template(const OPTIONAL<ASP__Results>& other_value);
ASP__Results_template(ASP__Results_template* p_precondition, ASP__Results_template* p_implied_template);
ASP__Results_template(Dynamic_Match_Interface<ASP__Results>* p_dyn_match);
ASP__Results_template(const ASP__Results_template& other_value);
~ASP__Results_template();
void clean_up();
ASP__Results_template& operator=(template_sel other_value);
ASP__Results_template& operator=(const ASP__Results& other_value);
ASP__Results_template& operator=(const OPTIONAL<ASP__Results>& other_value);
ASP__Results_template& operator=(const ASP__Results_template& other_value);
boolean match(const ASP__Results& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ASP__Results valueof() const;
ASP__Results_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
ASP__PResult_template& pResult();
const ASP__PResult_template& pResult() const;
ASP__PResultBinary_template& pResultBinary();
const ASP__PResultBinary_template& pResultBinary() const;
ASP__PStdout_template& pStdout();
const ASP__PStdout_template& pStdout() const;
ASP__PStderr_template& pStderr();
const ASP__PStderr_template& pStderr() const;
ASP__PStdoutBinary_template& pStdoutBinary();
const ASP__PStdoutBinary_template& pStdoutBinary() const;
ASP__PStderrBinary_template& pStedrrBinary();
const ASP__PStderrBinary_template& pStedrrBinary() const;
ASP__PExit_template& pExit();
const ASP__PExit_template& pExit() const;
ASP__PError_template& pError();
const ASP__PError_template& pError() const;
boolean ischosen(ASP__Results::union_selection_type checked_selection) const;
void log() const;
void log_match(const ASP__Results& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ASP__Parrallel__Result {
  INTEGER field_p__id;
  ASP__Results field_result;
public:
  ASP__Parrallel__Result();
  ASP__Parrallel__Result(const INTEGER& par_p__id,
    const ASP__Results& par_result);
  ASP__Parrallel__Result(const ASP__Parrallel__Result& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
const TTCN_Typedescriptor_t* get_descriptor() const;
  ASP__Parrallel__Result& operator=(const ASP__Parrallel__Result& other_value);
  boolean operator==(const ASP__Parrallel__Result& other_value) const;
  inline boolean operator!=(const ASP__Parrallel__Result& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& p__id()
    {return field_p__id;}
  inline const INTEGER& p__id() const
    {return field_p__id;}
  inline ASP__Results& result()
    {return field_result;}
  inline const ASP__Results& result() const
    {return field_result;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_implicit_omit();
  void set_param(Module_Param& param);
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class ASP__Parrallel__Result_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ASP__Parrallel__Result_template *list_value;
} value_list;
struct {
ASP__Parrallel__Result_template* precondition;
ASP__Parrallel__Result_template* implied_template;
} implication_;
dynmatch_struct<ASP__Parrallel__Result>* dyn_match;
};

void set_specific();
void copy_value(const ASP__Parrallel__Result& other_value);
void copy_template(const ASP__Parrallel__Result_template& other_value);

public:
ASP__Parrallel__Result_template();
ASP__Parrallel__Result_template(template_sel other_value);
ASP__Parrallel__Result_template(const ASP__Parrallel__Result& other_value);
ASP__Parrallel__Result_template(const OPTIONAL<ASP__Parrallel__Result>& other_value);
ASP__Parrallel__Result_template(ASP__Parrallel__Result_template* p_precondition, ASP__Parrallel__Result_template* p_implied_template);
ASP__Parrallel__Result_template(Dynamic_Match_Interface<ASP__Parrallel__Result>* p_dyn_match);
ASP__Parrallel__Result_template(const ASP__Parrallel__Result_template& other_value);
~ASP__Parrallel__Result_template();
ASP__Parrallel__Result_template& operator=(template_sel other_value);
ASP__Parrallel__Result_template& operator=(const ASP__Parrallel__Result& other_value);
ASP__Parrallel__Result_template& operator=(const OPTIONAL<ASP__Parrallel__Result>& other_value);
ASP__Parrallel__Result_template& operator=(const ASP__Parrallel__Result_template& other_value);
boolean match(const ASP__Parrallel__Result& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ASP__Parrallel__Result valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ASP__Parrallel__Result_template& list_item(unsigned int list_index) const;
INTEGER_template& p__id();
const INTEGER_template& p__id() const;
ASP__Results_template& result();
const ASP__Results_template& result() const;
int size_of() const;
void log() const;
void log_match(const ASP__Parrallel__Result& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};


/* Function prototypes */

extern BOOLEAN f__PIPE__WIFEXITED(const INTEGER& code);
extern INTEGER f__PIPE__WEXITSTATUS(const INTEGER& code);
extern BOOLEAN f__PIPE__WIFSIGNALED(const INTEGER& code);
extern INTEGER f__PIPE__WTERMSIG(const INTEGER& code);
extern boolean operator==(null_type null_value, const ASP__PEndOfInput& other_value);
inline boolean operator!=(null_type null_value, const ASP__PEndOfInput& other_value) { return !(null_value == other_value); }

/* Global variable declarations */

extern const XERdescriptor_t ASP__PExecute_command_xer_;
extern const TTCN_Typedescriptor_t ASP__PExecute_command_descr_;
extern const XERdescriptor_t ASP__PExecute_stdin__xer_;
extern const TTCN_Typedescriptor_t ASP__PExecute_stdin__descr_;
extern const TTCN_Typedescriptor_t ASP__PExecute_descr_;
extern const XERdescriptor_t ASP__PExecutePty_command_xer_;
extern const TTCN_Typedescriptor_t ASP__PExecutePty_command_descr_;
extern const XERdescriptor_t ASP__PExecutePty_stdin__xer_;
extern const TTCN_Typedescriptor_t ASP__PExecutePty_stdin__descr_;
extern const TTCN_Typedescriptor_t ASP__PExecutePty_descr_;
extern const XERdescriptor_t ASP__PResult_stdout__xer_;
extern const TTCN_Typedescriptor_t ASP__PResult_stdout__descr_;
extern const XERdescriptor_t ASP__PResult_stderr__xer_;
extern const TTCN_Typedescriptor_t ASP__PResult_stderr__descr_;
extern const XERdescriptor_t ASP__PResult_code_xer_;
extern const TTCN_Typedescriptor_t ASP__PResult_code_descr_;
extern const TTCN_Typedescriptor_t ASP__PResult_descr_;
extern const XERdescriptor_t ASP__PExecuteBinary_command_xer_;
extern const TTCN_Typedescriptor_t ASP__PExecuteBinary_command_descr_;
extern const XERdescriptor_t ASP__PExecuteBinary_stdin__xer_;
extern const TTCN_OERdescriptor_t ASP__PExecuteBinary_stdin__oer_;
extern const TTCN_Typedescriptor_t ASP__PExecuteBinary_stdin__descr_;
extern const TTCN_Typedescriptor_t ASP__PExecuteBinary_descr_;
extern const XERdescriptor_t ASP__PExecuteBinaryPty_command_xer_;
extern const TTCN_Typedescriptor_t ASP__PExecuteBinaryPty_command_descr_;
extern const XERdescriptor_t ASP__PExecuteBinaryPty_stdin__xer_;
extern const TTCN_OERdescriptor_t ASP__PExecuteBinaryPty_stdin__oer_;
extern const TTCN_Typedescriptor_t ASP__PExecuteBinaryPty_stdin__descr_;
extern const TTCN_Typedescriptor_t ASP__PExecuteBinaryPty_descr_;
extern const XERdescriptor_t ASP__PResultBinary_stdout__xer_;
extern const TTCN_OERdescriptor_t ASP__PResultBinary_stdout__oer_;
extern const TTCN_Typedescriptor_t ASP__PResultBinary_stdout__descr_;
extern const XERdescriptor_t ASP__PResultBinary_stderr__xer_;
extern const TTCN_OERdescriptor_t ASP__PResultBinary_stderr__oer_;
extern const TTCN_Typedescriptor_t ASP__PResultBinary_stderr__descr_;
extern const XERdescriptor_t ASP__PResultBinary_code_xer_;
extern const TTCN_Typedescriptor_t ASP__PResultBinary_code_descr_;
extern const TTCN_Typedescriptor_t ASP__PResultBinary_descr_;
extern const XERdescriptor_t ASP__PExecuteBackground_command_xer_;
extern const TTCN_Typedescriptor_t ASP__PExecuteBackground_command_descr_;
extern const TTCN_Typedescriptor_t ASP__PExecuteBackground_descr_;
extern const XERdescriptor_t ASP__PExecuteBackgroundPty_command_xer_;
extern const TTCN_Typedescriptor_t ASP__PExecuteBackgroundPty_command_descr_;
extern const TTCN_Typedescriptor_t ASP__PExecuteBackgroundPty_descr_;
extern const XERdescriptor_t ASP__PStdin_stdin__xer_;
extern const TTCN_Typedescriptor_t ASP__PStdin_stdin__descr_;
extern const TTCN_Typedescriptor_t ASP__PStdin_descr_;
extern const XERdescriptor_t ASP__PStdout_stdout__xer_;
extern const TTCN_Typedescriptor_t ASP__PStdout_stdout__descr_;
extern const TTCN_Typedescriptor_t ASP__PStdout_descr_;
extern const XERdescriptor_t ASP__PStderr_stderr__xer_;
extern const TTCN_Typedescriptor_t ASP__PStderr_stderr__descr_;
extern const TTCN_Typedescriptor_t ASP__PStderr_descr_;
extern const XERdescriptor_t ASP__PStdinBinary_stdin__xer_;
extern const TTCN_OERdescriptor_t ASP__PStdinBinary_stdin__oer_;
extern const TTCN_Typedescriptor_t ASP__PStdinBinary_stdin__descr_;
extern const TTCN_Typedescriptor_t ASP__PStdinBinary_descr_;
extern const XERdescriptor_t ASP__PStdoutBinary_stdout__xer_;
extern const TTCN_OERdescriptor_t ASP__PStdoutBinary_stdout__oer_;
extern const TTCN_Typedescriptor_t ASP__PStdoutBinary_stdout__descr_;
extern const TTCN_Typedescriptor_t ASP__PStdoutBinary_descr_;
extern const XERdescriptor_t ASP__PStderrBinary_stderr__xer_;
extern const TTCN_OERdescriptor_t ASP__PStderrBinary_stderr__oer_;
extern const TTCN_Typedescriptor_t ASP__PStderrBinary_stderr__descr_;
extern const TTCN_Typedescriptor_t ASP__PStderrBinary_descr_;
extern const XERdescriptor_t ASP__PKill_signal_xer_;
extern const TTCN_Typedescriptor_t ASP__PKill_signal_descr_;
extern const TTCN_Typedescriptor_t ASP__PKill_descr_;
extern const XERdescriptor_t ASP__PExit_code_xer_;
extern const TTCN_Typedescriptor_t ASP__PExit_code_descr_;
extern const TTCN_Typedescriptor_t ASP__PExit_descr_;
extern const XERdescriptor_t ASP__PLineMode_lineMode_xer_;
extern const TTCN_OERdescriptor_t ASP__PLineMode_lineMode_oer_;
extern const TTCN_Typedescriptor_t ASP__PLineMode_lineMode_descr_;
extern const TTCN_Typedescriptor_t ASP__PLineMode_descr_;
extern const XERdescriptor_t ASP__PError_errorMessage_xer_;
extern const TTCN_Typedescriptor_t ASP__PError_errorMessage_descr_;
extern const TTCN_Typedescriptor_t ASP__PError_descr_;
extern const TTCN_Typedescriptor_t ASP__PEndOfInput_descr_;
extern const XERdescriptor_t ASP__Parallel__Command_p__id_xer_;
extern const TTCN_Typedescriptor_t ASP__Parallel__Command_p__id_descr_;
extern const TTCN_Typedescriptor_t ASP__Commands_descr_;
extern const TTCN_Typedescriptor_t ASP__Parallel__Command_descr_;
extern const XERdescriptor_t ASP__Parrallel__Result_p__id_xer_;
extern const TTCN_Typedescriptor_t ASP__Parrallel__Result_p__id_descr_;
extern const TTCN_Typedescriptor_t ASP__Results_descr_;
extern const TTCN_Typedescriptor_t ASP__Parrallel__Result_descr_;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
